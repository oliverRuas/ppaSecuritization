'use strict';
const sinon = require('sinon');
const chai = require('chai');
const sinonChai = require('sinon-chai');
const expect = chai.expect;
const crypto=require('crypto')
const { Context, Transaction } = require('fabric-contract-api');
const { ChaincodeStub,ClientIdentity } = require('fabric-shim');

const SecuritizationContract = require('../lib/securitizationContract.js');
const { stub, mock } = require('sinon');
const { consumers } = require('stream');
const { doesNotThrow } = require('assert');

let assert = sinon.assert;
chai.use(sinonChai);




describe('Context Test', () =>{

    let ctx,contract,stub,clientIdentity;
    let sandbox,mockClientIdentity,mockStub;

    beforeEach(() => {
        sandbox = sinon.createSandbox();
        contract= new SecuritizationContract.ppaContract();
        ctx = new SecuritizationContract.securitizationContext();

        mockStub=sinon.createStubInstance(ChaincodeStub);
        ctx.stub= mockStub;
        mockClientIdentity=sinon.createStubInstance(ClientIdentity);
        ctx.clientIdentity=mockClientIdentity;

        mockStub.getState.callsFake(async (key) => {
            let ret;
            if (mockStub.states) {
                ret = mockStub.states[key];
            }
            return Promise.resolve(ret);
        });

        mockStub.deleteState.callsFake(async (key) => {
            if (mockStub.states) {
                delete mockStub.states[key];
            }
            return Promise.resolve(key);
        });

        mockStub.putState.callsFake((key, value) => {
            if (!mockStub.states) {
                mockStub.states = {};
            }
            mockStub.states[key] = value;
        });

        mockStub.getStateByPartialCompositeKey.callsFake(async () => {
            function* internalGetStateByPartialCompositeKey() {
                if (mockStub.states) {
                    // Shallow copy
                    const copied = Object.assign({}, mockStub.states);
                    for (let key in copied) {
                        yield {value: copied[key]};
                    }
                }
            }
            return Promise.resolve(internalGetStateByPartialCompositeKey());
        });
        mockStub.getHistoryForKey.callsFake(async () => {
            function* internalGetHistoryForKey() {
                if (mockStub.states) {
                    // Shallow copy
                    const copied = Object.assign({}, mockStub.states);
                    for (let key in copied) {
                        yield {value: copied[key]};
                    }
                }
            }
            return Promise.resolve(internalGetHistoryForKey());
        });

        // mockStub.putState.resolves('some state');
        // mockStub.setEvent.returns('set event');

    });

    afterEach('Sandbox restoration', () => {
        sandbox.restore();
    });
    describe('Testing: GetMSPID', ()=>{
        it('Should return mspid',async () =>{
            let org='originatorMSP'
            mockClientIdentity.getMSPID.returns(org);
            let ret=await ctx.GetMSPID()
            expect(ret).to.eql(org)
        })
    })
    describe('Testing: GetUserIdentity', ()=>{
        it('Should return user ID',async () =>{
            let userID='12345678P'
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(userID);
            let ret=await ctx.GetUserIdentity('cif')
            expect(ret).to.eql(userID)
        })
    })
    describe('Testing: GetRole', ()=>{
        it('Return true/false',async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            let ret=await ctx.GetRole()
            expect(ret).to.eql(true)
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            ret=await ctx.GetRole()
            expect(ret).to.eql(false)
        })
    })
    describe('Testing: SetMSPID', ()=>{
        it('Return NOTHING',async () =>{
            let org='originatorMSP'
            await ctx.SetMSPID(org)
            expect(org).to.eql(ctx.mspid)
        })
    })
    describe('Testing: SetEventPayload', ()=>{
        it('Return ',async () =>{
            let eventPayload={
                Content:'',
            };
            await ctx.SetEventPayload(Buffer.from(JSON.stringify(eventPayload)));
            expect(ctx.eventPayload).to.eql(Buffer.from(JSON.stringify(eventPayload)));
        })
    })
    describe('Testing: SetEventName', ()=>{
        it('Return ',async () =>{
            let eventName='EventName';
            await ctx.SetEventName(eventName);
            expect(ctx.eventName).to.eql(eventName)
        })
    })
    // Revisar ejecutando en la red
    describe('Testing: GetEventPayload', ()=>{
        it('Return event',async () =>{
            let eventName='EventName';
            let eventPayload={
                Content:'',
            };
            // First submit an event and its name
            await ctx.SetEventName(eventName);
            await ctx.SetEventPayload(Buffer.from(JSON.stringify(eventPayload)));

            // revisar esto ejecutando
            mockStub.setEvent.withArgs(eventName,Buffer.from(JSON.stringify(eventPayload))).returns();

            let ret=await ctx.GetEventPayload();
            //console.log(JSON.parse(ret.toString()))
            expect(ret).to.eql(eventPayload)
        })
    })
    describe('Testing: getDateTimestamp', ()=>{
        it('Return timestamp value',async () =>{
            let thisDate=new Date()
            // this function will return the server time, with this format
            mockStub.getDateTimestamp.returns(thisDate)

            let ret=await ctx.getDateTimestamp();
            expect(ret).to.eql(thisDate)
        })
    })
})



describe('Securitization-Origination Test. In this stage an Irrigator client will submit a request in order to subscribe a PPA. If this request is submitted, with its args, an originator client will submit a bespoke PPA Proposal linked to that irrigator client (to his/her digital certificate). Irrigator client will query this PPA and sign it. If it is signed, the originator client who has proposed that PPA can embed that PPA ID into a new UTXO state, the PPA Pool. After PPA is signed, irrigator client can request maintenance services, which will be reflected in the PPA state. Moreover, originator client will deliver electricity bill (an update of the PPA state), that must be paid before the limit date. This Payout function will transfer cash tokens from irrigator client to originator client or spv client depending on the ownership of the pool and the introduction of PPAID within the PPAPOOL', () => {

    let OwnerID,CustomerID
    //we define common variables within this scenario

    //igual hay que introducir mas
    let ctx,contract;
    let sandbox,mockClientIdentity,mockStub;

    let IrrigatorClientID,OriginatorClientID,TransactionID;
    let IrrigatorClientCert,IrrigatorClientCertAsBytes,OriginatorClientCert,OriginatorClientCertAsBytes;
    let Test,secret;
    let date;
    let argDate;
    let FunctionAndParameters;
    let Doctype;

    let ret;


    beforeEach(() => {
        sandbox = sinon.createSandbox();
        contract= new SecuritizationContract.ppaContract();
        ctx = new SecuritizationContract.securitizationContext();

        mockStub=sinon.createStubInstance(ChaincodeStub);
        ctx.stub= mockStub;
        mockClientIdentity=sinon.createStubInstance(ClientIdentity);
        ctx.clientIdentity=mockClientIdentity;

        mockStub.getState.callsFake(async (key) => {
            let ret;
            if (mockStub.states) {
                ret = mockStub.states[key];
            }
            return Promise.resolve(ret);
        });

        mockStub.deleteState.callsFake(async (key) => {
            if (mockStub.states) {
                delete mockStub.states[key];
            }
            return Promise.resolve(key);
        });

        mockStub.putState.callsFake((key, value) => {
            if (!mockStub.states) {
                mockStub.states = {};
            }
            mockStub.states[key] = value;
        });

        mockStub.getStateByPartialCompositeKey.callsFake( async() => {
            function* internalGetStateByPartialCompositeKey() {
                if (mockStub.states) {
                    // Shallow copy
                    const copied = Object.assign({}, mockStub.states);
                    for (let key in copied) {
                        yield {value: copied[key]};
                    }
                }
            }

            return Promise.resolve(internalGetStateByPartialCompositeKey());
            // return Promise.resolve(internalGetStateByPartialCompositeKey());
        });

        // string unique to each client which corresponds to 'cif' attribute of digital certificate

    });

    afterEach('Sandbox restoration', () => {
        sandbox.restore();
    });
    describe('Auxiliary function _isPoolCreated works as expected', () =>
    {
        let date;
        let poolName;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        beforeEach(() => {
            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10


            date=new Date()
            // argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('POOL').digest('hex');
            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientCertAsBytes,
                LastModificationOn: new Date(2022,1,20)
            };


        });
        it('Should return false if Pool has not been created', async () =>{
            await mockStub.getStateByPartialCompositeKey('POOL',[])
            let ret=await contract._isPoolCreated(ctx,poolName);
            expect(await ret).to.eql(false)
        });
        it ('Should return true if it only exists one POOL', async () => {
            await mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getStateByPartialCompositeKey('POOL',[])
            let ret=await contract._isPoolCreated(ctx,poolName);
            expect(ret).to.eql(true)
        });
        it ('Should throw an error if there are more than one State linked to that partial key', async () => {
            await mockStub.getStateByPartialCompositeKey('POOL',[])
            NewTransactionID=crypto.createHash('sha256', secret).update('NewTransactionID').digest('hex');
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            Pool.poolID='POOL'+NewTransactionID
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            try{
                await contract._isPoolCreated(ctx,poolName);
                assert.fail('_isPoolCreated should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`State not unique`);
            }
        });
    });
    describe('Auxiliary function _isPPAProposed works as expected', () =>
    {
        let date;
        let poolName;
        let Pool;
        let PPA;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let Irrigator1ClientID;
        beforeEach(() => {
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            // TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            // TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            // TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            // TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            // TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            // TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            // TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            // TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            // TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            // Irrigator2ClientCert="Irrigator2ClientCert";
            // Irrigator3ClientCert="Irrigator3ClientCert";
            // Irrigator4ClientCert="Irrigator4ClientCert";
            // Irrigator5ClientCert="Irrigator5ClientCert";
            // Irrigator6ClientCert="Irrigator6ClientCert";
            // Irrigator7ClientCert="Irrigator7ClientCert";
            // Irrigator8ClientCert="Irrigator8ClientCert";
            // Irrigator9ClientCert="Irrigator9ClientCert";
            // Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";
            Irrigator1ClientID="12345678A"


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            // Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            // Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            // Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            // Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            // Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            // Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            // Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            // Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            // Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            // ppaID2='PPA'+Irrigator2ClientCertAsBytes+TransactionID2
            // ppaID3='PPA'+Irrigator3ClientCertAsBytes+TransactionID3
            // ppaID4='PPA'+Irrigator4ClientCertAsBytes+TransactionID4
            // ppaID5='PPA'+Irrigator5ClientCertAsBytes+TransactionID5
            // ppaID6='PPA'+Irrigator6ClientCertAsBytes+TransactionID6
            // ppaID7='PPA'+Irrigator7ClientCertAsBytes+TransactionID7
            // ppaID8='PPA'+Irrigator8ClientCertAsBytes+TransactionID8
            // ppaID9='PPA'+Irrigator9ClientCertAsBytes+TransactionID9
            // ppaID10='PPA'+Irrigator10ClientCertAsBytes+TransactionID10


            date=new Date()
            // argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+Irrigator1ClientID+TransactionID,
                Customer: Irrigator1ClientCertAsBytes,
                CustomerID: Irrigator1ClientID,
            }

        });
        it('Should return false if PPA has not been created', async () =>{
            let ret=await contract._isPPAProposed(ctx,Irrigator1ClientID);
            expect(ret).to.eql(false)
        });
        it ('Should return true if exists at least one PPA', async () => {
            mockStub.putState(PPA.ppaID,Buffer.from(JSON.stringify(PPA)));
            let ret=await contract._isPPAProposed(ctx,Irrigator1ClientID);
            expect(ret).to.eql(true)
        });
    });
    describe('TESTING: _getPoolStateByPartialCompositeKey', () => {

        let date;
        let poolName;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let OriginatorClientID
        beforeEach(() => {
            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K"
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10


            date=new Date()
            let argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('POOL').digest('hex');
            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientCertAsBytes,
                OwnerID: OriginatorClientID,
                LastModificationOn: argDate
            };
        })
        it('Should throw an error if partial key does not provide a unique state',async () =>{
            NewTransactionID=crypto.createHash('sha256', secret).update('NewPOOL').digest('hex');
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            Pool.poolID='POOL'+NewTransactionID;
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            try{
                let ret=await contract._getPoolStateByPartialCompositeKey(ctx,'POOL');
                assert.fail('_getPoolStateByPartialCompositeKey should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`This state-value pair is not unique`)
            }
        })
        it('Should return false if state does not exist',async () =>{
            let ret=await contract._getPoolStateByPartialCompositeKey(ctx,'POOL');
            expect(ret).to.eql(false)
        })
        it('Should return state',async () =>{
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            let ret=await contract._getPoolStateByPartialCompositeKey(ctx,'POOL');
            expect(ret).to.eql(Pool)
        })

    });
    describe('TESTING: _mygetStateByPartialCompositeKey works as expected', () => {

        let date;
        let poolName;
        let PPA1,PPA2,PPA3;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let OriginatorClientID
        beforeEach(() => {
            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K"
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10


            date=new Date()
            let argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('POOL').digest('hex');

            PPA1={
                docType: 'PPA',
                ppaID: 'PPA'+Irrigator1ClientID+TransactionID1,
                Customer: Irrigator1ClientCertAsBytes,
                CustomerID: Irrigator1ClientID,
            }
            PPA2={
                docType: 'PPA',
                ppaID: 'PPA'+Irrigator2ClientID+TransactionID2,
                Customer: Irrigator2ClientCertAsBytes,
                CustomerID: Irrigator2ClientID,
            }
            PPA3={
                docType: 'PPA',
                ppaID: 'PPA'+Irrigator3ClientID+TransactionID3,
                Customer: Irrigator3ClientCertAsBytes,
                CustomerID: Irrigator3ClientID,
            }
        })
        it('should throw an error if state is not unique', async () =>{
            mockStub.putState(PPA1.ppaID,Buffer.from(JSON.stringify(PPA1)));
            PPA2.ppaID='PPA'+Irrigator1ClientID+TransactionID2
            mockStub.putState(PPA2.ppaID,Buffer.from(JSON.stringify(PPA2)));
            try{
                await contract._mygetStateByPartialCompositeKey(ctx,PPA1.docType,PPA1.CustomerID);
                assert.fail('_mygetStateByPartialCompositeKey should throw an Error')
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal('This state-value pair is not unique')
            }

        })
        it('should return true if state does not exist', async () =>{
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,PPA1.Doctype,PPA1.CustomerID);
            expect(ret).to.eql(true)
        })
        it('should return state', async () =>{
            mockStub.putState(PPA1.ppaID,Buffer.from(JSON.stringify(PPA1)))
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,PPA1.ppaID,PPA1.CustomerID);
            expect(ret).to.eql(PPA1)
        })
    });
    describe('TESTING: _isPPAinPool works as expected', () =>{
        let date;
        let poolName;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let OriginatorClientID;
        let PPA
        beforeEach(() => {
            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K"
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10


            date=new Date()
            let argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('POOL').digest('hex');
            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientCertAsBytes,
                OwnerID: OriginatorClientID,
                LastModificationOn: argDate
            };
            PPA={
                Doctype:'PPA',
                ppaID: ppaID1,
                Customer: Irrigator1ClientCertAsBytes,
                CustomerID: Irrigator1ClientID
            }
        });
        // Prior identity verifications not necessary because it is an auxiliary function. It cannot be invoked from
        // API
        it('PPA is included inside POOL', async ()=>{
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)))
            let ret=await contract._isPPAinPool(ctx,ppaID1);
            expect(ret[0]).to.eql(true);
            expect(ret[1]).to.eql(Pool.OwnerID)
        });
        it('PPA is not included inside POOL', async ()=>{
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)))
            let ret=await contract._isPPAinPool(ctx,ppaID1+"asdwq");
            expect(ret[0]).to.eql(false);
        });
        it('Pool not created', async ()=>{
            let ret=await contract._isPPAinPool(ctx,ppaID3);
            expect(ret[0]).to.eql(false);
        });
    });
    describe('TESTING: _getCouponPortion works as expected', () =>{
        let date;
        let poolName;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let OriginatorClientID;
        let PPA
        beforeEach(() => {
            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K"
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10


            date=new Date()
            let argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('POOL').digest('hex');
            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientCertAsBytes,
                OwnerID: OriginatorClientID,
                LastModificationOn: argDate,
                Coupon:1,
            };
        });
        // Prior identity verifications not necessary because it is an auxiliary function. It cannot be invoked from
        // API
        it('Returns couponPortion', async ()=>{
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)))
            let ret=await contract._getCouponProportion(ctx,'POOL');
            expect(ret).to.eql(Pool.CouponPortion);
        });
    })
    describe('TESTING: _TransferMoney works as expected',()=>{
        let typeID;
        let securitizationCoin_Input,securitizationCoin_Output1,securitizationCoin_Output2;
        let key, amount;

        let quantityToTransfer;
        let balance;

        let Irrigator1ClientID,OriginatorClientID,Irrigator1ClientCertAsBytes,Irrigator2ClientCert,Irrigator1ClientCert;
        let TransactionID1,TransactionID2;
        let secret="MySecret";

        let IssuerClientCert, IssuerClientCertAsBytes;
        beforeEach(() => {
            Irrigator1ClientID="12345678A";
            OriginatorClientID="12345678K"
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            OriginatorClientCert="OriginatorClientCert";
            IssuerClientCert="IssuerClientCert";

            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');
            IssuerClientCertAsBytes=Buffer.from(IssuerClientCert).toString('base64');

            typeID=":0"
            key="securitizationCoin"+ Irrigator1ClientID+TransactionID1;

            mockClientIdentity.getIDBytes.returns(Irrigator1ClientCertAsBytes);
            amount="1000.01"
            quantityToTransfer="500.02"
            securitizationCoin_Input= {
                ID: key+ typeID,
                GenericID: TransactionID1,
                TypeID: typeID,
                Issuer: IssuerClientCertAsBytes,
                Owner: Irrigator1ClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            key="securitizationCoin"+OriginatorClientID+TransactionID2
            securitizationCoin_Output1= {
                ID: key+ typeID,
                GenericID: TransactionID2,
                TypeID: typeID,
                Issuer: Irrigator1ClientCertAsBytes,
                Owner: OriginatorClientID,
                Amount: parseInt(parseFloat(quantityToTransfer)*100),
                Factor: 100,
                CanBeUsed: true
            };
            typeID=':1'
            balance=parseFloat(amount)-parseFloat(quantityToTransfer);
            key="securitizationCoin"+Irrigator1ClientID+TransactionID2;
            securitizationCoin_Output2= {
                ID: key+ typeID,
                GenericID: TransactionID2,
                TypeID: typeID,
                Issuer: Irrigator1ClientCertAsBytes,
                Owner: Irrigator1ClientID,
                Amount: parseInt(balance*100),
                Factor: 100,
                CanBeUsed: true
            };

            mockClientIdentity.getIDBytes.returns(Irrigator1ClientCertAsBytes);
            mockStub.createCompositeKey.withArgs('securitizationCoin',[Irrigator1ClientID,TransactionID2]).returns('securitizationCoin'+Irrigator1ClientID+TransactionID2);
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OriginatorClientID,TransactionID2]).returns('securitizationCoin'+OriginatorClientID+TransactionID2)
            mockStub.getTxID.returns(TransactionID2)

            mockClientIdentity.getAttributeValue.withArgs('cif').returns('12345678L');
        });
        // Prior identity verifications not necessary because it is an auxiliary function. It cannot be invoked from
        // API
        it('Should throw an error if Token does not exist', async ()=>{
            try {
                await contract._TransferMoney(ctx,securitizationCoin_Input.ID, parseInt(parseFloat(quantityToTransfer)*100), OriginatorClientID,Irrigator1ClientID);
                assert.fail('_Transfer should throw an Error');
            } catch(err) {
                //
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error: no token associated with ID ${securitizationCoin_Input.ID}`);
            }
        });
        it('Should return success. Case 1: balance>0', async ()=>{
            let token1;
            mockStub.getState.withArgs(securitizationCoin_Input.ID).returns(Buffer.from(JSON.stringify(securitizationCoin_Input)))
            token1=await contract._TransferMoney(ctx,securitizationCoin_Input.ID, parseInt(parseFloat(quantityToTransfer)*100),OriginatorClientID,Irrigator1ClientID)
            expect(token1[1]).to.eql(securitizationCoin_Output1);
            expect(token1[0]).to.eql(securitizationCoin_Output2);
        });
        it('Should return success. Case 2: balance=0', async ()=>{
            let token1;
            securitizationCoin_Output1.Amount=parseInt(parseFloat(amount)*100);
            mockStub.getState.withArgs(securitizationCoin_Input.ID).returns(Buffer.from(JSON.stringify(securitizationCoin_Input)))
            token1=await contract._TransferMoney(ctx,securitizationCoin_Input.ID, parseInt(parseFloat(amount)*100), OriginatorClientID,Irrigator1ClientID)
            expect(token1[0]).to.eql(securitizationCoin_Output1);
        });


    })
    describe('TESTING: _TransferMoneyToCouponAndPrincipal works as expected',()=>{
        let typeID;
        let securitizationCoin_Input,securitizationCoin_Output1,securitizationCoin_Output2,securitizationCoin_Output3;
        let key, amount;

        let quantityToTransfer;
        let balance;

        let Irrigator1ClientID,SPVClientID,Irrigator1ClientCertAsBytes,Irrigator1ClientCert,SPVClientCertAsBytes,SPVClientCert;
        let TransactionID1,TransactionID2;
        let secret="MySecret";

        let IssuerClientCert, IssuerClientCertAsBytes;
        let couponPortion;

        beforeEach(() => {
            Irrigator1ClientID="12345678A";
            SPVClientID="12345678M"
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            SPVClientCert="SPVClientCert";
            IssuerClientCert="IssuerClientCert";

            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');
            IssuerClientCertAsBytes=Buffer.from(IssuerClientCert).toString('base64');

            typeID=":0"
            key="securitizationCoin"+ Irrigator1ClientID+TransactionID1;


            couponPortion=0.1;


            mockClientIdentity.getIDBytes.returns(Irrigator1ClientCertAsBytes);
            amount="1000.01"
            quantityToTransfer="500.02"
            securitizationCoin_Input= {
                ID: key+ typeID,
                GenericID: TransactionID1,
                TypeID: typeID,
                Issuer: IssuerClientCertAsBytes,
                Owner: Irrigator1ClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            key="securitizationCoin"+SPVClientID+TransactionID2
            securitizationCoin_Output1= {
                ID: key+ typeID,
                GenericID: TransactionID2,
                TypeID: typeID,
                Issuer: Irrigator1ClientCertAsBytes,
                Owner: SPVClientID,
                Amount: parseInt(parseFloat(quantityToTransfer)*100*couponPortion),
                Factor: 100,
                CanBeUsed: true
            };
            typeID=':2'
            securitizationCoin_Output3= {
                ID: key+typeID,
                GenericID: TransactionID2,
                TypeID: typeID,
                Issuer: Irrigator1ClientCertAsBytes,
                Owner: SPVClientID,
                Amount: parseInt(parseInt(parseFloat(quantityToTransfer)*100)- parseInt(parseFloat(quantityToTransfer)*100*couponPortion)),
                Factor: 100,
                CanBeUsed: false
            };

            typeID=':1'
            balance=parseInt(parseFloat(amount)*100-parseFloat(quantityToTransfer)*100);
            key="securitizationCoin"+Irrigator1ClientID+TransactionID2;
            securitizationCoin_Output2= {
                ID: key+ typeID,
                GenericID: TransactionID2,
                TypeID: typeID,
                Issuer: Irrigator1ClientCertAsBytes,
                Owner: Irrigator1ClientID,
                Amount: balance,
                Factor: 100,
                CanBeUsed: true
            };


            mockClientIdentity.getIDBytes.returns(Irrigator1ClientCertAsBytes);
            mockStub.createCompositeKey.withArgs('securitizationCoin',[Irrigator1ClientID,TransactionID2]).returns('securitizationCoin'+Irrigator1ClientID+TransactionID2);
            mockStub.createCompositeKey.withArgs('securitizationCoin',[SPVClientID,TransactionID2]).returns('securitizationCoin'+SPVClientID+TransactionID2)
            mockStub.getTxID.returns(TransactionID2)
        });
        // Prior identity verifications not necessary because it is an auxiliary function. It cannot be invoked from
        // API
        it('Should throw an error if Token does not exist', async ()=>{
            try {
                await contract._TransferMoneyToCouponAndPrincipal(ctx,securitizationCoin_Input.ID, parseInt(parseFloat(quantityToTransfer)*100),couponPortion, SPVClientID,Irrigator1ClientID);
                assert.fail('_Transfer should throw an Error');
            } catch(err) {
                //
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error: no token associated with ID ${securitizationCoin_Input.ID}`);
            }
        });
        it('Should return success. Case 1: balance>0', async ()=>{
            let token1;

            mockStub.putState(securitizationCoin_Input.ID,Buffer.from(JSON.stringify(securitizationCoin_Input)));
            mockStub.getState.withArgs(securitizationCoin_Input.ID).returns(Buffer.from(JSON.stringify(securitizationCoin_Input)))

            token1=await contract._TransferMoneyToCouponAndPrincipal(ctx,securitizationCoin_Input.ID, parseInt(parseFloat(quantityToTransfer)*100),couponPortion,SPVClientID,Irrigator1ClientID);

            expect(token1[1]).to.eql(securitizationCoin_Output1);
            expect(token1[0]).to.eql(securitizationCoin_Output2);
            expect(token1[2]).to.eql(securitizationCoin_Output3)
        });
        it('Should return success. Case 2: balance=0', async ()=>{
            let token1;
            securitizationCoin_Input.Amount=parseInt(parseFloat(quantityToTransfer)*100);

            mockStub.putState(securitizationCoin_Input.ID,Buffer.from(JSON.stringify(securitizationCoin_Input)));
            securitizationCoin_Output1.Amount=parseInt(couponPortion*parseInt(parseFloat(quantityToTransfer)*100));
            securitizationCoin_Output3.Amount=parseInt(parseInt(parseFloat(quantityToTransfer)*100))-parseInt(couponPortion*parseInt(parseFloat(quantityToTransfer)*100));
            mockStub.getState.withArgs(securitizationCoin_Input.ID).returns(Buffer.from(JSON.stringify(securitizationCoin_Input)))
            token1=await contract._TransferMoneyToCouponAndPrincipal(ctx,securitizationCoin_Input.ID, parseInt(parseFloat(quantityToTransfer)*100),couponPortion, SPVClientID,Irrigator1ClientID)
            expect(token1[1]).to.eql(securitizationCoin_Output3);
            expect(token1[0]).to.eql(securitizationCoin_Output1);
        });
    })
    describe('TESTING: _CheckNonWorkingDays works as expected',()=>{
        beforeEach(() => {

        });
        // Prior identity verifications not necessary because it is an auxiliary function. It cannot be invoked from
        // API
        it('Should return 1,e.g, May 1st is non working day', async ()=>{
            let currentDate=new Date(2022,4,3);
            let notificationDate=new Date(2022,3,29);
            let ret=await contract._checkNonWorkingDays(currentDate, notificationDate);
            expect(ret).to.eql(1);
        });
        it('Should return 2,e.g, December 25th and January 1st are non working days', async ()=>{
            let currentDate=new Date(2022,0,3);
            let notificationDate=new Date(2021,11,24);
            let ret=await contract._checkNonWorkingDays(currentDate, notificationDate);
            expect(ret).to.eql(2);
        });

    })
    describe('TESTING: createContext works as expected', () =>{
        it('Should return new Context', async ()=>{
            let newContext=new SecuritizationContract.securitizationContext()
            let ret =await contract.createContext();
            expect(ret).to.eql(newContext);
        });
    });
    // describe('TESTING: afterTransaction works as expected', () =>{
    //     let PPA_compare
    //     beforeEach(() => {

    //         PPA_compare={
    //             docType: 'PPA',
    //             ppaID: 'PPA12345678L12132421421424123sdqwdwqdad',
    //             Customer: '',
    //             CustomerID: '12345678L'
    //         }
    //     })
    //     it('should return success', async () =>{
    //         mockStub.putState(PPA_compare.ID,Buffer.from(JSON.stringify(PPA_compare)))
    //         // PPA=await contract.PPAProposal(ctx,OwnerID,CustomerID,argDate)
    //         let eventObject={
    //             eventName:'PPAproposed',
    //             eventPayload: Buffer.from(JSON.stringify(PPA_compare))
    //         }
    //         mockStub.setEvent.withArgs('PPAproposed',Buffer.from(JSON.stringify(PPA_compare))).returns(eventObject)
    //         let ret=await contract.afterTransaction(ctx)
    //         //console.log(ret)
    //         expect(ret.eventName).to.eql(eventObject.eventName);
    //         expect(ret.eventPayload).to.eql(eventObject.eventPayload);
    //     });


    // });
    describe('TESTING: Irrigator client requests a PPA',() =>
    {
        let PPARequest,ID,LandID,Crops;
        let IrrigatorClientCertAsBytes,IrrigatorClientID,IrrigatorClientCert;


        beforeEach(() => {

            Doctype="PPARequest";
            LandID="LandIDString"
            Crops="cereals"

            IrrigatorClientID= "12345678P";
            OriginatorClientID="12345678L";
            IrrigatorClientCert="IrrigatorClientCert";
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');
            OriginatorClientCert="OriginatorClientCert";
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            //variable to mock getTxID()
            Test="test";
            secret="secret";
            TransactionID=crypto.createHash('sha256', secret).update(Test).digest('hex');
            ID=Doctype+IrrigatorClientID+TransactionID;

            // variable to mock getDateTimestamp()
            date=new Date()
            argDate=date.toUTCString();


            PPARequest={
                ID: ID,
                UserID: IrrigatorClientID,
                User: IrrigatorClientCertAsBytes,
                LandID: LandID,
                Crops: Crops,
            }
            mockStub.getTxID.returns(TransactionID);
            mockClientIdentity.getIDBytes.returns(IrrigatorClientCertAsBytes);
            mockStub.createCompositeKey.withArgs(Doctype,[IrrigatorClientID,TransactionID]).returns(Doctype+IrrigatorClientID+TransactionID);
            mockClientIdentity.getMSPID.returns('farmerMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(IrrigatorClientID);

            FunctionAndParameters={
                fcn: "RequestPPA",
                params: [LandID,Crops]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        })
        it('Should throw an error if user is neither an Irrigator nor an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('RequestPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('RequestPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty string', async () =>{
            FunctionAndParameters={
                fcn: "RequestPPA",
                params: [LandID,""]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('RequestPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`)
            }
        });
        it('Should throw an error if user is not an Irrigator member', async () =>{
            mockClientIdentity.getMSPID.returns('originatorMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('RequestPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if PPARequest ID is already being used', async () =>{
            mockStub.putState(PPARequest.ID,Buffer.from(JSON.stringify(PPARequest)));
            mockStub.getState.withArgs(PPARequest.ID).returns(Buffer.from(JSON.stringify(PPARequest)))
            await contract.beforeTransaction(ctx);
            try {
                await contract.RequestPPA(ctx,PPARequest.LandID,PPARequest.Crops)
                assert.fail('RequestPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`State with ID ${PPARequest.ID} already exists`)
            }
        });
        it('Should return PPARequest state', async () =>{
            await contract.beforeTransaction(ctx);
            ret=await contract.RequestPPA(ctx,PPARequest.LandID,PPARequest.Crops);
            expect(ret).to.eql(PPARequest);
        });
    });
    describe('TESTING: Originator client queries PPARequests',() =>
    {
        let PPARequest1,PPARequest2,PPARequest3,PPARequest4,ID,LandID,Crops;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes;

        beforeEach(() => {
            secret="secret"
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64')
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64')
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64')
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64')


            Doctype="PPARequest";
            LandID="LandIDString"
            Crops="cereals"

            PPARequest1={
                ID: Doctype+Irrigator1ClientCertAsBytes+TransactionID1,
                UserID: Irrigator1ClientCertAsBytes,
                LandID: LandID,
                Crops: Crops,
            }

            PPARequest2={
                ID: Doctype+Irrigator2ClientCertAsBytes+TransactionID2,
                UserID: Irrigator2ClientCertAsBytes,
                LandID: LandID,
                Crops: Crops,
            }

            PPARequest3={
                ID: Doctype+Irrigator3ClientCertAsBytes+TransactionID3,
                UserID: Irrigator3ClientCertAsBytes,
                LandID: LandID,
                Crops: Crops,
            }

            PPARequest4={
                ID: Doctype+Irrigator4ClientCertAsBytes+TransactionID4,
                UserID: Irrigator4ClientCertAsBytes,
                LandID: LandID,
                Crops: Crops,
            }

            mockStub.getTxID.returns(TransactionID);
            mockClientIdentity.getIDBytes.returns(OriginatorClientCertAsBytes);
            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OriginatorClientID);

            FunctionAndParameters={
                fcn: "QueryPPARequest",
                params: []
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        })
        it('Should throw an error if user is neither an Irrigator nor an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryPPARequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryPPARequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('farmerMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryPPARequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should return PPARequest1, ...,PPARequestn', async () =>{
            mockStub.putState(PPARequest1.ID,Buffer.from(JSON.stringify(PPARequest1)));
            mockStub.putState(PPARequest2.ID,Buffer.from(JSON.stringify(PPARequest2)));
            mockStub.putState(PPARequest3.ID,Buffer.from(JSON.stringify(PPARequest3)));
            mockStub.putState(PPARequest4.ID,Buffer.from(JSON.stringify(PPARequest4)));
            let PPARequestArray=[PPARequest1,PPARequest2,PPARequest3,PPARequest4]
            await contract.beforeTransaction(ctx);
            ret=await contract.QueryPPARequest(ctx)
            expect(ret).to.eql(PPARequestArray);
        });
        it('Should return [] if no PPARequest has been requested', async () =>{
            // mockStub.putState(PPARequest1.ID,Buffer.from(JSON.stringify(PPARequest1)));
            // mockStub.putState(PPARequest2.ID,Buffer.from(JSON.stringify(PPARequest2)));
            // mockStub.putState(PPARequest3.ID,Buffer.from(JSON.stringify(PPARequest3)));
            // mockStub.putState(PPARequest4.ID,Buffer.from(JSON.stringify(PPARequest4)));
            let PPARequestArray=[]
            await contract.beforeTransaction(ctx);
            ret=await contract.QueryPPARequest(ctx)
            expect(ret).to.eql(PPARequestArray);
        });
    });
    describe('TEST: Originator client proposes a Power Purchase Agreement to an Irrigator client', () =>
    {
        let date;
        let PPA;
        let ppaID
        let IrrigatorClientCert;
        let IrrigatorClientCertAsBytes;
        let OriginatorClientID,IrrigatorClientID;
        let TransactionID;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let secret="MySecret";
        let PPARequestClientID, PPARequestGenericID;
        let LandID,Doctype,Crops,ID;
        let PPARequest;
        beforeEach(() => {

            IrrigatorClientCert="IrrigatorClientCert";
            OriginatorClientCert="OriginatorClientCert";
            IrrigatorClientID="12345678A";
            OriginatorClientID="12345678B";


            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            // First of all we must mock PPARequest state
            Doctype="PPARequest";
            LandID="LandIDString"
            Crops="cereals"

            //variable to mock getTxID()
            Test="test";
            secret="secret";
            TransactionID=crypto.createHash('sha256', secret).update(Test).digest('hex');
            ID=Doctype+IrrigatorClientID+TransactionID;

            // variable to mock getDateTimestamp()
            date=new Date()
            argDate=date.toUTCString();

            PPARequestClientID=IrrigatorClientID;
            PPARequestGenericID=TransactionID;
            PPARequest={
                ID: ID,
                UserID: IrrigatorClientID,
                User: IrrigatorClientCertAsBytes,
                LandID: LandID,
                Crops: Crops,
            }

            // PPA state
            TransactionID=crypto.createHash('sha256', secret).update('1').digest('hex');
            ppaID='PPA'+IrrigatorClientID+TransactionID;

            date=new Date()
            // argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
            }



            mockStub.getTxID.returns(TransactionID);
            mockStub.createCompositeKey.withArgs(Doctype,[IrrigatorClientCertAsBytes,TransactionID]).returns(Doctype+IrrigatorClientCertAsBytes+TransactionID);


            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OriginatorClientID);


            FunctionAndParameters={
                fcn: "PPAProposal",
                params: [PPARequestClientID, PPARequestGenericID]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        })
        it('should throw an error if user is neither an Originator nor an Irrigator member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP');
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('PPA Proposal should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role', 'client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('PPA Proposal should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('should throw an error if any arg is an empty string', async () =>{
            mockClientIdentity.getMSPID.returns('originatorMSP');
            FunctionAndParameters={
                fcn: "PPAProposal",
                params: [PPARequestClientID, '']
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('PPA Proposal should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`)
            }
        });
        it('should throw an error if user is not an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('farmerMSP');
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('PPA Proposal should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('should throw an error if PPARequest does not exist', async () =>{
            mockStub.createCompositeKey.withArgs('PPARequest',[PPARequestClientID,PPARequestGenericID]).returns('PPARequest'+PPARequestClientID+PPARequestGenericID)
            let PPARequestKey='PPARequest'+PPARequestClientID+PPARequestGenericID;
            await contract.beforeTransaction(ctx);
            try {
                await contract.PPAProposal(ctx,PPARequestClientID, PPARequestGenericID);
                assert.fail('PPA Proposal should throw an Error');
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`PPARequest with ID ${PPARequestKey} does not exist`)
            }
        });
        it('should throw an error if owner ID and Customer ID are equal', async () =>{
            OriginatorClientID=IrrigatorClientID
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OriginatorClientID)
            mockStub.createCompositeKey.withArgs('PPARequest',[PPARequestClientID,PPARequestGenericID]).returns('PPARequest'+PPARequestClientID+PPARequestGenericID)
            let PPARequestKey='PPARequest'+PPARequestClientID+PPARequestGenericID;
            mockStub.putState(PPARequestKey,Buffer.from(JSON.stringify(PPARequest)));
            mockStub.getState.withArgs(PPARequestKey).returns(Buffer.from(JSON.stringify(PPARequest)));
            mockStub.getDateTimestamp.returns(argDate);
            await contract.beforeTransaction(ctx);
            try {
                await contract.PPAProposal(ctx,PPARequestClientID, PPARequestGenericID);
                assert.fail('PPA Proposal should throw an Error');
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Check owner and customer identities`)
            }
        });
        it('should throw an error if PPA for Customer ID has already been proposed', async () =>{
            mockStub.createCompositeKey.withArgs('PPARequest',[PPARequestClientID,PPARequestGenericID]).returns('PPARequest'+PPARequestClientID+PPARequestGenericID)
            let PPARequestKey='PPARequest'+PPARequestClientID+PPARequestGenericID;
            mockStub.putState(PPARequestKey,Buffer.from(JSON.stringify(PPARequest)));
            mockStub.getState.withArgs(PPARequestKey).returns(Buffer.from(JSON.stringify(PPARequest)))
            mockStub.getState.withArgs(PPA.ppaID).resolves(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract,'_isPPAProposed').returns(true)
            await contract.beforeTransaction(ctx);
            try {
                PPA=await contract.PPAProposal(ctx,PPARequestClientID,PPARequestGenericID);
                assert.fail('PPA Proposal should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error: PPA for user ${IrrigatorClientID} has already been offered`)
            }
        });
        it('should return success', async () =>{
            mockStub.createCompositeKey.withArgs('PPARequest',[PPARequestClientID,PPARequestGenericID]).returns('PPARequest'+PPARequestClientID+PPARequestGenericID)
            let PPARequestKey='PPARequest'+PPARequestClientID+PPARequestGenericID;
            mockStub.putState(PPARequestKey,Buffer.from(JSON.stringify(PPARequest)));
            mockStub.getState.withArgs(PPARequestKey).returns(Buffer.from(JSON.stringify(PPARequest)))
            sinon.stub(contract,'_isPPAProposed').returns(false)
            await contract.beforeTransaction(ctx);
            PPA=await contract.PPAProposal(ctx,PPARequestClientID,PPARequestGenericID)
            expect(PPA).to.eql(PPA);
        });
    })
    describe('TESTING: Farmer member queries his/her PPA',() =>
    {
        let ID;
        let IrrigatorClientCertAsBytes,IrrigatorClientID,IrrigatorClientCert;
        let PPA

        beforeEach(() => {

            IrrigatorClientID= "12345678P";
            IrrigatorClientCert="IrrigatorClientCert";
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');

            //variable to mock getTxID()
            Test="test";
            secret="secret";
            TransactionID=crypto.createHash('sha256', secret).update(Test).digest('hex');
            ID=Doctype+IrrigatorClientID+TransactionID;

            // variable to mock getDateTimestamp()
            date=new Date()
            argDate=date.toUTCString();

            // PPA state
            TransactionID=crypto.createHash('sha256', secret).update('1').digest('hex');

            date=new Date()
            // argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
            }




            mockClientIdentity.getMSPID.returns('farmerMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(IrrigatorClientID);


            FunctionAndParameters={
                fcn: "QueryMyPPA",
                params: []
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        })
        it('Should throw an error if user is neither a Farmer nor an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryMyPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryMyPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a Farmer member', async () =>{
            mockClientIdentity.getMSPID.returns('originatorMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryMyPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Returns PPA state', async () =>{
            await contract.beforeTransaction(ctx);
            mockStub.getState.withArgs(PPA.ppaID).resolves(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract,'_mygetStateByPartialCompositeKey').returns(PPA)
            let ret=await contract.QueryMyPPA(ctx);
            expect(ret).to.eql(PPA);
        });
    })
    describe('TESTING: Farmer member signs his/her PPA',() =>{

        let ID;
        let IrrigatorClientCertAsBytes,IrrigatorClientID,IrrigatorClientCert;
        let PPA
        let argDate,TransactionID

        beforeEach(() => {

            IrrigatorClientID= "12345678P";
            IrrigatorClientCert="IrrigatorClientCert";
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');

            //variable to mock getTxID()
            Test="test";
            secret="secret";
            TransactionID=crypto.createHash('sha256', secret).update(Test).digest('hex');
            ID=Doctype+IrrigatorClientID+TransactionID;

            // variable to mock getDateTimestamp()
            date=new Date()
            argDate=date.toUTCString();

            // PPA state
            TransactionID=crypto.createHash('sha256', secret).update('1').digest('hex');

            date=new Date()
            argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
                IsSigned: false
            }


            mockClientIdentity.getMSPID.returns('farmerMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(IrrigatorClientID);
            mockStub.getDateTimestamp.returns(argDate)


            FunctionAndParameters={
                fcn: "AcceptPPA",
                params: [PPA.ppaID]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        })
        it('Should throw an error if user is neither a Farmer nor an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('AcceptPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('AcceptPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it('Should throw an error if any arg is an empty string', async () =>{
            FunctionAndParameters.params=[''];
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('AcceptPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it('Should throw an error if user is not a Farmer member', async () =>{
            mockClientIdentity.getMSPID.returns('originatorMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('AcceptPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if PPA does not exist', async () =>{
            mockStub.createCompositeKey.withArgs('PPA',[IrrigatorClientID,TransactionID]).returns('PPA'+IrrigatorClientID+TransactionID)
            await contract.beforeTransaction(ctx);
            try {
                await contract.AcceptPPA(ctx,TransactionID);
                assert.fail('AcceptPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error PPA with ID ${PPA.ppaID} does not exist`)
            }
        });
        it('Should throw an error if Customer ID of PPA and user ID from his/her eCert do not match', async () =>{
            let WrongIrrigatorClientID="12345678D";
            mockStub.createCompositeKey.withArgs('PPA',[WrongIrrigatorClientID,TransactionID]).returns('PPA'+WrongIrrigatorClientID+TransactionID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(WrongIrrigatorClientID);
            mockStub.getState.withArgs('PPA'+WrongIrrigatorClientID+TransactionID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.AcceptPPA(ctx,TransactionID);
                assert.fail('AcceptPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user has already signed his/her PPA', async () =>{
            PPA.IsSigned=true;
            mockStub.createCompositeKey.withArgs('PPA',[IrrigatorClientID,TransactionID]).returns('PPA'+IrrigatorClientID+TransactionID)
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.AcceptPPA(ctx,TransactionID);
                assert.fail('AcceptPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your PPA has been already signed`)
            }
        });
        it('Should return PPA has been signed', async () =>{
            mockStub.createCompositeKey.withArgs('PPA',[IrrigatorClientID,TransactionID]).returns('PPA'+IrrigatorClientID+TransactionID)
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            const new_date=new Date(date);
            argDate=new_date.toUTCString();
            PPA={
                docType: PPA.docType,
                ppaID: PPA.ppaID,
                Customer: PPA.Customer,
                CustomerID: PPA.CustomerID,
                IsSigned: true,
                LastModificationOn: new Date(argDate)
            }
            await contract.beforeTransaction(ctx);
            let ret=await contract.AcceptPPA(ctx,TransactionID);
            expect(ret).to.eql(PPA)
       });
    })
    describe('TESTING: Originator member mints Pool of PPAs, and the owner of this PPA will receive farmer payments ',() =>{
        let ID;
        let IrrigatorClientCertAsBytes,IrrigatorClientID,IrrigatorClientCert;
        let PPA
        let argDate;
        let OriginatorClientCertAsBytes,OriginatorClientID,OriginatorClientCert;
        let POOL
        let TransactionID1


        beforeEach(() => {

            IrrigatorClientID= "12345678P";
            IrrigatorClientCert="IrrigatorClientCert";
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');

            OriginatorClientID= "12345678A";
            OriginatorClientCert="OriginatorClientCert";
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            //variable to mock getTxID()
            Test="test";
            secret="secret";

            // PPA state
            // TransactionID=crypto.createHash('sha256', secret).update('1').digest('hex');

            // date=new Date()
            // argDate=date.toUTCString();

            TransactionID1=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID1,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
                IsSigned: false,
                IsIssued: false,
                OwnerID:OriginatorClientID
            }


            mockClientIdentity.getMSPID.returns('farmerMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(IrrigatorClientID);
            mockStub.getDateTimestamp.returns(argDate)
            // PPA with ID must exist before each and must been signed

            // Pool state
            TransactionID=crypto.createHash('sha256', secret).update('POOL').digest('hex');

            Doctype="POOL"

            mockStub.getTxID.returns(TransactionID)
            mockStub.createCompositeKey.withArgs(Doctype,[TransactionID]).returns(Doctype+TransactionID)
            mockStub.getDateTimestamp.returns(argDate);

            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OriginatorClientID);


            FunctionAndParameters={
                fcn: "MintPPA",
                params: [PPA.ppaID]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);

            POOL={
                poolID: Doctype+TransactionID,
                ppaIDs: [],
                Name: Doctype,
                OwnerID: OriginatorClientID,
                LastModificationOn: new Date(argDate),
                CouponPortion:1
            }
            mockStub.createCompositeKey.withArgs('PPA',[PPA.CustomerID,TransactionID1]).returns('PPA'+PPA.CustomerID+TransactionID1)
        });

        it('Should throw an error if user is neither an Originator nor a Farmer member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('farmerMSP');
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if arg is an empty string', async () =>{
            FunctionAndParameters={
                fcn: "MintPPA",
                params: ['']
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
                //
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`)
            }
        });
        it('Should throw an error if PPA does not exist', async () =>{
            await contract.beforeTransaction(ctx);
            try {
                await contract.MintPPA(ctx,PPA.CustomerID,TransactionID1,'POOL');
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error: no State related to key ${PPA.ppaID}`)
            }
        });
        it('Should throw an error if Owner ID of PPA and user ID from his/her eCert do not match (only Owner can Mint)', async () =>{
            let wrong_OwnerID="12345678X";
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(wrong_OwnerID)
            await contract.beforeTransaction(ctx);
            try {
                await contract.MintPPA(ctx,PPA.CustomerID,TransactionID1,'POOL')
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Field ownerID does not match your user identity of the ecert`)
            }
        });
        it('Should throw an error if user has NOT signed his/her PPA', async () =>{
            PPA.IsSigned=false
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MintPPA(ctx,PPA.CustomerID,TransactionID1,'POOL');
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This PPA has not been signed`)
            }
        });
        it('Should throw an error if Owner has already minted this PPA', async () =>{
            PPA.IsSigned=true
            PPA.IsIssued=true;
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MintPPA(ctx,PPA.CustomerID,TransactionID1,'POOL');
                assert.fail('MintPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This PPA is already inside the POOL`)
            }
        });
        it('Case 1: pool not created. _isPoolCreated already tested', async () =>{
            PPA.IsSigned=true
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_isPoolCreated').returns(false)
            await contract.beforeTransaction(ctx);
            let ret=await contract.MintPPA(ctx,PPA.CustomerID,TransactionID1,'POOL');
            POOL.ppaIDs.push(PPA.ppaID);
            expect(ret).to.eql(POOL);

        });
        it('Case 2: pool already created, and contains one PPAID', async () =>{
            mockStub.putState(POOL.poolID,Buffer.from(JSON.stringify(POOL)))
            TransactionID=crypto.createHash('sha256', secret).update('OldPPA').digest('hex');
            PPA.IsSigned=true
            PPA.IsIssued=true
            let Irrigator1ClientID="12345678H"
            let Irrigator1ClientCert="Irrigator1ClientCert"
            let Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            let newPPA_TransactionID=crypto.createHash('sha256', secret).update('OldPPA').digest('hex');
            let newPPA={
                docType: 'PPA',
                ppaID: 'PPA'+Irrigator1ClientID+newPPA_TransactionID,
                Customer: Irrigator1ClientCertAsBytes,
                CustomerID: Irrigator1ClientID,
                OwnerID: OriginatorClientID,
                IsSigned: true,
                IsIssued: false
            };
            TransactionID=crypto.createHash('sha256', secret).update('OldPool').digest('hex');
            POOL.OwnerID=OriginatorClientID;
            POOL.ppaIDs.push(newPPA.ppaID);
            POOL.poolID=Doctype+TransactionID;
            POOL.LastModificationOn=new Date(argDate);

            PPA.IsIssued=true;

            mockStub.putState(PPA.ppaID,Buffer.from(JSON.stringify(PPA)))
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            mockStub.getState.withArgs(newPPA.ppaID).returns(Buffer.from(JSON.stringify(newPPA)));
            mockStub.createCompositeKey.withArgs('PPA',[newPPA.CustomerID,newPPA_TransactionID]).returns('PPA'+newPPA.CustomerID+newPPA_TransactionID);
            sinon.stub(contract, '_isPoolCreated').returns(true);
            sinon.stub(contract, '_getPoolStateByPartialCompositeKey').returns(POOL);
            await contract.beforeTransaction(ctx);
            let new_pool=await contract.MintPPA(ctx,newPPA.CustomerID,newPPA_TransactionID,'POOL');
            let modifiedPool=POOL;
            modifiedPool.ppaIDs.push(newPPA.ppaID);
            expect(new_pool).to.eql(modifiedPool)
        });
    })
    describe('TESTING: Farmer can request a maintenance service', () =>{
        let ID;
        let IrrigatorClientCertAsBytes,IrrigatorClientID,IrrigatorClientCert;
        let PPA,newPPA
        let argDate;
        let OriginatorClientCertAsBytes,OriginatorClientID,OriginatorClientCert;
        let right_Service;


        beforeEach(() => {

            IrrigatorClientID= "12345678P";
            IrrigatorClientCert="IrrigatorClientCert";
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');

            OriginatorClientID= "12345678A";
            OriginatorClientCert="OriginatorClientCert";
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            //variable to mock getTxID()
            Test="test";
            secret="secret";

            // PPA state
            TransactionID=crypto.createHash('sha256', secret).update('1').digest('hex');

            date=new Date()
            argDate=date.toUTCString();
            let lastModificationOn=new Date(argDate)

            TransactionID=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
                IsSigned: true,
                IsIssued: true,
                OwnerID: OriginatorClientID,
                IsInDefault: false,
                // MaintenanceServiceRequest: right_Service,
                // LastModificationOn: new Date(argDate),
                // LastMaintenanceServiceOn: PPA.LastModificationOn,
                // ServiceRequestDate: PPA.LastModificationOn,
                // IsServiceMaintenanceOn: true,
                // LastModificationUserID: PPA.CustomerID,

            }


            newPPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
                IsSigned: true,
                IsIssued: true,
                OwnerID:OriginatorClientID,
                IsInDefault: false,
                MaintenanceServiceRequest: right_Service,
                LastModificationOn: lastModificationOn,
                LastMaintenanceServiceOn: lastModificationOn,
                ServiceRequestDate: lastModificationOn,
                IsServiceMaintenanceOn: true,
                LastModificationUserID: IrrigatorClientID,

            }


            right_Service="service1"

            mockStub.getDateTimestamp.returns(argDate)
            mockClientIdentity.getMSPID.returns('farmerMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(IrrigatorClientID);
            mockStub.createCompositeKey.withArgs('PPA',[PPA.CustomerID,TransactionID]).returns('PPA'+PPA.CustomerID+TransactionID)


            FunctionAndParameters={
                fcn: "MaintenanceServiceRequest",
                params: [TransactionID,"service1"]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);

        });

        it('Should throw an error if user is neither a Farmer nor an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty string', async () =>{
            FunctionAndParameters.params=[PPA.ppaID,''];
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal(`Error`);
                expect(err.message).to.equal(`There is at least one empty parameter`)
            }
        });
        it('Should throw an error if user is not a Farmer member', async () =>{
            mockClientIdentity.getMSPID.returns('originatorMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if PPA does not exist', async () =>{
            await contract.beforeTransaction(ctx);
            try {
                await contract.MaintenanceServiceRequest(ctx,TransactionID,right_Service);
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`PPA with ID ${PPA.ppaID} does not exist`)
            }
        });
        it('Should throw an error if Customer ID of PPA and user ID from his/her eCert do not match', async () =>{
            PPA.CustomerID="12345678D"
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MaintenanceServiceRequest(ctx,TransactionID,right_Service)
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Customer ID and User ID do not match`)
            }
        });
        it('Should throw an error if user has NOT signed his/her PPA', async () =>{
            PPA.IsSigned=false;
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MaintenanceServiceRequest(ctx,TransactionID,right_Service)
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
    			expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This PPA has not been signed`)
            }
        });
        it('Should throw an error if PPA is in default', async () =>{
            PPA.IsInDefault =true;
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MaintenanceServiceRequest(ctx,TransactionID,right_Service)
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if service requested is not available', async () =>{
            let wrong_Service="service1234124"
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MaintenanceServiceRequest(ctx,TransactionID,wrong_Service)
                assert.fail('MaintenanceServiceRequest should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`The ${wrong_Service} service is not available`)
            }
        });
        it('Return success', async () =>{
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.MaintenanceServiceRequest(ctx,TransactionID,right_Service)
            expect(ret).to.eql(newPPA);
        });
    })
    describe('TESTING: Originator Issue Electricity Bills', () =>{
        let energyConsumption;

        let ID;
        let IrrigatorClientCertAsBytes,IrrigatorClientID,IrrigatorClientCert;
        let PPA,newPPA
        let argDate;
        let OriginatorClientCertAsBytes,OriginatorClientID,OriginatorClientCert;
        let right_Service;


        beforeEach(() => {

            IrrigatorClientID= "12345678P";
            IrrigatorClientCert="IrrigatorClientCert";
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');

            OriginatorClientID= "12345678A";
            OriginatorClientCert="OriginatorClientCert";
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            //variable to mock getTxID()
            Test="test";
            secret="secret";

            // PPA state
            TransactionID=crypto.createHash('sha256', secret).update('1').digest('hex');

            date=new Date()
            argDate=date.toUTCString();
            let lastModificationOn=new Date(argDate)

            TransactionID=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
                IsSigned: true,
                IsIssued: false,
                OwnerID: OriginatorClientID,
                IsInDefault: false,
                EnergyConsumption: [],
                PaymentsFrequency: 12,
                LastEnergyConsumption: '',
                BillDate: '',
                LastModificationOn: new Date(argDate),
                IsLastBillPaid: true,
                LastModificationUserID: OriginatorClientID,
            }


            newPPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
                IsSigned: true,
                IsIssued: true,
                OwnerID:OriginatorClientID,
                IsInDefault: false,
                MaintenanceServiceRequest: right_Service,
                LastModificationOn: lastModificationOn,
                LastMaintenanceServiceOn: lastModificationOn,
                ServiceRequestDate: lastModificationOn,
                IsServiceMaintenanceOn: true,
                LastModificationUserID: IrrigatorClientID,

            }


            mockStub.getDateTimestamp.returns(argDate)

            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OriginatorClientID);
            mockStub.createCompositeKey.withArgs('PPA',[PPA.CustomerID,TransactionID]).returns('PPA'+PPA.CustomerID+TransactionID)

            energyConsumption="124.123";

            FunctionAndParameters={
                fcn: "EnergyConsumptionPerPPA",
                params: [PPA.CustomerID,TransactionID,energyConsumption]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('Should throw an error if user is neither an Originator nor a Farmer member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP');
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('EnergyConsumptionPerPPA should throw an Error');
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('EnergyConsumptionPerPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty string', async () =>{
            FunctionAndParameters.params=[PPA.ppaID,''];
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('EnergyConsumptionPerPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it('Should throw an error if user is not an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('farmerMSP');
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('EnergyConsumptionPerPPA should throw an Error');
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if PPA does not exist', async () =>{
            await contract.beforeTransaction(ctx);
            try {
                await contract.EnergyConsumptionPerPPA(ctx,PPA.CustomerID,TransactionID,energyConsumption)
                assert.fail('EnergyConsumptionPerPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`State with ID ${PPA.ppaID} does not exist`)
            }
        });
        // TODO
        // it('Should throw an error if Energy has wrong format', async () => {
        //     mockStub.getState.withArgs(PPA_compare.ppaID).returns(Buffer.from(JSON.stringify(PPA_compare)));
        //     await contract.beforeTransaction(ctx);
        //     try {
        //         await contract.EnergyConsumptionPerUser(ctx,PPA_compare.ppaID,"123.345",argDate)
        //         assert.fail('EnergyConsumptionPerUser should throw an Error')
		// 	} catch(err) {
        //
		// 		expect(err.name).to.equal('Error');
        //         expect(err.message).to.equal(`Error: PPA for user ${CustomerID} has already been offered`)
        //     }
        // })
        it('Should throw an error if Owner ID of PPA and user ID from his/her eCert do not match (only Owner can Issue Electricity Bills)', async () =>{
            PPA.OwnerID="12345678S";
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.EnergyConsumptionPerPPA(ctx,PPA.CustomerID,TransactionID,energyConsumption)
                assert.fail('EnergyConsumptionPerPPA should throw an Error')
			} catch(err) {
     			expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        })
        it('Should throw an error if user has NOT signed his/her PPA', async () =>{
            PPA.IsSigned=false;
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.EnergyConsumptionPerPPA(ctx,PPA.CustomerID,TransactionID,energyConsumption)
                assert.fail('EnergyConsumptionPerPPA should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This PPA has not been signed`)
            }
        });
        it('Case 1: first bill', async () =>{
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            let ppa_result=await contract.EnergyConsumptionPerPPA(ctx,PPA.CustomerID,TransactionID,energyConsumption);
            PPA.EnergyConsumption.push(parseFloat(energyConsumption));
            PPA.LastEnergyConsumption=parseFloat(energyConsumption);
            PPA.BillDate=PPA.LastModificationOn;
            PPA.IsLastBillPaid=false;
            expect(ppa_result).to.eql(PPA);
        });
        it('Case 2: another bills', async () =>{
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            let energy_month2="40.123";
            PPA.EnergyConsumption.push(parseFloat(energy_month2));
            PPA.LastEnergyConsumption=parseFloat(energy_month2);
            PPA.BillDate=PPA.LastModificationOn;
            PPA.IsLastBillPaid=false;
            await contract.beforeTransaction(ctx);
            let ppa_result=await contract.EnergyConsumptionPerPPA(ctx,PPA.CustomerID,TransactionID,energy_month2);
            expect(ppa_result).to.eql(PPA);
        });
        it('Case 3: first bill of the year', async () =>{
            let energy=[123.345,123.345,123.345,123.345,123.345,123.345,123.345,123.345,123.345,123.345,123.345,56.120]
            PPA.EnergyConsumption=energy;
            PPA.LastEnergyConsumption=56.120;
            PPA.BillDate=PPA.LastModificationOn;
            PPA.IsLastBillPaid=true;

            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            let ppa_result=await contract.EnergyConsumptionPerPPA(ctx,PPA.CustomerID,TransactionID,"100.001");
            PPA.EnergyConsumption=[];
            PPA.IsLastBillPaid=false;
            PPA.EnergyConsumption.push(100.001);
            PPA.LastEnergyConsumption=100.001;
            PPA.BillDate=PPA.LastModificationOn;
            expect(ppa_result).to.eql(PPA);
        });
        it('Case 4: farmer is in default', async () =>{
            PPA.IsLastBillPaid=false;
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            let energy_month2="40.123";
            PPA.EnergyConsumption.push(parseFloat(energy_month2));
            PPA.LastEnergyConsumption=parseFloat(energy_month2);
            PPA.BillDate=PPA.LastModificationOn;
            PPA.IsLastBillPaid=false;
            PPA.IsInDefault=false;
            await contract.beforeTransaction(ctx);
            let ppa_result=await contract.EnergyConsumptionPerPPA(ctx,PPA.CustomerID,TransactionID,energy_month2);
            expect(ppa_result).to.eql(PPA);
        });
    })
    describe('TESTING: Farmer member pays monthly to POOL token Owner according to bill Minted', () =>{
        let old_txid;
        let right_OwnerID;
        let typeID, date;

        let securitizationCoin;
        let key, amount;
        let unitPrice;
        let minimumMonthlyFee;
        let facturacionMensual;

        let ID;
        let IrrigatorClientCertAsBytes,IrrigatorClientID,IrrigatorClientCert;
        let PPA
        let argDate;
        let OriginatorClientCertAsBytes,OriginatorClientID,OriginatorClientCert;
        let IssuerClientCert, IssuerClientCertAsBytes;
        let energyConsumption
        let GenericIDOutput
        let type;
        let TransactionID1

        beforeEach(() => {

            IrrigatorClientID= "12345678P";
            IrrigatorClientCert="IrrigatorClientCert";
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');

            OriginatorClientID= "12345678A";
            OriginatorClientCert="OriginatorClientCert";
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            //variable to mock getTxID()
            Test="test";
            secret="secret";

            // PPA state
            TransactionID=crypto.createHash('sha256', secret).update('1').digest('hex');

            date=new Date()
            argDate=date.toUTCString();
            let lastModificationOn=new Date(argDate)


            energyConsumption="124.123";
            unitPrice=0.20;
            minimumMonthlyFee=99.99;
            facturacionMensual=[100.45,101.45];


            TransactionID1=crypto.createHash('sha256', secret).update('PPA').digest('hex');
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+IrrigatorClientID+TransactionID1,
                Customer: IrrigatorClientCertAsBytes,
                CustomerID: IrrigatorClientID,
                IsSigned: true,
                IsIssued: false,
                EnergyConsumption: [120,300],
                PaymentsFrequency: 12,
                IsLastBillPaid: true,
                LastEnergyConsumption: 300,
                BillDate: '',
                LastModificationOn: new Date(argDate),
                IsInDefault: false,
                IsLastBillPaid: true,
                LastModificationUserID: right_OwnerID,
                LimitDate: 3,
                UnitPrice: unitPrice,
                MinimumMonthlyFee: minimumMonthlyFee,
                FacturacionMensual: facturacionMensual,
            }

            TransactionID=crypto.createHash('sha256', secret).update('CashTokenOutput').digest('hex');

            GenericIDOutput=TransactionID
            mockStub.getDateTimestamp.returns(argDate)
            mockStub.getTxID.returns(TransactionID);

            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(IrrigatorClientID);


            TransactionID=crypto.createHash('sha256', secret).update('CashTokenInput').digest('hex');
            typeID=":0"
            key="securitizationCoin"+ IrrigatorClientID+TransactionID;
            amount="100.01"
            IssuerClientCert="IssuerClientCert";
            IssuerClientCertAsBytes=Buffer.from(IssuerClientCert).toString('base64');

            securitizationCoin= {
                ID: key+ typeID,
                GenericID: TransactionID,
                TypeID: typeID,
                Issuer: IssuerClientCertAsBytes,
                Owner: IrrigatorClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };



            mockStub.createCompositeKey.withArgs('securitizationCoin',[securitizationCoin.Owner,securitizationCoin.GenericID]).returns('securitizationCoin'+securitizationCoin.Owner+securitizationCoin.GenericID)

            mockClientIdentity.getMSPID.returns('farmerMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(IrrigatorClientID);

            mockStub.createCompositeKey.withArgs('PPA',[PPA.CustomerID,TransactionID1]).returns('PPA'+PPA.CustomerID+TransactionID1)

            FunctionAndParameters={
                fcn: "MonthlyBillPayout",
                params: [TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);

        });
        it('Should throw an error if user is neither a Farmer nor an Originator member', async () =>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty string', async () =>{
            FunctionAndParameters.params=[TransactionID1,securitizationCoin.genericID,''];
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`)
            }
        });
        it('Should throw an error if user is not a Farmer member', async () =>{
            mockClientIdentity.getMSPID.returns('originatorMSP')
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if Token does not exist', async () =>{
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID);
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error token with ID ${'securitizationCoin'+securitizationCoin.Owner+securitizationCoin.GenericID} does not exist`)
            }
        });
        it('Should throw an error if Token cannot be used', async () =>{
            securitizationCoin.CanBeUsed=false;
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error, token with ID ${securitizationCoin.GenericID} is allocated to other services. Try to use another key or cancel whatever your token is allocated to`)
            }
        });
        it('Should throw an error if PPA does not exist', async () =>{
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`PPA with ID ${TransactionID1} does not exist`)
            }
        });
        it('Should throw an error if Customer ID of PPA and user ID from his/her eCert do not match', async () =>{
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            PPA.CustomerID="12345678H";
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user has NOT signed his/her PPA', async () =>{
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            PPA.IsSigned=false;
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`PPA with ID ${TransactionID1} has not been signed`)
            }
        });
        it('Check NON-WORKING days; Case 1: both days are working days', async () =>{
            let notificationDate=new Date(2021,11,11);
            let currentDate=new Date(2022,0,19);
            // We have the following non working days:
            // const nonWorkingDay1=new Date(2022,0,1)
            // const nonWorkingDay2=new Date(2021,11,25);
            // const nonWorkingDay3=new Date(2022,4,1)

            // So, we must obtain 2 days
            let ret=await contract._checkNonWorkingDays(currentDate,notificationDate);
            expect(ret).to.be.equal(2)
        });
        it('Check NON-WORKING days; Case 2: notificationDate is a non-working day', async () =>{
            let notificationDate=new Date(2021,11,25);
            let currentDate=new Date(2022,0,19);
            // We have the following non working days:
            // const nonWorkingDay1=new Date(2022,0,1)
            // const nonWorkingDay2=new Date(2021,11,25);
            // const nonWorkingDay3=new Date(2022,4,1)

            // So, we must obtain 2 days

            let ret=await contract._checkNonWorkingDays(currentDate,notificationDate);
            expect(ret).to.be.equal(2)
        });
        it('Check NON-WORKING days; Case 3: currentDate is a non-working day', async () =>{
            let notificationDate=new Date(2021,11,27);
            let currentDate=new Date(2022,0,1);
            // We have the following non working days:
            // const nonWorkingDay1=new Date(2022,0,1)
            // const nonWorkingDay2=new Date(2021,11,25);
            // const nonWorkingDay3=new Date(2022,4,1)

            // So, we must obtain 1 day

            let ret=await contract._checkNonWorkingDays(currentDate,notificationDate);
            expect(ret).to.be.equal(1)
        });
        it('Check NON-WORKING days; Case 4: Both dates are non-working days', async () =>{
            let notificationDate=new Date(2021,11,25);
            let currentDate=new Date(2022,0,1);
            // We have the following non working days:
            // const nonWorkingDay1=new Date(2022,0,1)
            // const nonWorkingDay2=new Date(2021,11,25);
            // const nonWorkingDay3=new Date(2022,4,1)

            // So, we must obtain 2 days

            let ret=await contract._checkNonWorkingDays(currentDate,notificationDate);
            expect(ret).to.be.equal(2)
        });
        it('Should throw an error if difference between CurrentDate and BillDate is more than LimitDate.', async () =>{
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,22);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate)
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1)
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Try to pay before time limit`)
            }
        });
        it('Should pass because valueLimit +nonworkingdays>= dates difference. ', async () =>{
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.IsLastBillPaid=true
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate)
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1)
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You have already paid this bill`)
            }
        });
        it('Should throw an error if no Bill has been minted', async () =>{
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.LimitDate=10;
            PPA.IsLastBillPaid=true
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate);
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You have already paid this bill`)
            }
        });
        it('Should throw an error if user has not enough funds to pay Bill. Case 1: first Bill', async () =>{
            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMenusal) => {
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-Math.sum(par_FacturacionMenusal))];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };

            let bill;
            securitizationCoin.Amount=parseInt(parseFloat("30.02")*100)
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[];
            PPA.EnergyConsumption=[100.564]

            PPA.LastEnergyConsumption=100.564;
            let currentDate=new Date(2022,4,3);
            bill=myFunctions.firstMonthlyPayment(PPA.UnitPrice,PPA.LastEnergyConsumption,PPA.MinimumMonthlyFee);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate);
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,OriginatorClientID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Please add more coins to your wallet, or pool them. Bill amounts to ${bill.toFixed(2)}`)
            }
        });
        it('Should throw an error if user has not enough funds to pay Bill. Case 2: successive Bill', async () =>{
            securitizationCoin.Amount=parseInt(parseFloat("30.02")*100)
            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMensual) => {
                    let total=par_FacturacionMensual.reduce(function(a, b){ return a + b; });
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-total)];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };
            let bill;

            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[99.99,99.99];
            PPA.EnergyConsumption=[100.564,234.221,150.345]
            PPA.LastEnergyConsumption=150.345
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate);
            bill=myFunctions.succesiveMonthlyPayments(PPA.LastEnergyConsumption,PPA.UnitPrice,PPA.MinimumMonthlyFee,PPA.EnergyConsumption,PPA.FacturacionMensual);
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,OriginatorClientID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Please add more coins to your wallet, or pool them. Bill amounts to ${bill.toFixed(2)}`)
            }
        });
        it('Should throw an error if user has not enough funds to pay Bill. Case 1.1: first Bill. MonthlyFee<Consumption', async () =>{
            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMenusal) => {
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-Math.sum(par_FacturacionMenusal))];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };

            let bill;

            securitizationCoin.Amount=parseInt(parseFloat("30.02")*100)
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[];
            PPA.EnergyConsumption=[734.221]

            PPA.LastEnergyConsumption=734.221;
            let currentDate=new Date(2022,4,3);
            bill=myFunctions.firstMonthlyPayment(PPA.UnitPrice,PPA.LastEnergyConsumption,PPA.MinimumMonthlyFee);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate)
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,OriginatorClientID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Please add more coins to your wallet, or pool them. Bill amounts to ${bill.toFixed(2)}`)
            }
        });
        it('Should throw an error if user has not enough funds to pay Bill. Case 2.1: successive Bill.MonthlyFee<Consumption', async () =>{
            securitizationCoin.Amount=parseInt(parseFloat("30.02")*100)
            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMensual) => {
                    let total=par_FacturacionMensual.reduce(function(a, b){ return a + b; });
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-total)];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };
            let bill;

            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[99.99,99.99];
            PPA.EnergyConsumption=[100.564,234.221,750.345]
            PPA.LastEnergyConsumption=750.345
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate);
            bill=myFunctions.succesiveMonthlyPayments(PPA.LastEnergyConsumption,PPA.UnitPrice,PPA.MinimumMonthlyFee,PPA.EnergyConsumption,PPA.FacturacionMensual);
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,OriginatorClientID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            await contract.beforeTransaction(ctx);
            try {
                await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
                assert.fail('MonthlyBillPayout should throw an Error')
			} catch(err) {
				expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Please add more coins to your wallet, or pool them. Bill amounts to ${bill.toFixed(2)}`)
            }
        });
        it('Should return success if user has enough funds to pay Bill. Case 1: first Bill', async () =>{
            let amount="1000.01"
            let quantityToTransfer="500.02"
            securitizationCoin.Amount=parseInt(parseFloat(amount)*100)

            key="securitizationCoin"+OriginatorClientID+GenericIDOutput
            type=':0'
            let securitizationCoin_Output1= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: OriginatorClientID,
                Amount: parseInt(parseFloat(quantityToTransfer)*100),
                Factor: 100,
                CanBeUsed: true
            };
            typeID=':1'
            let balance=parseFloat(amount)-parseFloat(quantityToTransfer);
            key="securitizationCoin"+IrrigatorClientID+GenericIDOutput;
            let securitizationCoin_Output2= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: IrrigatorClientID,
                Amount: parseInt(balance*100),
                Factor: 100,
                CanBeUsed: true
            };
            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMenusal) => {
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-Math.sum(par_FacturacionMenusal))];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };

            let bill;
            let token=[]
            if (balance>0){
                token[1]=securitizationCoin_Output1;
                token[0]=securitizationCoin_Output2;
            }else if(balance===0){
                token[0]=securitizationCoin_Output2;
            }
            // mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[];

            PPA.EnergyConsumption=[234.221]
            PPA.LastEnergyConsumption=234.221;
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate)
            bill=myFunctions.firstMonthlyPayment(PPA.UnitPrice,PPA.LastEnergyConsumption,PPA.MinimumMonthlyFee);
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,OriginatorClientID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            sinon.stub(contract, '_TransferMoney').returns(token);
            sinon.stub(contract,'_getCouponProportion').returns(1)
            await contract.beforeTransaction(ctx);
            let ret= await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
            expect(ret).to.eql(token)
        });
        it('Should return success if user has not enough funds to pay Bill. Case 1.1: first Bill. balance=0', async () =>{
            let amount="1000.01"
            let quantityToTransfer="500.02"
            securitizationCoin.Amount=parseInt(parseFloat(amount)*100)

            key="securitizationCoin"+OriginatorClientID+GenericIDOutput
            type=':0'
            let securitizationCoin_Output1= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: OriginatorClientID,
                Amount: parseInt(parseFloat(quantityToTransfer)*100),
                Factor: 100,
                CanBeUsed: true
            };
            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMenusal) => {
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-Math.sum(par_FacturacionMenusal))];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };

            let bill;

            // mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[];

            PPA.EnergyConsumption=[234.221]
            PPA.LastEnergyConsumption=234.221;
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate)
            bill=myFunctions.firstMonthlyPayment(PPA.UnitPrice,PPA.LastEnergyConsumption,PPA.MinimumMonthlyFee);

            let balance=securitizationCoin.Amount-securitizationCoin_Output1.Amount;
            // ////console.log(`balance: ${balance}`);
            typeID=':1'
            // let balance=parseFloat(amount)-parseFloat(quantityToTransfer);
            key="securitizationCoin"+IrrigatorClientID+GenericIDOutput;
            let securitizationCoin_Output2= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: IrrigatorClientID,
                Amount: parseInt(balance*100),
                Factor: 100,
                CanBeUsed: true
            };

            let token=[]
            if (balance>0){
                token[1]=securitizationCoin_Output1;
                token[0]=securitizationCoin_Output2;
            }else if(balance===0){
                token[0]=securitizationCoin_Output2;
            }
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,right_OwnerID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            sinon.stub(contract, '_TransferMoney').returns(token);
            sinon.stub(contract,'_getCouponProportion').returns(1)

            await contract.beforeTransaction(ctx);
            let ret=await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
            expect(ret).to.eql(token)
        });
        it('Should return success if user has enough funds to pay Bill. (POOL Owner is SPV CLIENT) Case 2: successive Bill', async () =>{
            let couponPortion=0.1

            let amount="1000.01"
            let quantityToTransfer="500.02"
            let balance=parseInt(parseFloat(amount)*100)-parseInt(parseFloat(quantityToTransfer));

            let SPVClientID,SPVClientCert,SPVClientCertAsBytes;
            SPVClientID="12345678V"
            SPVClientCert="SPVClientCert"
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');
            typeID=':0'
            key="securitizationCoin"+SPVClientID+GenericIDOutput
            let securitizationCoin_Output1= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: SPVClientID,
                Amount: couponPortion*parseInt(parseFloat(quantityToTransfer)*100),
                Factor: 100,
                CanBeUsed: true
            };
            typeID=':2'
            let securitizationCoin_Output3= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientID,
                Owner: SPVClientID,
                Amount: (1-couponPortion)*parseInt(balance*100),
                Factor: 100,
                CanBeUsed: false
            };
            typeID=':1'
            key="securitizationCoin"+IrrigatorClientID+GenericIDOutput;
            let securitizationCoin_Output2= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCert,
                Owner: IrrigatorClientID,
                Amount: parseInt(balance*100),
                Factor: 100,
                CanBeUsed: true
            };

            let token=[]
            if (balance>0){
                token[1]=securitizationCoin_Output1;
                token[0]=securitizationCoin_Output2;
                token[2]=securitizationCoin_Output3
            }else if(balance===0){
                token[0]=securitizationCoin_Output2;
                token[1]=securitizationCoin_Output3;
            }

            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMensual) => {
                    let total=par_FacturacionMensual.reduce(function(a, b){ return a + b; });
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-total)];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };
            let bill;
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[99.99,99.99];
            PPA.EnergyConsumption=[100.564,234.221,150.345]
            PPA.LastEnergyConsumption=150.345
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate);
            bill=myFunctions.succesiveMonthlyPayments(PPA.LastEnergyConsumption,PPA.UnitPrice,PPA.MinimumMonthlyFee,PPA.EnergyConsumption,PPA.FacturacionMensual);
            balance=securitizationCoin.Amount-parseInt(parseFloat(bill)*100)
            securitizationCoin_Output1.Amount=parseInt(parseFloat(bill)*100);
            securitizationCoin_Output1.Amount=balance;

            mockStub.putState(PPA.ppaID,Buffer.from(JSON.stringify(PPA)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,SPVClientID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            sinon.stub(contract, '_TransferMoneyToCouponAndPrincipal').returns(token);
            sinon.stub(contract,'_getCouponProportion').returns(couponPortion)
            await contract.beforeTransaction(ctx);
            let ret=await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
            expect(ret).to.eql(token)
        });
        it('Should return success if user has enough funds to pay Bill (POOL Owner is SPV CLIENT). Case 2.1: successive Bill. balance=0', async () =>{
            let couponPortion=0.1

            // let balance=parseInt(parseFloat(amount)*100)-parseInt(parseFloat(quantityToTransfer));

            let SPVClientID,SPVClientCert,SPVClientCertAsBytes;
            SPVClientID="12345678V"
            SPVClientCert="SPVClientCert"
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');

            mockClientIdentity.getIDBytes.returns(IrrigatorClientCertAsBytes);
            let amount="1000.01"
            let quantityToTransfer="500.02"
            typeID=":0"
            key="securitizationCoin"+ SPVClientID+GenericIDOutput;
            let securitizationCoin_Output1= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: SPVClientID,
                Amount: parseInt(parseFloat(quantityToTransfer)*100),
                Factor: 100,
                CanBeUsed: true
            };

            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMensual) => {
                    let total=par_FacturacionMensual.reduce(function(a, b){ return a + b; });
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-total)];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };
            let bill;
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[99.99,99.99];
            PPA.EnergyConsumption=[100.564,234.221,750.345]
            PPA.LastEnergyConsumption=750.345
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate);
            bill=myFunctions.succesiveMonthlyPayments(PPA.LastEnergyConsumption,PPA.UnitPrice,PPA.MinimumMonthlyFee,PPA.EnergyConsumption,PPA.FacturacionMensual);
            securitizationCoin.Amount=parseInt(parseFloat(bill.toFixed(2))*100);
            securitizationCoin_Output1.Amount=parseInt(parseFloat(bill.toFixed(2))*100);
            typeID=':1'
            let balance=securitizationCoin.Amount-securitizationCoin_Output1.Amount;
            key="securitizationCoin"+IrrigatorClientID+GenericIDOutput;
            let securitizationCoin_Output2= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: IrrigatorClientID,
                Amount: parseInt(balance*100),
                Factor: 100,
                CanBeUsed: true
            };
            let token=[]
            if (balance>0){
                token[1]=securitizationCoin_Output1;
                token[0]=securitizationCoin_Output2;
            }else if(balance===0){
                token[0]=securitizationCoin_Output2;
            }
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[true,SPVClientID];
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            sinon.stub(contract, '_TransferMoneyToCouponAndPrincipal').returns(token);
            sinon.stub(contract,'_getCouponProportion').returns(couponPortion)

            await contract.beforeTransaction(ctx);
            let ret=await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
            expect(ret).to.eql(token)
        });
        it('Should return success if user has enough funds to pay Bill (PPA not pooled). Case 3', async () =>{
            mockClientIdentity.getIDBytes.returns(IrrigatorClientCertAsBytes);
            let amount="1000.01"
            let quantityToTransfer="500.02"
            typeID=":0"
            key="securitizationCoin"+ OriginatorClientID+GenericIDOutput;
            let securitizationCoin_Output1= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: OriginatorClientID,
                Amount: parseInt(parseFloat(quantityToTransfer)*100),
                Factor: 100,
                CanBeUsed: true
            };

            const myFunctions={
                firstMonthlyPayment:  (par_UnitPrice,par_EnergyConsumption, par_MinimumMonthlyFee) => {
                    const values=[par_UnitPrice*par_EnergyConsumption,par_MinimumMonthlyFee]
                    const resultado=Math.max(...values);
                    return resultado
                },
                succesiveMonthlyPayments: (par_LastEnergyConsumption,par_UnitPrice,par_MinimumMonthlyFee,par_EnergyConsumption,par_FacturacionMensual) => {
                    let total=par_FacturacionMensual.reduce(function(a, b){ return a + b; });
                    const values=[par_LastEnergyConsumption*par_UnitPrice,Math.abs(par_MinimumMonthlyFee*par_EnergyConsumption.length-total)];
                    const resultado=Math.max(...values);
                    return resultado
                },
            };
            let bill;
            let billDate=new Date(2022,3,30);
            PPA.BillDate=billDate;
            PPA.IsLastBillPaid=false;
            PPA.LimitDate=3;
            PPA.FacturacionMensual=[99.99,99.99];
            PPA.EnergyConsumption=[100.564,234.221,750.345]
            PPA.LastEnergyConsumption=750.345
            let currentDate=new Date(2022,4,3);
            let argCurrentDate=currentDate.toUTCString();
            mockStub.getDateTimestamp.returns(argCurrentDate);
            bill=myFunctions.succesiveMonthlyPayments(PPA.LastEnergyConsumption,PPA.UnitPrice,PPA.MinimumMonthlyFee,PPA.EnergyConsumption,PPA.FacturacionMensual);
            securitizationCoin.Amount=parseInt(parseFloat(bill.toFixed(2))*100);
            securitizationCoin_Output1.Amount=parseInt(parseFloat(bill.toFixed(2))*100);
            typeID=':1'
            let balance=securitizationCoin.Amount-securitizationCoin_Output1.Amount;
            key="securitizationCoin"+IrrigatorClientID+GenericIDOutput;
            let securitizationCoin_Output2= {
                ID: key+ typeID,
                GenericID: GenericIDOutput,
                TypeID: typeID,
                Issuer: IrrigatorClientCertAsBytes,
                Owner: IrrigatorClientID,
                Amount: parseInt(balance*100),
                Factor: 100,
                CanBeUsed: true
            };
            let token=[]
            if (balance>0){
                token[1]=securitizationCoin_Output1;
                token[0]=securitizationCoin_Output2;
            }else if(balance===0){
                token[0]=securitizationCoin_Output2;
            }
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            mockStub.getState.withArgs(PPA.ppaID).returns(Buffer.from(JSON.stringify(PPA)));
            sinon.stub(contract, '_checkNonWorkingDays').returns(1);
            let isPPAinPool=[false,''];
            //Bill goes directly from irrigator to Originator (i.e. the owner of the PPA)
            sinon.stub(contract,'_isPPAinPool').returns(isPPAinPool);
            sinon.stub(contract, '_TransferMoney').returns(token);
            sinon.stub(contract,'_getCouponProportion').returns(1)
            await contract.beforeTransaction(ctx);
            let ret=await contract.MonthlyBillPayout(ctx,TransactionID1,securitizationCoin.GenericID,securitizationCoin.TypeID)
            expect(ret).to.eql(token)
        });
    })

});


describe('Securitization (structuring) Test', () => {
    let ctx;
    let sandbox,mockClientIdentity,mockStub;
    let contract;

    beforeEach(() => {
        sandbox = sinon.createSandbox();
        contract= new SecuritizationContract.bondIssuanceContract();
        ctx = new SecuritizationContract.securitizationContext();

        mockStub=sinon.createStubInstance(ChaincodeStub);
        ctx.stub= mockStub;
        mockClientIdentity=sinon.createStubInstance(ClientIdentity);
        ctx.clientIdentity=mockClientIdentity;


        mockStub.getState.callsFake(async (key) => {
            let ret;
            if (mockStub.states) {
                ret = mockStub.states[key];
            }
            return Promise.resolve(ret);
        });

        mockStub.deleteState.callsFake(async (key) => {
            if (mockStub.states) {
                delete mockStub.states[key];
            }
            return Promise.resolve(key);
        });

        mockStub.putState.callsFake((key, value) => {
            if (!mockStub.states) {
                mockStub.states = {};
            }
            mockStub.states[key] = value;
        });

        mockStub.getStateByPartialCompositeKey.callsFake(async () => {
            function* internalGetStateByPartialCompositeKey() {
                if (mockStub.states) {
                    // Shallow copy
                    const copied = Object.assign({}, mockStub.states);
                    for (let key in copied) {
                        yield {value: copied[key]};
                    }
                }
            }
            return Promise.resolve(internalGetStateByPartialCompositeKey());
        });
    });

    afterEach('Sandbox restoration', () => {
        sandbox.restore();
    });

    describe('TESTING: afterTransaction works as expected', () =>{
        beforeEach(() => {

        })
        it('should return event', async () =>{

        });


    })

    describe('TESTING: createContext works as expected', () =>{
        it('Should return new Context', async ()=>{
            let newContext=new SecuritizationContract.securitizationContext()
            let ret =await contract.createContext();
            expect(ret).to.eql(newContext);
        });
    })
    describe('TESTING: _mygetStateByPartialCompositeKey works as expected', () => {

        let ppa1,ppa2;
        let txid1,txid2;
        let ID

        beforeEach(() => {
            txid1="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f"
            txid2="rytnd21bc278fdf6a32d00975602eb853e23a86a156781588d99ddqwe123asdq"

            ID="12345678A"
            ppa1={
                docType: 'PPA',
                ppaID: 'PPA'+ID+txid1,
                Customer: '',
                CustomerID: ID,
            };
            ppa2={
                docType: 'PPA',
                ppaID: 'PPA'+ID+txid2,
                Customer: '',
                CustomerID: ID,
            };

        })
        it('should throw an error if state is not unique', async () =>{
            mockStub.putState(ppa1.ppaID,Buffer.from(JSON.stringify(ppa1)));
            mockStub.putState(ppa2.ppaID,Buffer.from(JSON.stringify(ppa2)));
            try{
                await contract._mygetStateByPartialCompositeKey(ctx,ppa1.docType,ppa1.CustomerID);
                assert.fail('_mygetStateByPartialCompositeKey should throw an Error')
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal('This state-value pair is not unique')
            }
        })
        it('should return true if state does not exist', async () =>{
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,ppa1.docType,ppa1.CustomerID);
            expect(ret).to.eql(true)
        })
        it('should return state', async () =>{
            mockStub.putState(ppa1.ppaID,Buffer.from(JSON.stringify(ppa1)))
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,ppa1.ppaID,ppa1.CustomerID);
            expect(ret).to.eql(ppa1)
        })
    })
    describe('Auxiliary function _isPoolCreated works as expected', () =>
    {
        let date,argDate;
        let poolName;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let OriginatorClientCert,OriginatorClientCertAsBytes;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        beforeEach(() => {
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";


            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientCertAsBytes+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientCertAsBytes+TransactionID2
            ppaID3='PPA'+Irrigator3ClientCertAsBytes+TransactionID3
            ppaID4='PPA'+Irrigator4ClientCertAsBytes+TransactionID4
            ppaID5='PPA'+Irrigator5ClientCertAsBytes+TransactionID5
            ppaID6='PPA'+Irrigator6ClientCertAsBytes+TransactionID6
            ppaID7='PPA'+Irrigator7ClientCertAsBytes+TransactionID7
            ppaID8='PPA'+Irrigator8ClientCertAsBytes+TransactionID8
            ppaID9='PPA'+Irrigator9ClientCertAsBytes+TransactionID9
            ppaID10='PPA'+Irrigator10ClientCertAsBytes+TransactionID10


            date=new Date()
            argDate=date.toUTCString();

            mockStub.getDateTimestamp.returns(argDate);

            TransactionID=crypto.createHash('sha256', secret).update('POOL').digest('hex');
            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientCertAsBytes,
                LastModificationOn: new Date(2022,1,20)
            };
        });
        it('Should return false if Pool has not been created', async () =>{
            let ret=await contract._isPoolCreated(ctx,poolName);
            expect(ret).to.eql(false)
        });
        it ('Should return true if it only exists one POOL', async () => {
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            let ret=await contract._isPoolCreated(ctx,poolName);
            expect(ret).to.eql(true)
        });
        it ('Should throw an error if there are more than one State linked to that partial key', async () => {
            let NewTransactionID=crypto.createHash('sha256', secret).update('NewTransactionID').digest('hex');
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            Pool.poolID='POOL'+NewTransactionID
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            try{
                await contract._isPoolCreated(ctx,poolName);
                assert.fail('_isPoolCreated should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`State not unique`);
            }
        });
    })
    describe('TESTING: Auxiliary function _getPoolStateByPartialCompositeKey works as expected', () =>
    {
        let date,argDate;
        let poolName;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let OriginatorClientCert,OriginatorClientCertAsBytes, OriginatorClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        beforeEach(() => {
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";

            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K";




            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10

            date=new Date()
            argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('txid').digest('hex');

            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientID,
                LastModificationOn: argDate
            };

        });
        it('should return true if no Pool has been created', async () =>{
            let ret=await contract._getPoolStateByPartialCompositeKey(ctx,poolName);
            expect(ret[0]).to.eql(false)
        });
        it ('should throw an error if there are more than one state linked to one partial key', async () => {
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            Pool.poolID='POOL'+'1'+TransactionID
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            try{
                await contract._getPoolStateByPartialCompositeKey(ctx,poolName);
                assert.fail('_getPoolStateByPartialCompositeKy should throw an Error')
            }catch(err){
                //
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This state-value pair is not unique`);
            }
        });
        it('returns pool', async ()=>{
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            let ret=await contract._getPoolStateByPartialCompositeKey(ctx,poolName);
            expect(ret[1]).to.eql(Pool)
            expect(ret[0]).to.eql(true)
        })
    })
    describe('SPV queries POOL', () =>
    {
        let date,argDate;
        let poolName;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let OriginatorClientCert,OriginatorClientCertAsBytes, OriginatorClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let SPVClientCert,SPVClientCertAsBytes,SPVClientID;
        let FunctionAndParameters;
        beforeEach(() => {
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";
            SPVClientCert="SPVClientCert";

            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K";
            SPVClientID="12345678L"




            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10

            date=new Date()
            argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('txid').digest('hex');

            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientID,
                LastModificationOn: argDate
            };


            mockClientIdentity.getMSPID.returns('spvMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(SPVClientID);

            poolName='POOL';
            FunctionAndParameters={
                fcn: "QueryPool",
                params: [poolName]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('should throw an error if user is neither an  Originator nor a SPV member', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns('farmerMSP');
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryPool should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryPool should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a SPV member', async () => {
            let wrong_OrgMSP='originatorMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryPool should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if any arg is an empty string', async () => {
            FunctionAndParameters.params=['']
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryPool should throw an Error');
            } catch(err) {
                //
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it('Should throw an error if Pool has not been created', async () =>{
            sinon.stub(contract, '_getPoolStateByPartialCompositeKey').returns([false])
            await contract.beforeTransaction(ctx);
            try {
                await contract.QueryPool(ctx,poolName)
                assert.fail('QueryPool should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is no Pool linked to name ${poolName}`);
            }
        })
        it('Should return pool', async () =>{
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)))
            let x=[true,Pool]
            sinon.stub(contract, '_isPoolCreated').returns(x)
            await contract.beforeTransaction(ctx);
            let ret= await contract.QueryPool(ctx,poolName);
            expect(ret).to.eql(Pool)
        })
    })
    describe('DvP starting. Phase 1: SPV makes a buy request',() =>
    {
        let txid;
        let amount,price;
        let poolOwnerID;
        let buyerID;
        let BuyRequest;
        let poolID;
        let new_genericID;

        let poolName
        let Pool;
        let date,argDate;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let OriginatorClientCert,OriginatorClientCertAsBytes, OriginatorClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let SPVClientCert,SPVClientCertAsBytes,SPVClientID;
        let FunctionAndParameters;
        beforeEach(() => {
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";
            SPVClientCert="SPVClientCert";

            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K";
            SPVClientID="12345678L"




            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10

            date=new Date()
            argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('txid').digest('hex');

            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientID,
                LastModificationOn: argDate
            };


            NewTransactionID=crypto.createHash('sha256', secret).update('Newtxid').digest('hex');

            mockStub.getTxID.returns(NewTransactionID);
            mockStub.createCompositeKey.withArgs('BuyRequest',[SPVClientID,NewTransactionID]).returns('BuyRequest'+SPVClientID+NewTransactionID);

            mockClientIdentity.getMSPID.returns('spvMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(SPVClientID);

            amount="10";
            price="100.23";
            poolName='POOL';
            poolID=poolName+TransactionID

            BuyRequest={
                ID: 'BuyRequest'+SPVClientID+NewTransactionID,
                Owner: SPVClientID,
                Receiver: '',
                Amount: parseInt(amount),
                Price: parseInt(parseFloat(price)*100),
                Factor: 100,
                IsSigned: false,
                PoolID: Pool.poolID
            };

            FunctionAndParameters={
                fcn: "BuyRequest",
                params: [amount,price,Pool.poolID]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('should throw an error if user is neither an  Originator nor a SPV member', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns('farmerMSP');
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('BuyRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('BuyRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a SPV member', async () => {
            let wrong_OrgMSP='originatorMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('BuyRequest should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if any arg is an empty string', async () => {
            FunctionAndParameters.params=[amount,price,'']
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('BuyRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it('should throw an Error if Pool State does not exist',async ()=>{
            mockStub.createCompositeKey.withArgs('POOL',[TransactionID]).returns('POOL'+TransactionID);
            await contract.beforeTransaction(ctx);
            try {
                await contract.BuyRequest(ctx,amount,price,TransactionID);
                assert.fail('BuyRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error`);
            }

        });
        it('Should return buyRequest', async () =>{
            mockStub.createCompositeKey.withArgs('POOL',[TransactionID]).returns('POOL'+TransactionID);
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.BuyRequest(ctx,amount,price,'POOL',TransactionID)
            expect(ret).to.eql(BuyRequest)
        })
    })
    describe('Originator queries Buy Requests',async () =>{

        let price, amount;
        let FunctionAndParameters;

        let OriginatorClientCert,OriginatorClientCertAsBytes,OriginatorClientID;
        let SPVClientID,SPVClientCert,SPVClientCertAsBytes;

        let date,argDate;

        let NewSPVClientCert,NewSPVClientID,NewSPVClientCertAsBytes
        let NewNewTransactionID, TransactionID,NewTransactionID;
        let secret="MySecret";
        let poolName,Pool;
        let BuyRequest,NewbuyRequest;
        beforeEach(() => {

            OriginatorClientCert="OriginatorClientCert";
            SPVClientCert="SPVClientCert";
            NewSPVClientCert="NewSPVClientCert";


            OriginatorClientID="12345678K";
            SPVClientID="12345678L"
            NewSPVClientID="12345678P";


            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');
            NewSPVClientCertAsBytes=Buffer.from(NewSPVClientCert).toString('base64');

            date=new Date()
            argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('txid').digest('hex');

            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
            };


            NewTransactionID=crypto.createHash('sha256', secret).update('Newtxid').digest('hex');

            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OriginatorClientID);

            amount="10";
            price="100.23";

            BuyRequest={
                ID: 'BuyRequest'+SPVClientID+NewTransactionID,
                Owner: SPVClientID,
                Receiver: '',
                Amount: parseInt(amount),
                Price: parseInt(parseFloat(price)*100),
                Factor: 100,
                IsSigned: false,
                PoolID: Pool.poolID
            };



            price="1249.12"
            amount='100'
            NewNewTransactionID=crypto.createHash('sha256', secret).update('NewNewtxid').digest('hex');

            NewbuyRequest={
                ID: 'BuyRequest'+NewSPVClientID+NewNewTransactionID,
                Owner: NewSPVClientID,
                Receiver: '',
                Amount: parseInt(amount),
                Price: parseInt(parseFloat(price)*100),
                Factor: 100,
                IsSigned: false,
                PoolID: Pool.poolID
            };


            FunctionAndParameters={
                fcn: 'QueryBuyRequest',
                params: []
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);

        })
        it('Should throw an error if user org is different from originator',async ()=>{
            mockClientIdentity.getMSPID.returns('spvMSP')
            try{
                await contract.beforeTransaction(ctx)
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Your organization spvMSP is not allowed to perform this action`)
            }
        })
        it('Should return one buy request',async ()=>{
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.QueryBuyRequest(ctx);
            expect(ret).to.eql([BuyRequest])
        })
        it('Should return two buy requests',async ()=>{
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)));
            mockStub.putState(NewbuyRequest.ID,Buffer.from(JSON.stringify(NewbuyRequest)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.QueryBuyRequest(ctx);
            let x=[BuyRequest,NewbuyRequest]
            expect(ret).to.eql(x)
        })
    })
    describe('DvP starting. Phase 2: Originator makes a Sell Request',() =>
    {
        let price;
        let SellRequest

        let poolName
        let Pool;
        let date,argDate;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Irrigator1ClientCert,Irrigator2ClientCert,Irrigator3ClientCert,Irrigator4ClientCert,Irrigator5ClientCert,Irrigator6ClientCert,Irrigator7ClientCert,Irrigator8ClientCert,Irrigator9ClientCert,Irrigator10ClientCert;
        let Irrigator1ClientCertAsBytes,Irrigator2ClientCertAsBytes,Irrigator3ClientCertAsBytes,Irrigator4ClientCertAsBytes,Irrigator5ClientCertAsBytes,Irrigator6ClientCertAsBytes,Irrigator7ClientCertAsBytes,Irrigator8ClientCertAsBytes,Irrigator9ClientCertAsBytes,Irrigator10ClientCertAsBytes;
        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let OriginatorClientCert,OriginatorClientCertAsBytes, OriginatorClientID;
        let secret="MySecret";
        let TransactionID,NewTransactionID;
        let SPVClientCert,SPVClientCertAsBytes,SPVClientID;
        let FunctionAndParameters;

        beforeEach(() => {
            TransactionID1=crypto.createHash('sha256', secret).update('1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('10').digest('hex');

            Irrigator1ClientCert="Irrigator1ClientCert";
            Irrigator2ClientCert="Irrigator2ClientCert";
            Irrigator3ClientCert="Irrigator3ClientCert";
            Irrigator4ClientCert="Irrigator4ClientCert";
            Irrigator5ClientCert="Irrigator5ClientCert";
            Irrigator6ClientCert="Irrigator6ClientCert";
            Irrigator7ClientCert="Irrigator7ClientCert";
            Irrigator8ClientCert="Irrigator8ClientCert";
            Irrigator9ClientCert="Irrigator9ClientCert";
            Irrigator10ClientCert="Irrigator10ClientCert";
            OriginatorClientCert="OriginatorClientCert";
            SPVClientCert="SPVClientCert";

            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";
            OriginatorClientID="12345678K";
            SPVClientID="12345678L"




            Irrigator1ClientCertAsBytes=Buffer.from(Irrigator1ClientCert).toString('base64');
            Irrigator2ClientCertAsBytes=Buffer.from(Irrigator2ClientCert).toString('base64');
            Irrigator3ClientCertAsBytes=Buffer.from(Irrigator3ClientCert).toString('base64');
            Irrigator4ClientCertAsBytes=Buffer.from(Irrigator4ClientCert).toString('base64');
            Irrigator5ClientCertAsBytes=Buffer.from(Irrigator5ClientCert).toString('base64');
            Irrigator6ClientCertAsBytes=Buffer.from(Irrigator6ClientCert).toString('base64');
            Irrigator7ClientCertAsBytes=Buffer.from(Irrigator7ClientCert).toString('base64');
            Irrigator8ClientCertAsBytes=Buffer.from(Irrigator8ClientCert).toString('base64');
            Irrigator9ClientCertAsBytes=Buffer.from(Irrigator9ClientCert).toString('base64');
            Irrigator10ClientCertAsBytes=Buffer.from(Irrigator10ClientCert).toString('base64');
            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');

            ppaID1='PPA'+Irrigator1ClientID+TransactionID1;
            ppaID2='PPA'+Irrigator2ClientID+TransactionID2
            ppaID3='PPA'+Irrigator3ClientID+TransactionID3
            ppaID4='PPA'+Irrigator4ClientID+TransactionID4
            ppaID5='PPA'+Irrigator5ClientID+TransactionID5
            ppaID6='PPA'+Irrigator6ClientID+TransactionID6
            ppaID7='PPA'+Irrigator7ClientID+TransactionID7
            ppaID8='PPA'+Irrigator8ClientID+TransactionID8
            ppaID9='PPA'+Irrigator9ClientID+TransactionID9
            ppaID10='PPA'+Irrigator10ClientID+TransactionID10

            date=new Date()
            argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('txid').digest('hex');

            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: OriginatorClientID,
                LastModificationOn: argDate
            };


            NewTransactionID=crypto.createHash('sha256', secret).update('Newtxid').digest('hex');

            mockStub.getTxID.returns(NewTransactionID);

            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OriginatorClientID);


            mockStub.createCompositeKey.withArgs('SellRequest',[OriginatorClientID,NewTransactionID]).returns('SellRequest'+OriginatorClientID+NewTransactionID);

            SellRequest={
                ID: 'SellRequest'+OriginatorClientID+NewTransactionID,
                Owner: OriginatorClientID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                IsSigned: false,
                Factor:100,
                BackedBy: Pool.poolID
            };

            poolName='POOL';
            FunctionAndParameters={
                fcn: "SellRequest",
                params: [price, Pool.poolID]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('should throw an error if user is neither an  Originator nor a SPV member', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns('farmerMSP');
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SellRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SellRequest should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a originator member', async () => {
            let wrong_OrgMSP='spvMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SellRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if any arg is an empty string', async () => {
            FunctionAndParameters.params=[price,'']
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SellRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it ('should throw an error if pool state does not exist', async () => {
            mockStub.createCompositeKey.withArgs(poolName,[TransactionID]).returns(poolName+TransactionID);
            try {
                await contract.beforeTransaction(ctx);
                await contract.SellRequest(ctx,price,TransactionID);
                assert.fail('SellRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error`);
            }
        });
        it('Should return sellRequest', async () =>{
            mockStub.createCompositeKey.withArgs(poolName,[TransactionID]).returns(poolName+TransactionID);
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.SellRequest(ctx,price,'POOL',TransactionID);
            expect(ret).to.eql(SellRequest);
        });
    })
    describe('SPV queries Sell Requests',async () =>{
        let amount
        let price;
        let FunctionAndParameters;

        let OriginatorClientCert,OriginatorClientCertAsBytes,OriginatorClientID;
        let SPVClientID,SPVClientCert,SPVClientCertAsBytes;

        let date,argDate;

        let NewOriginatorClientCert,NewOriginatorClientID,NewOriginatorClientCertAsBytes
        let NewNewTransactionID, TransactionID,NewTransactionID;
        let secret="MySecret";
        let poolName,Pool;
        let SellRequest,NewsellRequest;
        beforeEach(() => {

            OriginatorClientCert="OriginatorClientCert";
            SPVClientCert="SPVClientCert";
            NewOriginatorClientCert="NewOriginatorClientCert";


            OriginatorClientID="12345678K";
            SPVClientID="12345678L"
            NewOriginatorClientID="12345678P";


            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');
            NewOriginatorClientCertAsBytes=Buffer.from(NewOriginatorClientCert).toString('base64');

            date=new Date()
            argDate=date.toUTCString();

            TransactionID=crypto.createHash('sha256', secret).update('txid').digest('hex');

            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
            };


            NewTransactionID=crypto.createHash('sha256', secret).update('Newtxid').digest('hex');

            mockClientIdentity.getMSPID.returns('spvMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(SPVClientID);

            amount="10";
            price="100.23";

            SellRequest={
                ID: 'SellRequest'+OriginatorClientID+NewTransactionID,
                Owner: SPVClientID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                Factor: 100,
                IsSigned: false,
                BackedBy: Pool.poolID
            };



            price="1249.12"
            amount='100'
            NewNewTransactionID=crypto.createHash('sha256', secret).update('NewNewtxid').digest('hex');

            NewsellRequest={
                ID: 'SellRequest'+NewOriginatorClientID+NewNewTransactionID,
                Owner: NewOriginatorClientID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                Factor: 100,
                IsSigned: false,
                BackedBy: Pool.poolID
            };

            FunctionAndParameters={
                fcn: 'QuerySellRequest',
                params: []
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        })
        it('Should throw an error if user org is different from SPV',async ()=>{
            mockClientIdentity.getMSPID.returns('originatorMSP')
            try{
                await contract.beforeTransaction(ctx)
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Your organization originatorMSP is not allowed to perform this action`)
            }
        })
        it('Should return one sell request',async ()=>{
            mockStub.putState(SellRequest.ID,Buffer.from(JSON.stringify(SellRequest)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.QuerySellRequest(ctx);
            expect(ret).to.eql([SellRequest])
        })
        it('Should return two sell requests',async ()=>{
            mockStub.putState(SellRequest.ID,Buffer.from(JSON.stringify(SellRequest)));
            mockStub.putState(NewsellRequest.ID,Buffer.from(JSON.stringify(NewsellRequest)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.QuerySellRequest(ctx);
            let x=[SellRequest,NewsellRequest]
            expect(ret).to.eql(x)
        })
    })
    describe('DvP starting. Phase 3: SPV signs his/her request and bind both requests into a fullRequest ',() =>{

        let date,argDate,PPA_compare;
        let poolName;
        let txid;
        let price;
        let FunctionAndParameters;
        let securitizationCoin;
        let key,genericID;
        let SellRequest;
        let amount
        let BuyRequest;
        let tokenID,typeID, SellRequestID,SellRequestPrice,SellRequestAmount,SellRequestBackedBy,SellRequestOwner

        let OriginatorClientCert,OriginatorClientCertAsBytes,OriginatorClientID;
        let SPVClientID,SPVClientCert,SPVClientCertAsBytes;
        let IssuerClientCert,IssuerClientCertAsBytes;

        let secret="MySecret";
        let TransactionID,NewTransactionID,NewNewTransactionID;
        let Pool

        beforeEach(() => {

            OriginatorClientCert="OriginatorClientCert";
            SPVClientCert="SPVClientCert";

            OriginatorClientID="12345678K";
            SPVClientID="12345678L"


            OriginatorClientCertAsBytes=Buffer.from(OriginatorClientCert).toString('base64');
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');

            IssuerClientCert="IssuerClientCert"
            IssuerClientCertAsBytes=Buffer.from(IssuerClientCert).toString('base64');

            txid="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            genericID="po5f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5bqewqi3"
            typeID=':0'
            key='securitizationCoin'+SPVClientID+genericID;

            date=new Date()
            argDate=date.toUTCString();


            price="9002.34"

            mockStub.getTxID.returns(txid);
            mockClientIdentity.getMSPID.returns('spvMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(SPVClientID);

            TransactionID=crypto.createHash('sha256', secret).update('txid').digest('hex');

            poolName='POOL';
            Pool={
                poolID: poolName+TransactionID,
            };


            NewTransactionID=crypto.createHash('sha256', secret).update('Newtxid').digest('hex');

            BuyRequest={
                ID: 'BuyRequest'+SPVClientID+NewTransactionID,
                Owner: SPVClientID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                Amount: parseInt(amount),
                IsSigned: false,
                Factor:100,
                PoolID: Pool.poolID
            };
            NewNewTransactionID=crypto.createHash('sha256', secret).update('NewNewtxid').digest('hex');
            SellRequest={
                ID: 'SellRequest'+OriginatorClientID+NewNewTransactionID,
                Owner: OriginatorClientID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                IsSigned: false,
                Factor:100,
                BackedBy: Pool.poolID
            };

            mockStub.createCompositeKey.withArgs('POOL',[TransactionID]).returns('POOL'+TransactionID)

            SellRequestOwner=SellRequest.Owner
            SellRequestBackedBy=SellRequest.BackedBy

            securitizationCoin= {
                ID: key+ typeID,
                GenericID: txid,
                TypeID: typeID,
                Issuer: IssuerClientCertAsBytes,
                Owner: SPVClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            mockStub.createCompositeKey.withArgs('SellRequest',[SellRequest.Owner,NewNewTransactionID]).returns('SellRequest'+SellRequest.Owner+NewNewTransactionID)
            mockStub.createCompositeKey.withArgs('BuyRequest',[BuyRequest.Owner,NewTransactionID]).returns('BuyRequest'+BuyRequest.Owner+NewTransactionID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[SPVClientID,genericID]).returns('securitizationCoin'+SPVClientID+genericID);
            mockStub.getTxID.returns(txid);
            poolName='POOL';
            SellRequestPrice=SellRequest.Price.toString();
            FunctionAndParameters={
                fcn: "SignRequestSPV",
                params: [tokenID,typeID,BuyRequest.ID, SellRequest.ID,SellRequestPrice,SellRequestBackedBy,SellRequestOwner]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('should throw an error if user is neither an  Originator nor a SPV member', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestSPV should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestSPV should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a SPV member', async () => {
            let wrong_OrgMSP='originatorMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestSPV should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if any arg is an empty string', async () => {
            FunctionAndParameters.params=['',typeID,BuyRequest.ID, SellRequest.ID,SellRequestPrice,SellRequestBackedBy,SellRequestOwner]
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestSPV should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it('Should throw an error if BuyRequest does not exist', async () =>{
            await contract.beforeTransaction(ctx)
            try{
                await contract.SignRequestSPV(ctx,tokenID,typeID,NewTransactionID, NewNewTransactionID,SellRequestPrice,'POOL',SellRequestBackedBy,SellRequestOwner);
                assert.fail('SignRequestSPV should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Buy request linked to ID ${NewTransactionID} does not exist`)
            }

        });
        it('Should throw an error if BuyRequest has been signed', async () =>{
            BuyRequest.IsSigned=true;
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)))
            await contract.beforeTransaction(ctx)
            try{
                await contract.SignRequestSPV(ctx,genericID,typeID, NewTransactionID, NewNewTransactionID,SellRequestPrice,'POOL',SellRequestBackedBy,SellRequestOwner);
                assert.fail('SignRequestSPV should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Request has been already signed. Not allowed to perform this action`)
            }
        });
        it('Should throw an error if token does not exist', async () =>{
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)))
            await contract.beforeTransaction(ctx)
            try{
                await contract.SignRequestSPV(ctx,genericID,typeID, NewTransactionID, NewNewTransactionID,SellRequestPrice,'POOL',SellRequestBackedBy,SellRequestOwner);
                assert.fail('SignRequestSPV should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Error, Token with ID ${genericID+typeID} does not exist`)
            }
        });
        it('Should throw an error if token cannot be used', async () =>{
            securitizationCoin.CanBeUsed=false;
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)))
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            await contract.beforeTransaction(ctx)
            try{
                await contract.SignRequestSPV(ctx,genericID,typeID, NewTransactionID, NewNewTransactionID,SellRequestPrice,'POOL',SellRequestBackedBy,SellRequestOwner);
                assert.fail('SignRequestSPV should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Your token has been already used`)
            }
        });
        it('Should throw an error if token does not contain enough funds', async () =>{
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)))
            securitizationCoin.Amount=parseInt(parseFloat("30.02")*100)
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            await contract.beforeTransaction(ctx)
            try{
                await contract.SignRequestSPV(ctx,genericID,typeID,NewTransactionID, NewNewTransactionID,SellRequestPrice,'POOL',SellRequestBackedBy,SellRequestOwner);
                assert.fail('SignRequestSPV should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Your token has not enough funds. Try to pool your token or ask for mint`)
            }
        });
        it('Should throw an error if SellRequest has been removed',async () =>{
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)))
            securitizationCoin.Amount=parseInt(parseFloat("10000.02")*100)
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            await contract.beforeTransaction(ctx)
            try{
                await contract.SignRequestSPV(ctx,genericID,typeID,NewTransactionID, NewNewTransactionID,SellRequestPrice,'POOL',SellRequestBackedBy,SellRequestOwner);
                assert.fail('SignRequestSPV should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Sell Request does not exist or have been removed`)
            }
        })
        it('Should throw an error if any sell request arg does not match those of world state',async () =>{
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)));
            let changePrice=parseInt(parseFloat(price)*100)-400;
            SellRequest.Price=changePrice
            mockStub.putState(SellRequest.ID,Buffer.from(JSON.stringify(SellRequest)));
            securitizationCoin.Amount=parseInt(parseFloat("10000.02")*100)
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            SellRequest.Price=changePrice+400
            SellRequestPrice=SellRequest.Price.toString()
            await contract.beforeTransaction(ctx)
            try{
                await contract.SignRequestSPV(ctx,genericID,typeID,NewTransactionID, NewNewTransactionID,SellRequestPrice,'POOL',SellRequestBackedBy,SellRequestOwner);
                assert.fail('SignRequestSPV should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal('Sell Request has been modified')
            }
        });
        it('Should return full request ID',async () =>{
            mockStub.putState(BuyRequest.ID,Buffer.from(JSON.stringify(BuyRequest)));
            mockStub.putState(SellRequest.ID,Buffer.from(JSON.stringify(SellRequest)));
            securitizationCoin.Amount=parseInt(parseFloat("10000.02")*100)
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            let n_value={
                ID: 'Request'+txid,
                BuyRequest,
                SellRequest,
                TokenID: securitizationCoin.ID
            }
            SellRequestPrice=SellRequest.Price.toString();
            mockStub.createCompositeKey.withArgs('Request',[txid]).returns('Request'+txid);
            await contract.beforeTransaction(ctx)
            let ret=await contract.SignRequestSPV(ctx,genericID,typeID,NewTransactionID, NewNewTransactionID,price,'POOL',TransactionID,SellRequestOwner);
            expect(ret).to.eql('Request'+txid)
        });
    })
    describe('QueryFullRequest works as expected', () =>{
        let FullRequest1, FullRequest2;
        let new_genericID,txid1,txid2,token1OwnerID,token2OwnerID,price,amount,buyRequest1,buyRequest2
        let pool1OwnerID,pool2OwnerID,pool1ID,pool2ID
        let sellRequest1,sellRequest2;
        let TokenID1,TokenID2;
        let FunctionAndParameters;
        let TransactionID,NewTransactionID;

        let secret="MySecret";
        // let pool1ID,pool2ID
        beforeEach(() => {
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            txid1="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            txid2="qwd21sfsdfasd34df6a32d00975602eb853e23a86a156781588deqwe90123nhd";

            token1OwnerID='12345678A';
            token2OwnerID='12345678B'
            price="1249.12"
            amount='100'

            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            txid1="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            txid2="qwd21sfsdfasd34df6a32d00975602eb853e23a86a156781588deqwe90123nhd";

            pool1OwnerID='12345678C';
            pool2OwnerID='12345678D'
            pool1ID='POOL'+pool1OwnerID+txid1
            price="1249.12"
            pool1ID='POOL'+pool1OwnerID+txid1
            pool2ID='POOL'+pool2OwnerID+txid2

            buyRequest1={
                ID: 'BuyRequest'+token1OwnerID+txid2,
                Owner: token1OwnerID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                Amount: parseInt(amount),
                IsSigned: true,
                Factor:100,
                PoolID: pool1ID
            };
            buyRequest2={
                ID: 'BuyRequest'+token2OwnerID+txid1,
                Owner: token2OwnerID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                Amount: parseInt(amount),
                IsSigned: true,
                Factor:100,
                PoolID: pool2ID
            };

            sellRequest1={
                ID: 'SellRequest'+pool1OwnerID+new_genericID,
                Owner: pool1OwnerID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                IsSigned: false,
                Factor:100,
                BackedBy: pool1ID
            };
            pool2ID='POOL'+pool2OwnerID+txid2
            sellRequest2={
                ID: 'SellRequest'+pool2OwnerID+new_genericID,
                Owner: pool2OwnerID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                IsSigned: false,
                Factor:100,
                BackedBy: pool2ID
            };
            TransactionID=crypto.createHash('sha256', secret).update('newtxid').digest('hex');
            NewTransactionID=crypto.createHash('sha256', secret).update('newnewtxid').digest('hex');
            TokenID1='securitizationCoin'+buyRequest1.Owner+new_genericID+':0'
            FullRequest1={
                ID: 'Request'+TransactionID,
                buyRequest1,
                sellRequest1,
                TokenID1
            }
            TokenID2='securitizationCoin'+buyRequest2.Owner+new_genericID+':0'
            FullRequest2={
                ID: 'Request'+NewTransactionID,
                buyRequest2,
                sellRequest2,
                TokenID2
            }

            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns('12345678A');

            // poolName='POOL';
            FunctionAndParameters={
                fcn: "QueryFullRequest",
                params: []
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('should throw an error if user is neither an  Originator nor a SPV member', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryFullRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryFullRequest should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not an Originator member', async () => {
            let wrong_OrgMSP='spvMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('QueryFullRequest should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it('should return 2 FullRequests', async () =>{
            mockStub.putState(FullRequest1.ID,Buffer.from(JSON.stringify(FullRequest1)));
            mockStub.putState(FullRequest2.ID,Buffer.from(JSON.stringify(FullRequest2)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.QueryFullRequest(ctx);
            expect(ret).to.eql([FullRequest1,FullRequest2])
        });
        it('should return 1 FullRequest', async () =>{
            mockStub.putState(FullRequest1.ID,Buffer.from(JSON.stringify(FullRequest1)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.QueryFullRequest(ctx);
            expect(ret).to.eql([FullRequest1]);
        });
        it('should return 0 FullRequest', async () =>{
            await contract.beforeTransaction(ctx)
            let ret=await contract.QueryFullRequest(ctx);
            expect(ret).to.eql([]);
        });
    })
    describe('_DVP works as expected', () =>{
        let typeID,key1,genericID,balanceTokens,securityID,tokenID,securityKey1;
        let tokensToTransfer;
        let securitizationCoin;
        let Pool;
        let txid1,txid2;
        let poolName;
        // let typeID;
        let amount;
        let poolOwnerID,buyerID;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        beforeEach(() => {
            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            txid1="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            txid2="3sw12wq1238fdf6a32d00975602eb853e23a86a156781588sadkjln2198dnne";
            typeID=':0';
            key1='securitizationCoin'+buyerID+txid1
            poolOwnerID='12345678A';
            buyerID="12345678B"
            amount="1231.76"
            securitizationCoin={
                ID: key1+typeID,
                GenericID: genericID,
                TypeID: typeID,
                Owner: buyerID,
                Issuer: buyerID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };

            ppaID1="PPA12345678Pdqwdqdasd32412o3ijdqpW213214ad"
            ppaID2="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe"
            ppaID3="PPA12345678MSD2E12asd32412o3ijdqpW2gnjhjyt"
            ppaID4="PPA12345678Tdqwdqdasd32412o3ijdqpW2ret4314"
            ppaID5="PPA12345678L12132421421424123sdqwdwqdadQWE"
            ppaID6="PPA12345678Fewqewqe1wqe2143232132321323123"
            ppaID7="PPA12345678Ssda2e3ewqrewrtewrrrq322r324343"
            ppaID8="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID9="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID10="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe" ;
            poolName='POOL';
            Pool={
                poolID: poolName+txid2,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: poolOwnerID,
                LastModificationOn: new Date(2022,1,20),
                CanBeUsed: true
            };

            mockStub.getTxID.returns(genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[securitizationCoin.Owner,genericID]).returns('securitizationCoin'+securitizationCoin.Owner+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[Pool.Owner,genericID]).returns('securitizationCoin'+Pool.Owner+genericID)
            mockStub.createCompositeKey.withArgs('POOL',[genericID]).returns('POOL'+genericID)


            tokensToTransfer=parseInt(parseFloat("123.21")*100);
        })
        it('Should throw an error if token does not exist',async ()=>{
            try{
                await contract._dvp(ctx,securitizationCoin.ID,Pool.poolID,tokensToTransfer);
                assert.fail('_dvp should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error, Token state according to key ${securitizationCoin.ID} does not exist`)
            }
        })
        it('Should throw an error if security state does not exist',async ()=>{
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            try{
                await contract._dvp(ctx,securitizationCoin.ID,Pool.poolID,tokensToTransfer);
                assert.fail('_dvp should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error, Pool state according to key ${Pool.poolID} does not exist`)
            }
        })
        it('Should throw an error if security or token have been already used',async ()=>{
            securitizationCoin.CanBeUsed=false
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            try{
                await contract._dvp(ctx,securitizationCoin.ID,Pool.poolID,tokensToTransfer);
                assert.fail('_dvp should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Token has been already used`)
            }
        })
        it('Should carry out DvP. Case 1: balance>0',async ()=>{
            poolName='POOL'+securitizationCoin.Owner
            Pool={
                poolID: poolName+genericID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: securitizationCoin.Owner,
                LastModificationOn: new Date(2022,1,20),
                CanBeUsed: true
            };

            typeID=':1';
            let securitizationCoin1={
                ID: 'securitizationCoin'+securitizationCoin.Owner+genericID+typeID,
                GenericID: genericID,
                TypeID: typeID,
                Owner: securitizationCoin.Owner,
                Issuer: securitizationCoin.Issuer,
                Amount: securitizationCoin.Amount-tokensToTransfer,
                Factor: 100,
                CanBeUsed: true
            };
            typeID=':0'
            let securitizationCoin2={
                ID: 'securitizationCoin'+Pool.Owner+genericID+typeID,
                GenericID: genericID,
                TypeID: typeID,
                Owner: Pool.Owner,
                Issuer: Pool.Issuer,
                Amount: tokensToTransfer,
                Factor: 100,
                CanBeUsed: true
            };

            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            mockStub.deleteState(securitizationCoin.ID);
            mockStub.deleteState(Pool.poolID);
            mockStub.putState(securitizationCoin1.ID,Buffer.from(JSON.stringify(securitizationCoin1)));
            mockStub.putState(securitizationCoin2.ID,Buffer.from(JSON.stringify(securitizationCoin2)));
            await contract._dvp(ctx,securitizationCoin.ID,Pool.poolID,tokensToTransfer);
        })
        it('Should carry out DvP. Case 2: balance=0',async ()=>{
            typeID=':1';
            let securitizationCoin1={
                ID: 'securitizationCoin'+securitizationCoin.Owner+genericID+typeID,
                GenericID: genericID,
                TypeID: typeID,
                Owner: securitizationCoin.Owner,
                Issuer: securitizationCoin.Issuer,
                Amount: securitizationCoin.Amount-tokensToTransfer,
                Factor: 100,
                CanBeUsed: true
            };
            typeID=':0'
            let securitizationCoin2={
                ID: 'securitizationCoin'+Pool.Owner+genericID+typeID,
                GenericID: genericID,
                TypeID: typeID,
                Owner: Pool.Owner,
                Issuer: Pool.Issuer,
                Amount: tokensToTransfer,
                Factor: 100,
                CanBeUsed: true
            };
            securitizationCoin.Amount=tokensToTransfer
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            mockStub.deleteState(securitizationCoin.ID);
            mockStub.deleteState(Pool.poolID);
            mockStub.putState(securitizationCoin1.ID,Buffer.from(JSON.stringify(securitizationCoin1)));
            mockStub.putState(securitizationCoin2.ID,Buffer.from(JSON.stringify(securitizationCoin2)));
            await contract._dvp(ctx,securitizationCoin.ID,Pool.poolID,tokensToTransfer);
        })
    })
    describe('DvP finishing. Phase 4: Originator signs request and triggers DvP', () =>{
        let date,argDate;
        let new_genericID,genericID;
        let FunctionAndParameters;
        let FullRequest,BuyRequest,SellRequest;
        let txid1,txid2;
        let buyerID,poolOwnerID;
        let price,amount;
        let poolName,poolID,fullRequestID,buyRequestIdentity,buyRequestAmount,buyRequestPrice
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Pool
        beforeEach(() => {
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            txid1="wqe189rhhfqwondf6a3d00975602eb853e23a86a156781588d99ddef9149vfrd";
            txid2="rytnd21bc278fdf6a32d00975602eb853e23a86a156781588d99ddqwe123asdq";
            date=new Date()
            argDate=date.toUTCString();
            buyerID="12345678B"
            poolOwnerID='12345678A';
            amount="10"
            price="112.45"

            poolName='POOL';
            poolID=genericID;
            fullRequestID='Request'+new_genericID;
            BuyRequest={
                ID: 'BuyRequest'+buyerID+txid1,
                Owner: buyerID,
                Receiver: poolOwnerID,
                Price: parseInt(parseFloat(price)*100),
                Amount: parseInt(amount),
                IsSigned: true ,
                Factor:100,
                PoolID: poolName+poolID
            };
            SellRequest={
                ID: 'SellRequest'+poolOwnerID+txid2,
                Owner: poolOwnerID,
                Receiver: '',
                Price: parseInt(parseFloat(price)*100),
                IsSigned: false,
                Factor:100,
                BackedBy: poolName+poolID
            };

            FullRequest={
                ID: 'Request'+new_genericID,
                buyRequest: BuyRequest,
                sellRequest: SellRequest,
                TokenID: 'securitizationCoin'+buyerID+genericID+':0'
            }
            ppaID1="PPA12345678Pdqwdqdasd32412o3ijdqpW213214ad"
            ppaID2="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe"
            ppaID3="PPA12345678MSD2E12asd32412o3ijdqpW2gnjhjyt"
            ppaID4="PPA12345678Tdqwdqdasd32412o3ijdqpW2ret4314"
            ppaID5="PPA12345678L12132421421424123sdqwdwqdadQWE"
            ppaID6="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe"
            ppaID7="PPA12345678Ysda2e3ewqrewrtewrrrq322r324343"
            ppaID8="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe"
            ppaID9="PPA12345678MSD2E12asd32412o3ijdqpW2gnjhjyt"
            ppaID10="PPA12345678Tdqwdqdasd32412o3ijdqpW2ret4314"
            buyRequestIdentity=BuyRequest.Owner;
            buyRequestAmount=BuyRequest.Amount.toString();
            buyRequestPrice=BuyRequest.Price.toString();
            Pool={
                poolID: poolName+poolID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                OwnerID: poolOwnerID,
                LastModificationOn: new Date(2022,1,20),
                CanBeUsed: true
            }

            mockClientIdentity.getMSPID.returns('originatorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(poolOwnerID);

            mockStub.createCompositeKey.withArgs(poolName,[poolID]).returns(poolName+poolID);
            mockStub.createCompositeKey.withArgs('Request',[new_genericID]).returns('Request'+new_genericID);


            FunctionAndParameters={
                fcn: "SignRequestOriginator",
                params: [poolName,poolID,new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('should throw an error if user is neither an  Originator nor a SPV nor a Ratingagency member', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestOriginator should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestOriginator should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if any arg is an empty string', async () => {
            FunctionAndParameters.params=[poolName,'',new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice]
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestOriginator should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it ('should throw an error if user is not an Originator member', async () => {
            let wrong_OrgMSP='spvMSP';
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('SignRequestOriginator should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it('Should throw an error if FullRequest does not exist', async () =>{
            await contract.beforeTransaction(ctx);
            try {
                await contract.SignRequestOriginator(ctx,poolName, poolID,new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice)
                assert.fail('SignRequestOriginator should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Request State does not exist`);
            }
        });
        it('Should throw an error if Pool does not exist', async () =>{
            mockStub.putState(FullRequest.ID,Buffer.from(JSON.stringify(FullRequest)));
            mockStub.getState.withArgs(FullRequest.ID).returns(Buffer.from(JSON.stringify(FullRequest)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.SignRequestOriginator(ctx,poolName,poolID,new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice)
                assert.fail('SignRequestOriginator should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error, Pool State does not exist according to the key provided`);
            }
        });
        it('Should throw an error if User ID and BuyRequest.Receiver does not match', async () =>{
            FullRequest.buyRequest.Receiver='34123546K'
            mockStub.putState(FullRequest.ID,Buffer.from(JSON.stringify(FullRequest)));
            mockStub.getState.withArgs(FullRequest.ID).returns(Buffer.from(JSON.stringify(FullRequest)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.SignRequestOriginator(ctx,poolName,poolID,new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice)
                assert.fail('SignRequestOriginator should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        })
        it('Should throw an error if User ID and poolOwnerID does not match', async () =>{
            Pool.OwnerID='12345678Y';
            mockStub.putState(FullRequest.ID,Buffer.from(JSON.stringify(FullRequest)));
            mockStub.getState.withArgs(FullRequest.ID).returns(Buffer.from(JSON.stringify(FullRequest)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.SignRequestOriginator(ctx,poolName,poolID,new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice)
                assert.fail('SignRequestOriginator should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`User ID ${SellRequest.Owner} does not match Pool Owner`);
            }
        })
        it('Should throw an error if size of Pool and size of Buy Request do not match', async () =>{
            Pool.ppaIDs.push(ppaID2);
            mockStub.putState(FullRequest.ID,Buffer.from(JSON.stringify(FullRequest)));
            mockStub.getState.withArgs(FullRequest.ID).returns(Buffer.from(JSON.stringify(FullRequest)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.SignRequestOriginator(ctx,poolName,poolID,new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice);
                assert.fail('SignRequestOriginator should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Size of Pool and size of Buy Request do not match`);
            }
        })
        it('Should throw an error if any arg of the FULL REQUEST has been modified',async () =>{
            FullRequest.buyRequest.Price="1298"
            mockStub.putState(FullRequest.ID,Buffer.from(JSON.stringify(FullRequest)));
            mockStub.getState.withArgs(FullRequest.ID).returns(Buffer.from(JSON.stringify(FullRequest)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            try {
                await contract.SignRequestOriginator(ctx,poolName,poolID,new_genericID,buyRequestIdentity,buyRequestAmount,buyRequestPrice)
                assert.fail('SignRequestOriginator should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Some args of Full Request have been modified`);
            }
        })
        it('Return success: Originator now owns tokens and spv is the owner of POOL', async () =>{
            mockStub.putState(FullRequest.ID,Buffer.from(JSON.stringify(FullRequest)));
            mockStub.getState.withArgs(FullRequest.ID).returns(Buffer.from(JSON.stringify(FullRequest)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            sinon.stub(contract, '_dvp').returns();
            await contract.beforeTransaction(ctx);
            await contract.SignRequestOriginator(ctx,poolName,poolID,new_genericID,buyRequestIdentity,amount,price)
        });
    })
    describe('Rating Agency mints Rating', () =>{
        let poolName;
        let FunctionAndParameters;
        let poolID;
        let genericID,new_genericID,txid;
        let Pool;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let Rating;
        let spvID
        beforeEach(() => {

            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h"
            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            txid="qwd21sfsdfasd34df6a32d00975602eb853e23a86a156781588deqwe90123nhd"

            poolName='POOL';
            poolID=poolName+genericID
            spvID='12345678A'

            mockStub.getTxID.returns(txid);
            mockStub.createCompositeKey.withArgs('Rating',[poolID]).returns('Rating'+poolID);


            mockClientIdentity.getMSPID.returns('ratingagencyMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(spvID);

            ppaID1="PPA12345678Pdqwdqdasd32412o3ijdqpW213214ad";
            ppaID2="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID3="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID4="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID5="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID6="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID7="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID8="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID9="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";
            ppaID10="PPA12345678Kdga3dsafsad412o3ijdqpW2rwerrwe";

            poolName='POOL';
            Pool={
                poolID: 'POOL'+poolID,
                PoolName: 'POOL',
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                Owner: spvID,
                LastModificationOn: new Date(2022,1,20)
            }
            Rating={
                ID: 'Rating'+poolID,
                AssetsID: poolID,
                PoolName: "POOL",
                Owner: spvID,
                RatingArgs: "BBB"
            }
            // poolID='asd'
            FunctionAndParameters={
                fcn: "Rating",
                params: [poolID,"BBB"]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
        });
        it('should throw an error if user is neither an  Originator nor a SPV nor a RatingAgency member ', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('Rating should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('Should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('Rating should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a Ratingagency member', async () => {
            let wrong_OrgMSP='spvMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('Rating should throw an Error');
            } catch(err) {

                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if any arg is an empty string', async () => {
            FunctionAndParameters.params=[poolID,'']
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('Rating should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it('Should throw an error if Pool does not exist', async () => {
            mockStub.createCompositeKey.withArgs('POOL',[poolID]).returns('POOL'+poolID)
            await contract.beforeTransaction(ctx);
            try{
                await contract.Rating(ctx,'POOL',poolID,"BBB");
                assert.fail('Rating should throw an Error');
            }catch (err){
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Pool does not exist, not possible to attach a rating`);
            }
        });
        it('Should return rating', async () => {
            mockStub.createCompositeKey.withArgs('POOL',[poolID]).returns('POOL'+poolID)
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)))
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)))
            await contract.beforeTransaction(ctx);
            let ret=await contract.Rating(ctx,'POOL',poolID,"BBB");
            expect(ret).to.eql(Rating)
        });
    })
    describe('Bond Issuance by SPV', () =>{
        let date,argDate;
        let poolName;
        let txid,genericID,new_genericID;
        let FunctionAndParameters;
        let Rating;
        let ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10;
        let spvID,poolID,Pool;
        let TransactionID,NewTransactionID;
        let SPVClientCert,SPVClientCertAsBytes,SPVClientID;
        let RatingClientCert,RatingClientID,RatingClientCertAsBytes;
        let secret="MySecret";

        let TransactionID1,TransactionID2,TransactionID3,TransactionID4,TransactionID5,TransactionID6,TransactionID7,TransactionID8,TransactionID9,TransactionID10;
        let Irrigator1ClientID,Irrigator2ClientID,Irrigator3ClientID,Irrigator4ClientID,Irrigator5ClientID,Irrigator6ClientID,Irrigator7ClientID,Irrigator8ClientID,Irrigator9ClientID,Irrigator10ClientID;
        let payOutFactor
        let bondID,typeID;
        beforeEach(() => {
            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            // txid="qwd21sfsdfasd34df6a32d00975602eb853e23a86a156781588deqwe90123nhd"




            SPVClientID="12345678A"
            RatingClientID="12345678B"

            SPVClientCert="SPVClientCert";
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64')
            RatingClientCert="RatingClientCert";
            RatingClientCertAsBytes=Buffer.from(RatingClientCert).toString('base64')

            date=new Date()
            argDate=date.toUTCString();

            txid=crypto.createHash('sha256', secret).update('txid').digest('hex');

            mockStub.getTxID.returns(txid);

            mockStub.createCompositeKey.withArgs('BondToken',[SPVClientID,txid]).returns('BondToken'+SPVClientID+txid );

            bondID='BondToken'+SPVClientID+txid

            mockClientIdentity.getMSPID.returns('spvMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(SPVClientID);

            mockClientIdentity.getIDBytes.returns(SPVClientCertAsBytes);


            genericID=crypto.createHash('sha256', secret).update('genericID').digest('hex');


            poolName='POOL';
            poolID=poolName+genericID


            Irrigator1ClientID="12345678A";
            Irrigator2ClientID="12345678B";
            Irrigator3ClientID="12345678C";
            Irrigator4ClientID="12345678D";
            Irrigator5ClientID="12345678E";
            Irrigator6ClientID="12345678F";
            Irrigator7ClientID="12345678G";
            Irrigator8ClientID="12345678H";
            Irrigator9ClientID="12345678I";
            Irrigator10ClientID="12345678J";

            TransactionID1=crypto.createHash('sha256', secret).update('TransactionID1').digest('hex');
            TransactionID2=crypto.createHash('sha256', secret).update('TransactionID2').digest('hex');
            TransactionID3=crypto.createHash('sha256', secret).update('TransactionID3').digest('hex');
            TransactionID4=crypto.createHash('sha256', secret).update('TransactionID4').digest('hex');
            TransactionID5=crypto.createHash('sha256', secret).update('TransactionID5').digest('hex');
            TransactionID6=crypto.createHash('sha256', secret).update('TransactionID6').digest('hex');
            TransactionID7=crypto.createHash('sha256', secret).update('TransactionID7').digest('hex');
            TransactionID8=crypto.createHash('sha256', secret).update('TransactionID8').digest('hex');
            TransactionID9=crypto.createHash('sha256', secret).update('TransactionID9').digest('hex');
            TransactionID10=crypto.createHash('sha256', secret).update('TransactionID10').digest('hex');


            ppaID1="PPA"+Irrigator1ClientID+TransactionID1;
            ppaID2="PPA"+Irrigator2ClientID+TransactionID2;
            ppaID3="PPA"+Irrigator3ClientID+TransactionID3;
            ppaID4="PPA"+Irrigator4ClientID+TransactionID4;
            ppaID5="PPA"+Irrigator5ClientID+TransactionID5;
            ppaID6="PPA"+Irrigator6ClientID+TransactionID6;
            ppaID7="PPA"+Irrigator7ClientID+TransactionID7;
            ppaID8="PPA"+Irrigator8ClientID+TransactionID8;
            ppaID9="PPA"+Irrigator9ClientID+TransactionID9;
            ppaID10="PPA"+Irrigator10ClientID+TransactionID10;


            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');

            poolName='POOL';
            poolID=poolName+TransactionID;
            Pool={
                poolID: poolID,
                ppaIDs: [ppaID1,ppaID2,ppaID3,ppaID4,ppaID5,ppaID6,ppaID7,ppaID8,ppaID9,ppaID10],
                OwnerID: SPVClientID,
                LastModificationOn: new Date(2022,1,20)
            }
            Rating={
                ID: 'Rating'+TransactionID,
                AssetsID: TransactionID,
                PoolName: 'POOL',
                Owner: SPVClientID,
                RatingArgs: "BBB"
            }

            let payOutFactor="0.2";

            mockStub.createCompositeKey.withArgs('Rating',[TransactionID]).returns('Rating'+TransactionID);
            
            mockStub.createCompositeKey.withArgs('POOL',[TransactionID]).returns('POOL'+TransactionID);
            
            FunctionAndParameters={
                fcn: "IssueBond",
                params: [Pool.poolID,payOutFactor]
            };
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            mockStub.createCompositeKey.withArgs('BondToken',[spvID,txid]).returns('BondToken'+spvID+txid);
        });
        it('should throw an error if user is neither an Originator nor a SPV nor a Ratingagency member', async () =>{
            let wrong_OrgMSP='farmerMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('IssueBond should throw an Error');
            } catch(err) {
                //
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it ('should throw an error if user is not a client', async () => {
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('IssueBond should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`);
            }
        });
        it ('should throw an error if any arg is an empty string', async () => {
            FunctionAndParameters.params=['',payOutFactor]
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('IssueBond should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it ('should throw an error if user is not a SPV member', async () => {
            let wrong_OrgMSP='originatorMSP'
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try {
                await contract.beforeTransaction(ctx);
                assert.fail('IssueBond should throw an Error');
            } catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`);
            }
        });
        it('Should throw an error if Rating has not been delivered', async () =>{
            await contract.beforeTransaction(ctx);
            try{
                await contract.IssueBond(ctx,Pool.poolID,payOutFactor);
                assert.fail('IssueBond should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Rating still not delivered`);
            }
        });
        it('Should throw an error if Pool State has been modified after rating or it does not exist', async () =>{
            mockStub.putState(Rating.ID,Buffer.from(JSON.stringify(Rating)));
            mockStub.getState.withArgs(Rating.ID).returns(Buffer.from(JSON.stringify(Rating)));
            await contract.beforeTransaction(ctx);
            try{
                await contract.IssueBond(ctx,TransactionID,payOutFactor);
                assert.fail('IssueBond should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Error, Pool State does not match Pool ID provided`)
            }
        });
        it('Should throw an error if Bonds Issuer and Pool Owner do not match', async () =>{
            mockStub.putState(Rating.ID,Buffer.from(JSON.stringify(Rating)));
            mockStub.getState.withArgs(Rating.ID).returns(Buffer.from(JSON.stringify(Rating)));
            let wrong_poolOwnerID="12345678J"
            Pool.OwnerID=wrong_poolOwnerID;
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            try{
                await contract.IssueBond(ctx,TransactionID,payOutFactor);
                assert.fail('IssueBond should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`User ID ${SPVClientID} does not own Pool`);
            }
        });
        it('Should return bondToken according to rating', async () =>{
            let thisDate=new Date(2022,4,24)
            let argThisDate=thisDate.toUTCString()
            mockStub.getDateTimestamp.returns(argThisDate);

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate

            if(initMonth<11){
                initMonth=initMonth+1
                initDate=1
                maturityDate=new Date(initYear+15,initMonth,initDate);
            }else{
                initMonth=0
                initDate=1
                maturityDate=new Date(initYear+16,initMonth,initDate);
            }
            let nextYear=initYear
            let nextMonth=initMonth;
            let monthDiff;

            for (let l=0; l<totalCoupons;l++){
                if(initMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=initMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=initMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,initDate);
            }


            let monthlyPayout=couponRate*faceValue;
            typeID=":0"
            bondID=bondID+typeID;
            const bondToken={
                ID: bondID,
                GenericID: txid,
                TypeID: typeID,
                Rating: Rating.RatingArgs,
                CouponRate: couponRate,
                MaturityDate: maturityDate,
                Issuer: SPVClientCertAsBytes,
                Owner: SPVClientID,
                Pool: Rating.AssetsID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 1000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            mockStub.putState(Rating.ID,Buffer.from(JSON.stringify(Rating)));
            mockStub.getState.withArgs(Rating.ID).returns(Buffer.from(JSON.stringify(Rating)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.IssueBond(ctx,TransactionID,payOutFactor);
            expect(ret).to.eql(bondToken)
        });
        it('Should return bondToken according to rating. New issuance date', async () =>{
            let thisDate=new Date(2022,8,24)
            let argThisDate=thisDate.toUTCString()
            mockStub.getDateTimestamp.returns(argThisDate);

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate

            if(initMonth<11){
                initMonth=initMonth+1
                initDate=1
                maturityDate=new Date(initYear+15,initMonth,initDate);
            }else{
                initMonth=0
                initDate=1
                maturityDate=new Date(initYear+16,initMonth,initDate);
            }
            let nextYear=initYear
            let nextMonth=initMonth;
            let monthDiff;

            for (let l=0; l<totalCoupons;l++){
                if(initMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=initMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=initMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,initDate);
            }


            let monthlyPayout=couponRate*faceValue;
            typeID=":0"
            bondID=bondID+typeID;
            const bondToken={
                ID: bondID,
                GenericID: txid,
                TypeID: typeID,
                Rating: Rating.RatingArgs,
                CouponRate: couponRate,
                MaturityDate: maturityDate,
                Issuer: SPVClientCertAsBytes,
                Owner: SPVClientID,
                Pool: Rating.AssetsID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 1000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            mockStub.putState(Rating.ID,Buffer.from(JSON.stringify(Rating)));
            mockStub.getState.withArgs(Rating.ID).returns(Buffer.from(JSON.stringify(Rating)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            await contract.beforeTransaction(ctx);
            let ret=await contract.IssueBond(ctx,TransactionID,payOutFactor);
            expect(ret).to.eql(bondToken)
        });
        it('Should return bondToken according to rating. New issuance date', async () =>{
            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()
            mockStub.getDateTimestamp.returns(argThisDate);

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate);
            }


            let monthlyPayout=couponRate*faceValue;
            typeID=":0"
            bondID=bondID+typeID;
            const bondToken={
                ID: bondID,
                GenericID: txid,
                TypeID: typeID,
                Rating: Rating.RatingArgs,
                CouponRate: couponRate,
                MaturityDate: maturityDate,
                Issuer: SPVClientCertAsBytes,
                Owner: SPVClientID,
                Pool: Rating.AssetsID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 1000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            mockStub.putState(Rating.ID,Buffer.from(JSON.stringify(Rating)));
            mockStub.getState.withArgs(Rating.ID).returns(Buffer.from(JSON.stringify(Rating)));
            mockStub.putState(Pool.poolID,Buffer.from(JSON.stringify(Pool)));
            mockStub.getState.withArgs(Pool.poolID).returns(Buffer.from(JSON.stringify(Pool)));
            //console.log(couponDates)
            await contract.beforeTransaction(ctx);
            let ret=await contract.IssueBond(ctx,TransactionID,payOutFactor);
            expect(ret).to.eql(bondToken)
        });

    })
    describe('TESTING: createContext works as expected', () =>{
        it('Should return new Context', async ()=>{
            let newContext=new SecuritizationContract.securitizationContext()
            let ret =await contract.createContext();
            expect(ret).to.eql(newContext);
        });
    })
});


describe('Securitization (common functions) Test', () => {
    let ctx;
    let sandbox,mockClientIdentity,mockStub;
    let contract;
    beforeEach(() => {
        sandbox = sinon.createSandbox();
        contract= new SecuritizationContract.commonSecuritizationContract();
        ctx = new SecuritizationContract.securitizationContext();

        mockStub=sinon.createStubInstance(ChaincodeStub);
        ctx.stub= mockStub;
        mockClientIdentity=sinon.createStubInstance(ClientIdentity);
        ctx.clientIdentity=mockClientIdentity;



        mockStub.getState.callsFake(async (key) => {
            let ret;
            if (mockStub.states) {
                ret = mockStub.states[key];
            }
            return Promise.resolve(ret);
        });

        mockStub.deleteState.callsFake(async (key) => {
            if (mockStub.states) {
                delete mockStub.states[key];
            }
            return Promise.resolve(key);
        });

        mockStub.putState.callsFake((key, value) => {
            if (!mockStub.states) {
                mockStub.states = {};
            }
            mockStub.states[key] = value;
        });

        mockStub.getStateByPartialCompositeKey.callsFake(async () => {
            function* internalGetStateByPartialCompositeKey() {
                if (mockStub.states) {
                    // Shallow copy
                    const copied = Object.assign({}, mockStub.states);
                    for (let key in copied) {
                        yield {value: copied[key]};
                    }
                }
            }
            return Promise.resolve(internalGetStateByPartialCompositeKey());
        });
    });

    afterEach('Sandbox restoration', () => {
        sandbox.restore();
    });
    describe('Testing: QueryMyBond()', () =>
    {
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let typeID;
        let secret="MySecret";
        let BondToken,NewBondToken


        beforeEach(() => {
            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            thisDate=new Date(argThisDate);
            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate

            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;

            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
                // couponDates[l]=couponDates[l]
            }

            //console.log('couponDates')
            //console.log(couponDates)

            let monthlyPayout=couponRate*faceValue;
            let TransactionID=crypto.createHash('sha256', secret).update('bondToken').digest('hex');
            let bondID='BondToken'+OwnerClientID+TransactionID;
            let NewTransactionID=crypto.createHash('sha256', secret).update('pool').digest('hex');

            typeID=":0"

            bondID=bondID+typeID;

            BondToken={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            //console.log(BondToken.CouponDates)

            let NewNewTransactionID=crypto.createHash('sha256', secret).update('NewNewtxid').digest('hex');
            typeID=':1'
            bondID="BondToken"+OwnerClientID+NewNewTransactionID+typeID;

            NewBondToken={
                ID: bondID,
                GenericID: NewNewTransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };


            mockClientIdentity.getMSPID.returns('investorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);

        })
        it('Should return an empty array if user does not own bonds', async () =>{
            let ret=await contract.QueryMyBond(ctx);
            expect(ret).to.eql([]);
        });
        it('else Should return an array of 1 bond', async () =>{
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            let ret=await contract.QueryMyBond(ctx);
            expect(ret).to.eql([BondToken]);
        });
        it('else Should return an array of 2 bonds', async () =>{
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.putState(NewBondToken.ID,Buffer.from(JSON.stringify(NewBondToken)));
            let ret=await contract.QueryMyBond(ctx);
            expect(ret[0]).to.eql(BondToken);
            expect(ret[1]).to.eql(NewBondToken);
            // expect(ret[2]).to.eql(undefined);
        });
    });
    describe('Testing: QueryMyCoins()', () =>
    {
        let date,argDate;
        let txid;
        let genericID,new_genericID;
        let ownerID;
        let typeID;
        let tokenID, new_tokenID;
        let amount;

        let securitizationCoin,new_securitizationCoin;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

        let IssuerClientCert,IssuerClientCertAsBytes,IssuerClientID;

        beforeEach(() => {
            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            IssuerClientID="12345678G"
            IssuerClientCert="IssuerClientCert";
            IssuerClientCertAsBytes=Buffer.from(IssuerClientCert).toString('base64');

            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";

            date=new Date()
            argDate=date.toUTCString();

            typeID=':0'
            tokenID="securitizationCoin"+OwnerClientID+genericID;
            amount="190.45"
            new_tokenID="securitizationCoin"+OwnerClientID+new_genericID;

            securitizationCoin={
                ID: tokenID+ typeID,
                GenericID: genericID,
                TypeID: typeID,
                Issuer: IssuerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            new_securitizationCoin={
                ID: new_tokenID+ typeID,
                GenericID: new_genericID,
                TypeID: typeID,
                Issuer: IssuerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            }

            mockClientIdentity.getMSPID.returns('investorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
        })
            it('Should return an empty array if user does not own coins', async () =>{
                let ret=await contract.QueryMyCoins(ctx);
                expect(ret).to.eql([]);
            });
            it('else Should return an array of 1 token', async () =>{
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                let ret=await contract.QueryMyCoins(ctx);
                expect(ret[0]).to.eql(securitizationCoin);
            });
            it('else Should return an array of 2 tokens', async () =>{
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
                let ret=await contract.QueryMyCoins(ctx);
                expect(ret[0]).to.eql(securitizationCoin);
                expect(ret[1]).to.eql(new_securitizationCoin);
                expect(ret[2]).to.eql(undefined)
            });

    });
    describe('Testing: auxiliary Function _checkDecimals', () =>
    {
        let rightAmount, wrongAmount_1, wrongAmount_2, wrongAmount_3,wrongAmount_4;
        beforeEach(() => {
            rightAmount="875.35";
            wrongAmount_1="875,35";
            wrongAmount_2="875.350000"
            wrongAmount_3="-875.35"
            wrongAmount_4="-0.00"
        })
        it('Should throw an error if user uses wrong format, i.e. "124,87" ', async () =>{
            try{
                await contract._checkDecimals(wrongAmount_1)
                assert.fail('_checkDecimals should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Wrong format. Try using dot instead of comma`)
            }
        });
        it('Should throw an error if user uses wrong format i.e. "124.12412412" ', async () =>{
            try{
                await contract._checkDecimals(wrongAmount_2)
                assert.fail('_checkDecimals should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Wrong decimals`);
            }
        });
        it('Should throw an error if amount<=0 ', async () =>{
            try{
                await contract._checkDecimals(wrongAmount_3);
                assert.fail('_checkDecimals should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Number must be strictly positive`);
            }
        });
        it('Should throw an error if amount<=0 ', async () =>{
            try{
                await contract._checkDecimals(wrongAmount_4);
                assert.fail('_checkDecimals should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Number must be strictly positive`);
            }
        });
        it('returns true', async () =>{
            let ret=await contract._checkDecimals(rightAmount)
            expect(ret).to.eql(true);
        });
    });
    describe('Testing: Mint()', () =>
    {
        let date,argDate;
        let txid;
        let genericID,new_genericID;
        let ownerID;
        let typeID;
        let tokenID, new_tokenID;
        let amount;
        let FunctionAndParameters;

        let securitizationCoin,new_securitizationCoin;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let IssuerClientCert,IssuerClientCertAsBytes,IssuerClientID;

        beforeEach(() => {
            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64')
            IssuerClientID="12345678B";
            IssuerClientCert="IssuerClientCert";
            IssuerClientCertAsBytes=Buffer.from(IssuerClientCert).toString('base64');

            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";

            date=new Date()
            argDate=date.toUTCString();
            typeID=':0'
            tokenID="securitizationCoin"+OwnerClientID+genericID;
            amount="190.45"

            securitizationCoin={
                ID: tokenID+ typeID,
                GenericID: genericID,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            FunctionAndParameters={
                fcn: 'Mint',
                params: [amount]
            }

            mockClientIdentity.getMSPID.returns('investorMSP');
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID);
        })
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('Mint should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty string', async () =>{
            FunctionAndParameters.params=[''];
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('Mint should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is at least one empty parameter`);
            }
        });
        it('Should throw an error if amount<=0 ', async () =>{
            FunctionAndParameters.params=['0.00'];
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            await contract.beforeTransaction(ctx);
            try{
                await contract.Mint(ctx,'0.00')
                assert.fail('Mint should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Number must be strictly positive`);
            }
        });
        it('return token', async () =>{
            await contract.beforeTransaction(ctx);
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
            let ret=await contract.Mint(ctx,amount)
            expect(ret).to.eql(securitizationCoin)
        });
    });
    describe('Testing: auxiliary Function _mygetStateByPartialCompositeKey', () =>
    {
        let PPA;
        let new_PPA;
        let OwnerClientID;
        let genericID, new_genericID;
        beforeEach(() => {
            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            OwnerClientID="12345678A"
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+OwnerClientID+genericID,
                CustomerID: OwnerClientID,
            }
            new_PPA={
                docType: 'PPA',
                ppaID: 'PPA'+OwnerClientID+new_genericID,
                CustomerID: OwnerClientID,
            }
        })
        it('Should throw an error if there are more than one state linked to that partial key', async () =>{
            mockStub.putState(PPA.ppaID,Buffer.from(JSON.stringify(PPA)));
            mockStub.putState(new_PPA.ppaID,Buffer.from(JSON.stringify(new_PPA)));
            try{
                await contract._mygetStateByPartialCompositeKey(ctx,PPA.docType,PPA.CustomerID)
                assert.fail('_mygetStateByPartialCompositeKey should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Check this...`)
            }
        });
        it('Should return true if there is no State', async () =>{
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,PPA.docType,PPA.CustomerID);
            expect(ret).to.eql(true)
        });
        it('Return State', async () =>{
            mockStub.putState(PPA.ppaID,Buffer.from(JSON.stringify(PPA)));
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,PPA.docType,PPA.CustomerID);
            expect(ret).to.eql(PPA);
        });

    })
    //PoolMoney is restricted to pool just 2 cash token states.
    describe('Testing: PoolMoney', () =>
    {
        let customerID;
        let genericID1,genericID2, new_genericID;
        let securitizationCoin1,securitizationCoin2,new_securitizationCoin;
        let tokenID1,tokenID2,new_tokenID;
        let FunctionAndParameters;
        let typeID,amount;
        let OwnerClientID, OwnerClientCert,OwnerClientCertAsBytes;
        beforeEach(() => {
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            OwnerClientID="12345678A"
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            typeID=':0'
            amount="190.45"
            new_tokenID="securitizationCoin"+OwnerClientID+new_genericID;

            genericID1="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            genericID2="lkp09kopk278fdf6a32d0097560asdqwee23a86a156781588d99ddef512387gs"
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";

            typeID=':0'
            tokenID1="securitizationCoin"+OwnerClientID+genericID1;
            tokenID2='securitizationCoin'+OwnerClientID+genericID2;
            amount="190.45"
            new_tokenID="securitizationCoin"+OwnerClientID+new_genericID;

            securitizationCoin1={
                ID: tokenID1+ typeID,
                GenericID: genericID1,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            securitizationCoin2={
                ID: tokenID2+ typeID,
                GenericID: genericID2,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            new_securitizationCoin={
                ID: new_tokenID+ typeID,
                GenericID: new_genericID,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: securitizationCoin1.Amount+securitizationCoin2.Amount,
                Factor: 100,
                CanBeUsed: true
            }
            FunctionAndParameters={
                fcn: 'PoolMoney',
                params: []
            }
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID)
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID]).returns('securitizationCoin'+OwnerClientID);
        })
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try{
                await contract.beforeTransaction(ctx)
                assert.fail('PoolMoney should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if there are no States linked to userID', async () =>{
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolMoney(ctx);
                assert.fail('PoolMoney should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('Should throw an error if you only owns one token and canbeused===true', async () =>{
            mockStub.putState(securitizationCoin1.ID,Buffer.from(JSON.stringify(securitizationCoin1)));
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolMoney(ctx);
                assert.fail('PoolMoney should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('Should throw an error if you only owns one token and canbeused===false', async () =>{
            securitizationCoin1.CanBeUsed=false;
            mockStub.putState(securitizationCoin1.ID,Buffer.from(JSON.stringify(securitizationCoin1)));
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolMoney(ctx);
                assert.fail('PoolMoney should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('Should throw an error if you owns two tokens and  one of them has Canbeused===false', async () =>{
            mockStub.putState(securitizationCoin1.ID,Buffer.from(JSON.stringify(securitizationCoin1)));
            securitizationCoin2.CanBeUsed=false;
            mockStub.putState(securitizationCoin2.ID,Buffer.from(JSON.stringify(securitizationCoin2)));
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolMoney(ctx);
                assert.fail('PoolMoney should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('returns new token', async () =>{
            mockStub.putState(securitizationCoin1.ID,Buffer.from(JSON.stringify(securitizationCoin1)));
            mockStub.putState(securitizationCoin2.ID,Buffer.from(JSON.stringify(securitizationCoin2)))
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)))
            sinon.stub(contract, '_transferMoney').returns(new_securitizationCoin);
            await contract.beforeTransaction(ctx);
            let ret=await contract.PoolMoney(ctx);
            expect(ret).to.eql(new_securitizationCoin)
        });
    })
    describe('Testing: auxiliary function _transferMoney works as expected', () =>
    {
        let securitizationCoin1,securitizationCoin2,new_securitizationCoin;
        let genericID1,genericID2,new_genericID;
        let tokenID1, tokenID2,new_tokenID;
        let typeID,amount;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        beforeEach(() => {
            genericID1="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            genericID2="lkp09kopk278fdf6a32d0097560asdqwee23a86a156781588d99ddef512387gs"
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            OwnerClientID="12345678A"
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            typeID=':0'
            tokenID1="securitizationCoin"+OwnerClientID+genericID1;
            tokenID2='securitizationCoin'+OwnerClientID+genericID2;
            amount="190.45"
            new_tokenID="securitizationCoin"+OwnerClientID+new_genericID;

            securitizationCoin1={
                ID: tokenID1+ typeID,
                GenericID: genericID1,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            securitizationCoin2={
                ID: tokenID2+ typeID,
                GenericID: genericID2,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(parseFloat(amount)*100),
                Factor: 100,
                CanBeUsed: true
            };
            new_securitizationCoin={
                ID: new_tokenID+ typeID,
                GenericID: new_genericID,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: securitizationCoin1.Amount+securitizationCoin2.Amount,
                Factor: 100,
                CanBeUsed: true
            }

            mockStub.getTxID.returns(new_genericID);
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,new_genericID]).returns('securitizationCoin'+OwnerClientID+new_genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);


            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID)
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
        })
        it('Should return new token', async () =>{
            mockStub.deleteState(securitizationCoin1.ID);
            mockStub.deleteState(securitizationCoin2.ID);
            let ret= await contract._transferMoney(ctx,OwnerClientID,securitizationCoin1.Amount+securitizationCoin2.Amount,[securitizationCoin1.ID,securitizationCoin2.ID])
            expect(ret).to.eql(new_securitizationCoin);
        });

    })
    describe('TESTING: createContext works as expected', () =>{
        it('Should return new Context', async ()=>{
            let newContext=new SecuritizationContract.securitizationContext()
            let ret =await contract.createContext();
            expect(ret).to.eql(newContext);
        });
    })
    describe('TESTING: QueryPPA works as expected', () =>{
        let ppa1,txid1;
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let ppaID

        beforeEach(() => {

            txid1="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f"
            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');
            ppaID='PPA'+OwnerClientID+txid1
            ppa1={
                docType: 'PPA',
                ppaID: ppaID,
                Customer: OwnerClientCertAsBytes,
                CustomerID: OwnerClientID,
            };

        })
        it('Should return PPA object if exists', async ()=>{
            mockStub.putState(ppa1.ppaID,Buffer.from(JSON.stringify(ppa1)));
            sinon.stub(contract, '_mygetStateByPartialCompositeKey').returns(ppa1)
            let ret =await contract.QueryPPA(ctx,ppa1.CustomerID)
            expect(ret).to.eql(ppa1);
        });
        it('Should throw an error if it does not exist', async ()=>{
            sinon.stub(contract,'_mygetStateByPartialCompositeKey').returns(true)
            try{
                await contract.QueryPPA(ctx,ppa1.CustomerID);
                assert.fail('QueryPPA should throw an Error')
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`PPA does not exist`)
            }
        });

    })


})


describe('Securitization (secondary Market Functions) Test', ()=>{

    let ctx;
    let sandbox,mockClientIdentity,mockStub;
    let contract;
    beforeEach(() => {
        sandbox = sinon.createSandbox();
        contract= new SecuritizationContract.servicingContract();
        ctx = new SecuritizationContract.securitizationContext();

        mockStub=sinon.createStubInstance(ChaincodeStub);
        ctx.stub= mockStub;
        mockClientIdentity=sinon.createStubInstance(ClientIdentity);
        ctx.clientIdentity=mockClientIdentity;



        mockStub.getState.callsFake(async (key) => {
            let ret;
            if (mockStub.states) {
                ret = mockStub.states[key];
            }
            return Promise.resolve(ret);
        });

        mockStub.deleteState.callsFake(async (key) => {
            if (mockStub.states) {
                delete mockStub.states[key];
            }
            return Promise.resolve(key);
        });

        mockStub.putState.callsFake((key, value) => {
            if (!mockStub.states) {
                mockStub.states = {};
            }
            mockStub.states[key] = value;
        });

        mockStub.getStateByPartialCompositeKey.callsFake(async () => {
            function* internalGetStateByPartialCompositeKey() {
                if (mockStub.states) {
                    // Shallow copy
                    const copied = Object.assign({}, mockStub.states);
                    for (let key in copied) {
                        yield {value: copied[key]};
                    }
                }
            }
            return Promise.resolve(internalGetStateByPartialCompositeKey());
        });

    });
    afterEach('Sandbox restoration', () => {
        sandbox.restore();
    });

    describe('TESTING: createContext works as expected', () =>{
        it('Should return new Context', async ()=>{
            let newContext=new SecuritizationContract.securitizationContext()
            let ret =await contract.createContext();
            expect(ret).to.eql(newContext);
        });
    })
    describe('Testing: auxiliary Function _mygetStateByPartialCompositeKey', () =>
    {
        let PPA;
        let new_PPA;
        let genericID, new_genericID;
        let OwnerClientID
        beforeEach(() => {
            genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";
            OwnerClientID="12345678A";
            PPA={
                docType: 'PPA',
                ppaID: 'PPA'+OwnerClientID+genericID,
                CustomerID: OwnerClientID,
            }
            new_PPA={
                docType: 'PPA',
                ppaID: 'PPA'+OwnerClientID+new_genericID,
                CustomerID: OwnerClientID,
            }
        })
        it('Should throw an error if there are more than one state linked to that partial key', async () =>{
            mockStub.putState(PPA.ppaID,Buffer.from(JSON.stringify(PPA)));
            mockStub.putState(new_PPA.ppaID,Buffer.from(JSON.stringify(new_PPA)));
            try{
                await contract._mygetStateByPartialCompositeKey(ctx,PPA.docType,PPA.CustomerID)
                assert.fail('_mygetStateByPartialCompositeKey should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Partial Key Uniqueness not provided. Something went wrong`)
            }
        });
        it('Should return true if there is no State', async () =>{
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,PPA.docType,PPA.CustomerID);
            expect(ret).to.eql(true)
        });
        it('Return State', async () =>{
            mockStub.putState(PPA.ppaID,Buffer.from(JSON.stringify(PPA)));
            let ret=await contract._mygetStateByPartialCompositeKey(ctx,PPA.docType,PPA.CustomerID);
            expect(ret).to.eql(PPA);
        });
    })
    describe('Testing: PoolBond', () =>
    {
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let FunctionAndParameters;
        let typeID,amount;
        let BondToken1,BondToken2,new_BondToken;
        let TransactionID,NewTransactionID;
        let secret="MySecret";
        beforeEach(() => {
            OwnerClientID="12345678A"
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            thisDate=new Date(argThisDate);
            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate

            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;

            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }

            let monthlyPayout=couponRate*faceValue;
            TransactionID=crypto.createHash('sha256', secret).update('bondToken').digest('hex');
            let bondID='BondToken'+OwnerClientID+TransactionID;
            NewTransactionID=crypto.createHash('sha256', secret).update('Pool').digest('hex');

            typeID=":0"

            bondID=bondID+typeID;

            BondToken1={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 1000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            TransactionID=crypto.createHash('sha256', secret).update('AnotherBondToken').digest('hex');
            bondID='BondToken'+OwnerClientID+TransactionID;

            BondToken2={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 9000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            }

            TransactionID=crypto.createHash('sha256', secret).update('NewBondToken').digest('hex');
            bondID='BondToken'+OwnerClientID+TransactionID;
            new_BondToken={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: BondToken1.Amount+BondToken2.Amount,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            }
            FunctionAndParameters={
                fcn: 'PoolBond',
                params: []
            }
            mockClientIdentity.getID.returns(OwnerClientCert);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID)
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
        })
        it('Should throw an error if user is not a client', async () =>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try{
                await contract.beforeTransaction(ctx)
                assert.fail('PoolBond should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is neither an Investor nor a SPV member', async () =>{
            let wrong_OrgMSP='ratingagencyMSP';
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx)
                assert.fail('PoolBond should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        });
        it('Should throw an error if there are no States linked to userID', async () =>{
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolBond(ctx);
                assert.fail('PoolBond should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('Should throw an error if you only owns one BondToken and canbeused===true', async () =>{
            mockStub.putState(BondToken1.ID,Buffer.from(JSON.stringify(BondToken1)));
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolBond(ctx);
                assert.fail('PoolBond should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('Should throw an error if you only owns one BondToken and canbeused===false', async () =>{
            BondToken1.CanBeUsed=false;
            mockStub.putState(BondToken1.ID,Buffer.from(JSON.stringify(BondToken1)));
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolBond(ctx);
                assert.fail('PoolBond should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('Should throw an error if you owns two BondTokens and  one of them has Canbeused===false', async () =>{
            mockStub.putState(BondToken1.ID,Buffer.from(JSON.stringify(BondToken1)));
            BondToken2.CanBeUsed=false;
            mockStub.putState(BondToken2.ID,Buffer.from(JSON.stringify(BondToken2)));
            await contract.beforeTransaction(ctx)
            try{
                await contract.PoolBond(ctx);
                assert.fail('PoolBond should throw an Error')
            }catch(err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is nothing left to do`)
            }
        });
        it('returns new BondToken', async () =>{
            mockStub.putState(BondToken1.ID,Buffer.from(JSON.stringify(BondToken1)));
            mockStub.putState(BondToken2.ID,Buffer.from(JSON.stringify(BondToken2)));

            mockStub.putState(new_BondToken.ID,Buffer.from(JSON.stringify(new_BondToken)));
            sinon.stub(contract, '_transferBond').returns(new_BondToken);
            await contract.beforeTransaction(ctx);
            let ret=await contract.PoolBond(ctx);
            expect(ret).to.eql(new_BondToken)
        });
    })
    describe('Testing: auxiliary function _transferBonds works as expected', () =>
    {
        let BondToken1,BondToken2,new_BondToken;
        let typeID,amount;
        let TransactionID,NewTransactionID;
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let secret="MySecret";
        beforeEach(() => {
            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            thisDate=new Date(argThisDate);
            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate

            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;

            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }

            let monthlyPayout=couponRate*faceValue;
            TransactionID=crypto.createHash('sha256', secret).update('bondToken').digest('hex');
            let bondID='BondToken'+OwnerClientID+TransactionID;
            NewTransactionID=crypto.createHash('sha256', secret).update('Pool').digest('hex');

            typeID=":0"

            bondID=bondID+typeID;

            BondToken1={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 1000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            TransactionID=crypto.createHash('sha256', secret).update('AnotherBondToken').digest('hex');
            bondID='BondToken'+OwnerClientID+TransactionID;

            BondToken2={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 9000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            }

            TransactionID=crypto.createHash('sha256', secret).update('NewBondToken').digest('hex');
            bondID='BondToken'+OwnerClientID+TransactionID+typeID;
            new_BondToken={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: BondToken1.Amount+BondToken2.Amount,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            }

            mockStub.getTxID.returns(TransactionID);
            mockStub.createCompositeKey.withArgs('BondToken',[BondToken1.Owner,BondToken1.GenericID]).returns('BondToken'+BondToken1.Owner+BondToken1.GenericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);

            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID)
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
        })
        it('Should return new token', async () =>{
            mockStub.deleteState(BondToken1.ID);
            mockStub.deleteState(BondToken2.ID);
            mockStub.createCompositeKey.withArgs('BondToken',[new_BondToken.Owner,new_BondToken.GenericID]).returns('BondToken'+new_BondToken.Owner+new_BondToken.GenericID);
            mockStub.getState.withArgs(BondToken1.ID).returns(Buffer.from(JSON.stringify(BondToken1)));
            let ret= await contract._transferBond(ctx,OwnerClientID,BondToken1.Amount+BondToken2.Amount,[BondToken1.ID,BondToken2.ID]);
            expect(ret).to.eql(new_BondToken);
        });

    })
    describe('Testing: auxiliary function _splitMoney works as expected', () =>
    {

        let securitizationCoin1,securitizationCoin2,new_securitizationCoin;
        let tokenID,new_tokenID;
        let typeID,amount;
        let notEnoughAmount;
        let IdealPrice, IdealQuantity;
        let idealPrice,idealQuantity;
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

        let secret="MySecret";
        let TransactionID,NewTransactionID;

        beforeEach(() => {
            OwnerClientID="12345678A"
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64')

            TransactionID=crypto.createHash('sha256', secret).update('cashToken').digest('hex');
            NewTransactionID=crypto.createHash('sha256', secret).update('NewCashToken').digest('hex');

            typeID=':0'
            tokenID="securitizationCoin"+OwnerClientID+TransactionID;
            amount="190.45"
            new_tokenID="securitizationCoin"+OwnerClientID+NewTransactionID;
            idealQuantity="25";
            idealPrice="100.00"
            amount="100000"
            IdealQuantity=25;
            IdealPrice=10000;


            securitizationCoin1={
                ID: tokenID+ typeID,
                GenericID: TransactionID,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: IdealPrice*IdealQuantity,
                Factor: 100,
                CanBeUsed: false
            };

            typeID=':0'
            new_securitizationCoin={
                ID: new_tokenID+ typeID,
                GenericID: NewTransactionID,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: parseInt(idealQuantity)*parseInt(parseFloat(idealPrice)*100)+parseInt(amount),
                Factor: 100,
                CanBeUsed: true
            }

            typeID=':1'
            securitizationCoin2={
                ID: tokenID+ typeID,
                GenericID: TransactionID,
                TypeID: typeID,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: new_securitizationCoin.Amount-(IdealPrice*IdealQuantity),
                Factor: 100,
                CanBeUsed: true
            };

            mockStub.getTxID.returns(TransactionID);
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,TransactionID]).returns('securitizationCoin'+OwnerClientID+TransactionID);
            mockClientIdentity.getID.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID)
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
        })
        it('Should throw an error if token does not exist', async () =>{
            try{
                await contract._splitMoney(ctx,new_securitizationCoin.ID,amount);
                assert.fail('_splitMoney should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error, Token state according to key ${new_securitizationCoin.ID} does not exist`)
            }
        });
        it('Should throw an error if token cannot be used', async ()=>{
            new_securitizationCoin.CanBeUsed=false;
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            try{
                await contract._splitMoney(ctx,new_securitizationCoin.ID,amount);
                assert.fail('_splitMoney should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This token ID ${new_securitizationCoin.ID} has already been used. Try another Token ID`)
            }
        });
        it('Should throw an error if token does not have enough funds',async ()=>{
            notEnoughAmount="1000.04";
            new_securitizationCoin.Amount=parseInt(parseFloat(notEnoughAmount)*100);
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            try{
                await contract._splitMoney(ctx,new_securitizationCoin.ID,IdealPrice*IdealQuantity);
                assert.fail('_splitMoney should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error, token State has not enough funds`)
            }
        })
        it('Should successfully split securitizationCoin. Case 1: balance>0',async ()=>{
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            mockStub.putState(securitizationCoin1.ID,Buffer.from(JSON.stringify(securitizationCoin1)));
            mockStub.putState(securitizationCoin2.ID,Buffer.from(JSON.stringify(securitizationCoin2)));
            mockStub.deleteState(new_securitizationCoin.ID);
            let ret=await contract._splitMoney(ctx,new_securitizationCoin.ID,IdealPrice*IdealQuantity);
            expect(ret).to.eql(securitizationCoin1.ID)
        })
        it('Should successfully split securitizationCoin. Case 2: balance=0',async ()=>{
            new_securitizationCoin.Amount=parseInt(idealQuantity)*parseInt(parseFloat(idealPrice)*100);
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            let ret=await contract._splitMoney(ctx,new_securitizationCoin.ID,IdealPrice*IdealQuantity);
            expect(ret).to.eql(securitizationCoin1.ID);
        })
    });
    describe('Testing: auxiliary function _splitBond works as expected', () =>
    {
        let BondToken1,BondToken2,new_BondToken;
        let typeID,amount;
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let secret="MySecret";

        let TransactionID,NewTransactionID,NewNewTransactionID;

        let IdealQuantity;
        let notEnoughAmount;
        beforeEach(() => {
            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');
            IdealQuantity=100

            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            thisDate=new Date(argThisDate);
            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate

            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;

            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }

            let monthlyPayout=couponRate*faceValue;
            TransactionID=crypto.createHash('sha256', secret).update('bondToken').digest('hex');
            let bondID='BondToken'+OwnerClientID+TransactionID;

            typeID=":0"

            bondID=bondID+typeID;

            BondToken1={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 1000,
                CanBeUsed: false,
                NotBefore: couponDates[0]
            };

            // TransactionID=crypto.createHash('sha256', secret).update('AnotherBondToken').digest('hex');
            typeID=":1"
            bondID='BondToken'+OwnerClientID+TransactionID+typeID;

            NewNewTransactionID=crypto.createHash('sha256', secret).update('Pool').digest('hex');

            BondToken2={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewNewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 9000,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            }

            NewTransactionID=crypto.createHash('sha256', secret).update('NewBondToken').digest('hex');
            bondID='BondToken'+OwnerClientID+NewTransactionID+typeID;
            new_BondToken={
                ID: bondID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+NewTransactionID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: BondToken1.Amount+BondToken2.Amount,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            }


            mockStub.getTxID.returns(TransactionID);
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,TransactionID]).returns('BondToken'+OwnerClientID+TransactionID);
            mockClientIdentity.getID.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true)
        })
        it('Should throw an error if bond token does not exist', async () =>{
            try{
                await contract._splitBonds(ctx,new_BondToken.ID,IdealQuantity);
                assert.fail('_splitBonds should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Error, Bond State according to key ${new_BondToken.ID} does not exist`)
            }
        });
        it('Should throw an error if bond token cannot be used', async ()=>{
            new_BondToken.CanBeUsed=false;
            mockStub.getState.withArgs(new_BondToken.ID).returns(Buffer.from(JSON.stringify(new_BondToken)))
            try{
                await contract._splitBonds(ctx,new_BondToken.ID,IdealQuantity);
                assert.fail('_splitBonds should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This Bond State with ID ${new_BondToken.ID} has already been used in a prior order`)
            }
        });
        it('Should throw an error if Bond token does not have enough funds',async ()=>{
            notEnoughAmount="5"
            new_BondToken.Amount=parseInt(notEnoughAmount);
            mockStub.getState.withArgs(new_BondToken.ID).returns(Buffer.from(JSON.stringify(new_BondToken)))
            try{
                await contract._splitBonds(ctx,new_BondToken.ID,IdealQuantity);
                assert.fail('_splitBond should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`This Bond State has not enough bonds to transfer`)
            }
        })
        it('Should successfully split BondToken. Case 1: balance>0',async ()=>{
            mockStub.getState.withArgs(new_BondToken.ID).returns(Buffer.from(JSON.stringify(new_BondToken)))
            mockStub.putState(BondToken1.ID,Buffer.from(JSON.stringify(BondToken1)));
            mockStub.putState(BondToken2.ID,Buffer.from(JSON.stringify(BondToken2)))
            mockStub.deleteState(new_BondToken.ID);
            amount=new_BondToken.Amount-5000
            let ret=await contract._splitBonds(ctx,new_BondToken.ID,amount.toString());
            expect(ret).to.eql(BondToken1.ID)
        })
        it('Should successfully split securitizationCoin. Case 2: balance=0',async ()=>{

            mockStub.getState.withArgs(new_BondToken.ID).returns(Buffer.from(JSON.stringify(new_BondToken)));
            mockStub.putState(BondToken1.ID,Buffer.from(JSON.stringify(BondToken1)));
            mockStub.deleteState(new_BondToken.ID);
            let ret=await contract._splitBonds(ctx,new_BondToken.ID,new_BondToken.Amount.toString());
            expect(ret).to.eql(BondToken1.ID)
        })
    })
    describe('Testing: TransferCoupons works as expected', () =>
    {   // In order to commit this transaction, we must own a bond token, we must know the spv ID
        // and we must be on a date later that CouponDatesNotBefore
        const secret = 'mySecret';
        let ownerCert,spvCert;
        let BondToken,new_BondToken;
        let genericID,new_genericID;
        let tokenID,new_tokenID;
        let typeID,amount;
        let thisDate,genericDate;
        let firstCouponDate;
        let irrigatorCert;
        let FunctionAndParameters;
        let couponDates;
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

        let SPVClientID,SPVClientCert,SPVClientCertAsBytes;
        let IrrigatorClientID,IrrigatorClientCert,IrrigatorClientCertAsBytes;
        let TransactionID,NewTransactionID;
        let PoolID
        let availableDate;
        let monthlyPayout;

        beforeEach(() => {
            // genericID="fa0f757bc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b80720f";
            // new_genericID="asdqwebc278fdf6a32d00975602eb853e23a86a156781588d99ddef5b58795h";

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');
            SPVClientID="12345678L";
            SPVClientCert="SPVClientCert";
            SPVClientCertAsBytes=Buffer.from(SPVClientCert).toString('base64');

            IrrigatorClientID="12345678B"
            IrrigatorClientCert="IrrigatorClientCert"
            IrrigatorClientCertAsBytes=Buffer.from(IrrigatorClientCert).toString('base64');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');

            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";
            NewTransactionID=crypto.createHash('sha256', secret).update('NewTransactionID').digest('hex');
            new_tokenID="BondToken"+OwnerClientID+NewTransactionID+typeID;

            // biannual coupon
            // lets start on date  1/1/2023
            // year, month, day
            // coupon dates, same function as such of IssueBonds


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');


            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };


            new_BondToken={
                ID: new_tokenID,
                GenericID: NewTransactionID,
                TypeID: typeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: BondToken.Issuer,
                Owner: BondToken.Owner,
                FaceValue: BondToken.FaceValue,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                RemainingPayments: BondToken.RemainingPayments-1,
                Amount: BondToken.Amount,
                CanBeUsed: BondToken.CanBeUsed,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived+1,
                NotBefore: couponDates[1]
            };

            availableDate=new Date(couponDates[0]).getTime()

            let rightOrg="investorMSP"
            mockClientIdentity.getMSPID.returns(rightOrg);
            mockStub.getTxID.returns(NewTransactionID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            FunctionAndParameters={
                fcn:"TransferCoupons",
                params:[BondToken.GenericID,BondToken.TypeID,SPVClientID]
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);

            // we must create a bunch of cash tokens owned by SPV
            // These cash tokens were transfered by an irrigator client, who, via smart contract
            // has allocated one cash token to coupon payout and another to principal coupon payout
            // lets simulate how much must each irrigator pay based on a normal distribution
            // and we will also create unique random IDs for each cash token transfered by an irrigator
            // client
        })
        it('Should throw an error if user is not a client', async ()=>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('TransferCoupons should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty ',async ()=>{
            FunctionAndParameters.params=[BondToken.ID,'',SPVClientID]
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('TransferCoupons should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter that should not be`)
            }
        })
        it('Should through an error if user is not an investor nor an SPV client',async ()=>{
            let wrong_OrgMSP='ratingagencyMSP';
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('TransferCoupons should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        })
        it('Should throw an error if Bond Token does not exist',async ()=>{
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            await contract.beforeTransaction(ctx);
            try{
                await contract.TransferCoupons(ctx,BondToken.GenericID,BondToken.TypeID,SPVClientID);
                assert.fail('TransferCoupons should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is no state associated to that key`)
            }
        })
        it('Should throw an error if currentDate<BondToken.NotBefore',async ()=>{
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            let newDate=new Date(availableDate-10000);
            let argNewDate=newDate.toUTCString();
            mockStub.getDateTimestamp.returns(argNewDate);
            await contract.beforeTransaction(ctx);
            try{
                await contract.TransferCoupons(ctx,BondToken.GenericID,BondToken.TypeID,SPVClientID);
                assert.fail('AskOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Error, you cannot still withdraw any coupons`)
            }
        })
        it('Should throw an error if Bond Token cannot be used (i.e. it is locked within order book)',async ()=>{
            BondToken.CanBeUsed=false;
            mockStub.putState.withArgs(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));

            let newDate=new Date(availableDate+1);
            let argNewDate=newDate.toUTCString();
            mockStub.getDateTimestamp.returns(argNewDate);

            await contract.beforeTransaction(ctx);
            try{
                await contract.TransferCoupons(ctx,BondToken.GenericID,BondToken.TypeID,spvCert);
                assert.fail('TransferCoupons should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Bond token cannot be used`)
            }
        })
        it('Should throw an error if there are not enough cash token values to pay that amount of coupons)',async ()=>{
            let energyConsumption
            let ID
            let GenericID;
            let TypeID;
            let Issuer;
            let Owner;
            let Amount;
            let Factor;
            let CanBeUsed;
            let UnitPrice=0.24;
            let securitizationCoinArray=[];
            let securitizationCoinBuffer;
            BondToken.CanBeUsed=true
            mockStub.putState.withArgs(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            // mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));


            let newDate=new Date(availableDate+1);
            let argNewDate=newDate.toUTCString();
            mockStub.getDateTimestamp.returns(argNewDate);


            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            let acumulator=0;
            for (let i=0;i<10;i++){
                energyConsumption=randomBetween(150,200);

                let securitizationCoin={

                };
                // ID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex')
                GenericID=crypto.createHash('sha256', secret).update(i.toString()+SPVClientID).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+SPVClientID+GenericID+TypeID
                Issuer=IrrigatorClientCertAsBytes;
                Owner=SPVClientID;
                Amount=parseInt((UnitPrice*energyConsumption*100).toFixed(2));
                Factor=100;
                CanBeUsed=true;
                //////console.log(Amount)
                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= GenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));
                acumulator+=Amount
            }

            await contract.beforeTransaction(ctx);
            try{
                await contract.TransferCoupons(ctx,BondToken.GenericID,BondToken.TypeID,SPVClientID);
                assert.fail('TransferCoupons should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There are not enough funds`)
            }
        })
        it('Should return bondToken "updated", i.e, burnt and created again. Case 1 : balance>0',async ()=>{
            let energyConsumption
            let ID
            let GenericID;
            let TypeID;
            let Issuer;
            let Owner;
            let Amount;
            let Factor;
            let CanBeUsed;
            let UnitPrice=0.24;
            let securitizationCoinArray=[];
            let securitizationCoinBuffer;

            BondToken.CanBeUsed=true
            mockStub.putState.withArgs(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));


            let newDate=new Date(availableDate+1);
            let argNewDate=newDate.toUTCString();
            mockStub.getDateTimestamp.returns(argNewDate);


            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // 600=6(months)*100(irrigators)
            let total=0;
            for (let i=0;i<600;i++){
                energyConsumption=randomBetween(150,200);

                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()+SPVClientID).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+SPVClientID+GenericID+TypeID
                Issuer=IrrigatorClientCertAsBytes;
                Owner=SPVClientID;
                Amount=parseInt((UnitPrice*energyConsumption*100).toFixed(2));
                total+=Amount;
                Factor=100;
                CanBeUsed=true;
                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= GenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
            }
            typeID=":1"
            mockStub.createCompositeKey.withArgs('securitizationCoin',[SPVClientID,NewTransactionID]).returns('securitizationCoin'+SPVClientID+NewTransactionID);
            typeID=":0"
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,NewTransactionID]).returns('securitizationCoin'+OwnerClientID+NewTransactionID);
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,NewTransactionID]).returns('BondToken'+OwnerClientID+NewTransactionID);
            await contract.beforeTransaction(ctx);

            let ret=await contract.TransferCoupons(ctx,BondToken.GenericID,BondToken.TypeID,SPVClientID);
            expect(ret).to.eql(new_BondToken);
        })
        it('Should return bondToken "updated", i.e, burnt and created again. Case 2 : balance=0',async ()=>{
            let energyConsumption
            let ID
            let GenericID;
            let TypeID;
            let Issuer;
            let Owner;
            let Amount;
            let Factor;
            let CanBeUsed;
            let UnitPrice=0.24;
            let securitizationCoinArray=[];
            let securitizationCoinBuffer;

            BondToken.CanBeUsed=true
            mockStub.putState.withArgs(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));


            let newDate=new Date(availableDate+1);
            let argNewDate=newDate.toUTCString();
            mockStub.getDateTimestamp.returns(argNewDate);



            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // 600=6(months)*100(irrigators)
            let cashTokensToTransfer=parseInt(BondToken.Amount*monthlyPayout*100)
            let total=0;
            for (let i=0;i<600;i++){
                energyConsumption=randomBetween(150,200);

                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()+SPVClientID).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+SPVClientID+GenericID+TypeID
                Issuer=IrrigatorClientCertAsBytes;
                Owner=SPVClientID;
                Amount=parseInt((UnitPrice*energyConsumption*100).toFixed(2));
                total+=Amount;
                Factor=100;
                CanBeUsed=true;
                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= GenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensToTransfer=cashTokensToTransfer-Amount;
                if (cashTokensToTransfer<0){
                    securitizationCoin.Amount=Amount+cashTokensToTransfer
                    securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                    mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                    break
                }
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
            }
            typeID=":1"
            mockStub.createCompositeKey.withArgs('securitizationCoin',[SPVClientID,NewTransactionID]).returns('securitizationCoin'+SPVClientID+NewTransactionID);
            typeID=":0"
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,NewTransactionID]).returns('securitizationCoin'+OwnerClientID+NewTransactionID);

            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,NewTransactionID]).returns('BondToken'+OwnerClientID+NewTransactionID);


            await contract.beforeTransaction(ctx);
            let ret=await contract.TransferCoupons(ctx,BondToken.GenericID,BondToken.TypeID,SPVClientID);
            expect(ret).to.eql(new_BondToken);
        })
        it('Should return bondToken "updated", i.e, burnt and created again. Case 3 : balance=0 && There are non-usable cash tokens',async ()=>{
            let energyConsumption
            let ID
            let GenericID;
            let TypeID;
            let Issuer;
            let Owner;
            let Amount;
            let Factor;
            let CanBeUsed;
            let UnitPrice=0.24;
            let securitizationCoinArray=[];
            let securitizationCoinBuffer;

            BondToken.CanBeUsed=true
            mockStub.putState.withArgs(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));


            let newDate=new Date(availableDate+1);
            let argNewDate=newDate.toUTCString();
            mockStub.getDateTimestamp.returns(argNewDate);



            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // 600=6(months)*100(irrigators)
            let cashTokensToTransfer=parseInt(BondToken.Amount*monthlyPayout*100)
            let total=0;
            for (let i=0;i<600;i++){
                energyConsumption=randomBetween(150,200);

                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()+SPVClientID).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+SPVClientID+GenericID+TypeID
                Issuer=IrrigatorClientCertAsBytes;
                Owner=SPVClientID;
                Amount=parseInt((UnitPrice*energyConsumption*100).toFixed(2));
                total+=Amount;
                Factor=100;
                CanBeUsed= (energyConsumption>175) ? true:false;
                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= GenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensToTransfer=cashTokensToTransfer-Amount;
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
            }
            typeID=":1"
            mockStub.createCompositeKey.withArgs('securitizationCoin',[SPVClientID,NewTransactionID]).returns('securitizationCoin'+SPVClientID+NewTransactionID);
            typeID=":0"
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,NewTransactionID]).returns('securitizationCoin'+OwnerClientID+NewTransactionID);

            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,NewTransactionID]).returns('BondToken'+OwnerClientID+NewTransactionID);


            await contract.beforeTransaction(ctx);
            let ret=await contract.TransferCoupons(ctx,BondToken.GenericID,BondToken.TypeID,SPVClientID);
            expect(ret).to.eql(new_BondToken);
        })
    })
    describe('TESTING: _sortingAskOrder works as expected (fake Mock). This should be checked by hand', () =>{
        const secret = 'MySecret';

        let ID;
        let Quantity;
        let Price;
        let TokenID;
        let FullMatch;
        let PartialMatch;
        let MarketPrice;
        let QuantityMatch;
        let RestingQuantity;
        let Name='Ask';
        let Time;


        function randomBetween(min,max){
            return Math.random()*(max-min)+min
        }

        let todayDate=new Date()

        let orderArray=[];
        async function sortingAskOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }
        beforeEach(() => {
        })

        it('First ask ordering attemp. Different Price but equal Time, FullMatch=false and MarketPrice=false', async ()=>{
            for (let i=0;i<10;i++){
                let AskOrder={

                };
                ID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex')
                TokenID='BondToken'+'userID'+crypto.createHash('sha256', secret).update(i.toString()+'userID').digest('hex')
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=Price;
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name

                orderArray.push(AskOrder)
            }

            let ret=await contract._sortingAskOrders(ctx,orderArray)
            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)
            //console.log(AskOrderArray_Ordered)
            // //console.log in order to check the performance of sorting
            expect(ret).to.eql(AskOrderArray_Ordered)
        })
        it('Second.1 ask ordering attemp. Different Time but equal Price, FullMatch=false and MarketPrice=false', async ()=>{
            orderArray=[]
            for (let i=0;i<10;i++){
                let comp=Math.random()
                let AskOrder={

                };
                ID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex')
                TokenID='BondToken'+'userID'+crypto.createHash('sha256', secret).update(i.toString()+'userID').digest('hex')
                Quantity=Math.floor(randomBetween(1,100))
                Price=109.23;
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=(comp>0.5) ? todayDate.getTime()+(Quantity*100) :todayDate.getTime()-(Quantity*100)

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=Price;
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name

                orderArray.push(AskOrder)
            }
            let ret=await contract._sortingAskOrders(ctx,orderArray)
            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)
            //console.log(AskOrderArray_Ordered)
            expect(ret).to.eql(AskOrderArray_Ordered)
        })
        it('Third ask ordering attemp. 2 possible changing parameters mixed', async ()=>{
            orderArray=[]
            for (let i=0;i<10;i++){
                let comp=Math.random()
                let AskOrder={

                };
                ID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex')
                TokenID='BondToken'+'userID'+crypto.createHash('sha256', secret).update(i.toString()+'userID').digest('hex')
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                PartialMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=(comp>0.5) ? todayDate.getTime()+(Quantity*100) :todayDate.getTime()-(Quantity*100)
                FullMatch=(comp>0.5) ? true :false
                MarketPrice=(comp>0.5) ? true :false


                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=Price;
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name

                orderArray.push(AskOrder)
            }
            let ret=await contract._sortingAskOrders(ctx,orderArray)
            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)
            //console.log(AskOrderArray_Ordered)
            expect(ret).to.eql(AskOrderArray_Ordered)
        })
    })
    describe('TESTING: _sortingBidOrder works as expected (fake Mock). This should be inspected by hand', () =>{
        // Deffining the secret key
        const secret = "MySecret";

        let ID;
        let Quantity;
        let Price;
        let TokenID;
        let FullMatch;
        let PartialMatch;
        let MarketPrice;
        let QuantityMatch;
        let RestingQuantity;
        let Name='Bid';
        let Time;

        let orderArray=[];

        function randomBetween(min,max){
            return Math.random()*(max-min)+min
        }
        // let comp=Math.random()
        let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? 1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? -1 : 1));
            return orderArray.reverse()
        }

        beforeEach(() => {


        })

        it('First bid ordering attemp. Different Price but equal Time, FullMatch=false and MarketPrice=false', async ()=>{
            orderArray=[]
            for (let i=0;i<1000;i++){
                let BidOrder={

                };
                ID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex')
                TokenID='BondToken'+'userID'+crypto.createHash('sha256', secret).update('Bid'+i.toString()+'userID').digest('hex')
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=parseInt(Quantity);
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name

                orderArray.push(BidOrder)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let ret=await contract._sortingBidOrders(ctx,orderArray)
            //console.log(BidOrderArray_Ordered)
            expect(ret).to.eql(BidOrderArray_Ordered)
        })
        it('Second.1 bid ordering attemp. Different Time but equal Price, FullMatch=false and MarketPrice=false', async ()=>{

            orderArray=[]
            for (let i=0;i<100;i++){
                let comp=Math.random()
                let BidOrder={

                };
                ID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex')
                TokenID='BondToken'+'userID'+crypto.createHash('sha256', secret).update('Bid'+i.toString()+'userID').digest('hex')
                Quantity=Math.floor(randomBetween(1,100))
                Price=110.09
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=(comp>0.5) ? todayDate.getTime()+(Quantity) :todayDate.getTime()-(Quantity)

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=Price;
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name

                orderArray.push(BidOrder)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let ret=await contract._sortingBidOrders(ctx,orderArray)
            //console.log(BidOrderArray_Ordered)
            expect(ret).to.eql(BidOrderArray_Ordered)
        })
        it('Third bid ordering attemp. 2 possible changing parameters mixed', async ()=>{
            orderArray=[]
            for (let i=0;i<100;i++){
                let comp=Math.random()
                let BidOrder={

                };
                ID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex')
                TokenID='BondToken'+'userID'+crypto.createHash('sha256', secret).update('Bid'+i.toString()+'userID').digest('hex')
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                PartialMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=(comp>0.5) ? todayDate.getTime()+(Quantity) :todayDate.getTime()-(Quantity)

                FullMatch=(comp>0.5) ? true :false
                MarketPrice=(comp>0.5) ? true :false

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=Price;
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name

                orderArray.push(BidOrder)
            }
            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let ret=await contract._sortingBidOrders(ctx,orderArray)
            //console.log(BidOrderArray_Ordered)
            expect(ret).to.eql(BidOrderArray_Ordered)
        })
    })
    // One ask has matched multiple bids and those bids must transfer those cash tokens to ask order submitter
    // and split bond to bid submitters matched
    describe('TESTING: _transferCashTokens(ctx,tokenAcumulator,currentOrder,orderBook) works as expected',()=>{
        let orderBook, askInput, bidInputs;
        let genericID,new_genericID,ownerID,date,argDate;
        let typeID,tokenID,amount,new_tokenID,IdealQuantity,price,IdealPrice;
        let orderID, BondToken1,BondToken2,new_BondToken, securitizationCoin, new_securitizationCoin;
        let currentOrder;
        let bondID, identificativo;
        let FunctionAndParameters;
        let OrderBook;
        let newBidOrder
        let monthlyPayout,PoolID, BondToken;
        let secret="MySecret";
        let TransactionID, NewTransactionID;
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let SPVClientID,SPVClientCert,SPVClientCertAsBytes

        let orderArray=[];
        async function sortingAskOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }

        let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? -1 : 1));
            return orderArray.reverse()
        }

        // beforeEach we must create an order Book
        beforeEach(() => {

        })
        it('Should throw an error if bond token does not exist', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let FaceValue,AmountPaid,RemainingPayments;

            let secret;

            let Name;

            let NewGenericID;

            let securitizationCoinBuffer

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            date=new Date()
            argDate=date.toUTCString();

            genericID=crypto.createHash('sha256', secret).update('GenericID').digest('hex');

            orderID="AskOrder"+genericID;

            let orderArray=[];

            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"
                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensArray.push(securitizationCoin)
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let bondTokensArray=[];
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=AmountPaid;
                bondToken.FaceValue=FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.RemainingPayments=RemainingPayments;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=200;
            price=109.05

            currentOrder={
                ID: orderID,
                Quantity: amount,
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: amount,
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]

            let bids=orderBook[0];

            let askReference=currentOrder;
            // "Match Engine" obtained from AskOrder Function
            let counter=askReference.Quantity;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let totalTokens=0;
            let balance=0;
            let myTokens=0;

            for (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    continue
                }
            }

            if (myTokens===askReference.Quantity){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                currentOrder.Quantity=counter;
            }else{
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }

            const InputtokenAcumulator=tokenAcumulator;
            const InputcurrentOrder=currentOrder;

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);

            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            orderBook[1].push(currentOrder);

            try{
                await contract._transferCashTokens(ctx,InputtokenAcumulator,InputcurrentOrder,orderBook);
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal('Bond Token does not exist')
            }
        });
        it('Should throw an error if one securitizationCoin from bids matched is intended to be spent more than once', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;
            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;
            let secret;
            let Name;

            let NewGenericID;

            let securitizationCoinBuffer
            secret='MySecret';
            new_genericID=crypto.createHash('sha256', secret).update("new_genericID").digest('hex');
            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            date=new Date()
            argDate=date.toUTCString();

            orderID="AskOrder"+genericID;


            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };


            let orderArray=[];

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;


                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;

                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;

                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived
                bondToken.NotBefore=BondToken.NotBefore;

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=200;
            price=100.00

            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };

            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]
            let bids=orderBook[0];

            let askReference=currentOrder;
            // "Match Engine" obtained from AskOrder Function
            let counter=askReference.Quantity;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let totalTokens=0;
            let balance=0;
            let myTokens=0;

            for await (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    // //console.log('paso 4.1')
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        // //console.log('paso 4.1.1')
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        // //console.log('paso 4.1.2')
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        bid.Quantity=bid.Quantity-balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    // //console.log('paso 4.2')
                    continue
                }
            }

            // According to what matching situation we are, differents orders will be submitted
            if (counter===0){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(counter!==0 && counter!==askReference.Quantity ){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=askReference.Quantity-counter;
                currentOrder.Quantity=counter;
            }else{
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }
            orderBook[1].push(currentOrder);

            BidOrderArray_Ordered=await sortingBidOrders(orderBook[0]);
            AskOrderArray_Ordered=await sortingAskOrders(orderBook[1])

            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))

            // ID repeated
            tokenAcumulator[1]=tokenAcumulator[0];

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }

            mockStub.putState.withArgs('OrderMatch'+genericID,Buffer.from(JSON.stringify(orderMatch)));
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            try{
                await contract._transferCashTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook);
            }catch(err){
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal('Repeated cash token ID');
            }
        });
        it('Should throw an error if any securitizationCoin from bids does not exist', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;
            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;
            let secret;
            let Name;

            let NewGenericID;

            let securitizationCoinBuffer
            secret='MySecret';
            new_genericID=crypto.createHash('sha256', secret).update("new_genericID").digest('hex');
            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            date=new Date()
            argDate=date.toUTCString();

            orderID="AskOrder"+genericID;


            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };


            let orderArray=[];

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;


                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;

                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;

                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived
                bondToken.NotBefore=BondToken.NotBefore;

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=200;
            price=108.65

            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };

            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]
            let bids=orderBook[0];

            let askReference=currentOrder;
            // "Match Engine" obtained from AskOrder Function
            let counter=askReference.Quantity;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let totalTokens=0;
            let balance=0;
            let myTokens=0;

            for await (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    // //console.log('paso 4.1')
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        // //console.log('paso 4.1.1')
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        // //console.log('paso 4.1.2')
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        bid.Quantity=bid.Quantity-balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    // //console.log('paso 4.2')
                    continue
                }
            }

            // According to what matching situation we are, differents orders will be submitted
            if (counter===0){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(counter!==0 && counter!==askReference.Quantity ){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=askReference.Quantity-counter;
                currentOrder.Quantity=counter;
            }else{
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }
            orderBook[1].push(currentOrder);

            BidOrderArray_Ordered=await sortingBidOrders(orderBook[0]);
            AskOrderArray_Ordered=await sortingAskOrders(orderBook[1])

            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))

            // modify one securitizationCoin ID
            tokenAcumulator[1].TokenID=tokenAcumulator[1].TokenID+'1234'

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }
            mockStub.putState.withArgs('OrderMatch'+genericID,Buffer.from(JSON.stringify(orderMatch)));

            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            try{
                let ret=await contract._transferCashTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook);
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`state ${tokenAcumulator[1].TokenID} does not exist`)
            }
        });
        it('Should return OrderBook. Case 1: cash tokens owned by same identity', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let FaceValue,AmountPaid,RemainingPayments;

            let secret="MySecret";
            let Name;
            let securitizationCoinBuffer;

            let NewGenericID;

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            genericID=crypto.createHash('sha256', secret).update('GenericID').digest('hex');

            orderID="AskOrder"+genericID;

            let orderArray=[];

            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"
                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensArray.push(securitizationCoin)
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let bondTokensArray=[];
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=AmountPaid;
                bondToken.FaceValue=FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.RemainingPayments=RemainingPayments;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=200;
            price=109.05

            // BondToken inside World State
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));

            currentOrder={
                ID: orderID,
                Quantity: amount,
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: amount,
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            let bids=orderBook[0];
            let askReference=currentOrder;

            // "Match Engine" obtained from AskOrder Function
            let counter=askReference.Quantity;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let totalTokens=0;
            let balance=0;
            let myTokens=0;

            for (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    continue
                }
            }

            if (myTokens===askReference.Quantity){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                currentOrder.Quantity=counter;
            }else{
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }
            orderBook=[bids,orderBook[1],orderBook[2]]

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }
            const InputtokenAcumulator=tokenAcumulator;
            const InputcurrentOrder=currentOrder;

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);

            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            orderBook[1].push(currentOrder);


            let ret=await contract._transferCashTokens(ctx,InputtokenAcumulator,InputcurrentOrder,orderBook)


            const orderBookInputVersion=orderBook




            let bondToken=BondToken;
            let myFunds=bondToken.Amount;

            let usedKeys=[];
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let bondTokensToTransfer=[];
            let total=0;
            let bondsToTransfer=[];
            amount=0;
            let token;
            let lastOwner
            let lastBid
            let lastQuantity
            let lastRestingQuantity
            let lastQuantityMatch
            let partialMatched=[]

            let outputTypeID=":0"
            let outputTokenID='BondToken'+OwnerClientID+genericID+outputTypeID

            let outputBondToken={
                ID: outputTokenID,
                GenericID: genericID,
                TypeID: outputTypeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            let asks
            asks=orderBook[1];
            bids=orderBook[0];
            let bidInputs=tokenAcumulator
            let askInput=currentOrder
            let referencePrice=bidInputs[0].Price
            for (let i=0; i<bidInputs.length;i++){
                if(referencePrice>bidInputs[i].Price){
                    referencePrice=bidInputs[i].Price;
                }
                let balance=0;
                let cashTokenID=bidInputs[i].TokenID;
                let quantityToTransfer=bidInputs[i].QuantityMatch;
                if(usedKeys.indexOf(cashTokenID)!==-1){
                    throw new Error('Error2')
                }
                total+=quantityToTransfer*bidInputs[i].Price
                balance=bidInputs[i].Quantity-bidInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer*bidInputs[i].Price
                }else{
                    total+=bidInputs[i].Quantity*bidInputs[i].Price
                }
                amount+=quantityToTransfer*bidInputs[i].Price;

                //TODO
                //check errors

                token=await cashTokensArray.filter(item=> item.ID===cashTokenID)



                let cashTokenOwner=token.Owner;


                if (usedOwners.indexOf(cashTokenOwner)===-1){
                    usedOwners.push(cashTokenOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    cashTokensToTransfer.push(quantityToTransfer*askInput.Price);
                    bondTokensToTransfer.push(quantityToTransfer);
                }else{
                    usedAmounts[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(cashTokenOwner)]+=token.Amount;
                    cashTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer*askInput.Price;
                    bondTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                }
                let index;
                let usedKey
                bids=orderBook[0];
                asks=orderBook[1];
                if (bidInputs[i].FullMatch){
                    let myBid=await bids.filter(item=> item.ID!==bidInputs[i].ID);
                    orderBook=[myBid,asks,[referencePrice]]
                }else{
                    lastOwner=token.Owner
                    let myBid=await bids.filter(item=> item.ID===bidInputs[i].ID);
                    lastBid=myBid[0]
                    lastQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    lastQuantityMatch=0
                    lastRestingQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    usedKey=token.ID
                    await ctx.stub.deleteState(token.ID);
                    orderBook=[myBid,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }

            for (let j=0;j<usedOwners.length;j++){
                outputBondToken.ID=await ctx.stub.createCompositeKey('BondToken',[usedOwners[j],outputBondToken.GenericID]);
                outputBondToken.Amount=bondTokensToTransfer[j];
                outputBondToken.Owner=usedOwners[j];

                if (usedAmounts[j]!==notUsedTokensAmounts[j]){
                    outputBondToken.Amount=bondTokensToTransfer[j]
                    let outputBondTokenBuffer= Buffer.from(JSON.stringify(outputBondToken))
                    mockStub.createCompositeKey.withArgs('BondToken',[usedOwners[j],outputBondToken.GenericID]).returns('BondToken'+usedOwners[j]+outputBondToken.GenericID);
                    mockStub.putState(outputBondTokenBuffer.ID,outputBondTokenBuffer)
                }else{
                    outputBondToken.Amount=bondTokensToTransfer[j];
                    mockStub.createCompositeKey.withArgs('BondToken',[usedOwners[j],outputBondToken.GenericID]).returns('BondToken'+usedOwners[j]+outputBondToken.GenericID);
                    let outputBondTokenBuffer=Buffer.from(JSON.stringify(outputBondToken))
                    mockStub.putState(outputBondToken.ID,outputBondTokenBuffer)
                }
            }

            let securitizationCoin1={
                ID: 'securitizationCoin'+OwnerClientID+genericID+':0',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: total,
                Factor: 100,
                CanBeUsed: true
            }
            // let valueBuffer1=Buffer.from(JSON.stringify(securitizationCoin1))
            let restingQuantity=total-amount;
            if(restingQuantity!==0){
                let securitizationCoin2={
                    ID: 'securitizationCoin'+lastOwner+genericID+':1',
                    GenericID: genericID,
                    TypeID: ':1',
                    Issuer: OwnerClientCertAsBytes,
                    Owner: lastOwner,
                    Amount: restingQuantity,
                    Factor: 100,
                    CanBeUsed: true
                }
                lastBid.TokenID=securitizationCoin2.ID;
                lastBid.QuantityMatch=lastQuantityMatch;
                lastBid.RestingQuantity=lastRestingQuantity;
                lastBid.Quantity=lastQuantity;
                lastBid.PartialMatch=false;
                let thisBid=await bids.filter(item=> item.ID===lastBid.ID)
                let indice=bids.indexOf(thisBid[0])
                bids[indice]=lastBid;
                orderBook=[bids,asks,referencePrice]
            }else{
                orderBook=[bids,asks,referencePrice]
            }

            if ((askInput.Quantity-askInput.QuantityMatch)!==0 && !askInput.MarketPrice){
                outputBondToken.ID='BondToken'+OwnerClientID+genericID+':1';
                outputBondToken.Amount=BondToken.Amount-bondAcumulator;
                let thisAsk=await asks.filter(item => item.ID===askInput.ID);
                let index=asks.indexOf(thisAsk[0]);
                thisAsk[0].Quantity=thisAsk[0].Quantity-thisAsk[0].QuantityMatch;
                thisAsk[0].QuantityMatch=0;
                thisAsk[0].TokenID=outputBondToken.ID;
                asks[index]=thisAsk[0];
                orderBook=[bids,asks,[referencePrice]]
            }else if ((askInput.Quantity-askInput.QuantityMatch)===0 && !askInput.MarketPrice){
                let thisAsk=await asks.filter(item => item.ID!==askInput.ID)
                orderBook=[bids,thisAsk,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-------------------OrderBook Updated--------------------------')
            //console.log(ret)
            //console.log('--------------------------------------------------------------')
            expect(ret).to.eql(orderBook);
        });
        it('Should return OrderBook. Case 2: cash tokens owned by same identity and balance==0', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let FaceValue,AmountPaid,RemainingPayments;

            let secret="MySecret";
            let Name;
            let securitizationCoinBuffer;

            let NewGenericID;

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            genericID=crypto.createHash('sha256', secret).update('GenericID').digest('hex');

            orderID="AskOrder"+genericID;

            let orderArray=[];

            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            price=109.05
            let myAmount=0
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                if(Price>=price){
                    myAmount+=Quantity
                }
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"
                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensArray.push(securitizationCoin)
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let bondTokensArray=[];
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=AmountPaid;
                bondToken.FaceValue=FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.RemainingPayments=RemainingPayments;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=myAmount;
            price=109.05

            // BondToken inside World State
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));

            currentOrder={
                ID: orderID,
                Quantity: amount,
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: amount,
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            let bids=orderBook[0];
            let askReference=currentOrder;

            // "Match Engine" obtained from AskOrder Function
            let counter=askReference.Quantity;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let totalTokens=0;
            let balance=0;
            let myTokens=0;

            for (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    continue
                }
            }

            if (myTokens===askReference.Quantity){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // currentOrder.Quantity=myTokens;
            }else{
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }
            const InputtokenAcumulator=tokenAcumulator;
            const InputcurrentOrder=currentOrder;

            orderBook=[bids,orderBook[1],orderBook[2]]
            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);

            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            orderBook[1].push(currentOrder);


            let ret=await contract._transferCashTokens(ctx,InputtokenAcumulator,InputcurrentOrder,orderBook)


            const orderBookInputVersion=orderBook




            let bondToken=BondToken;
            let myFunds=bondToken.Amount;

            let usedKeys=[];
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let bondTokensToTransfer=[];
            let total=0;
            let bondsToTransfer=[];
            amount=0;
            let token;
            let lastOwner;
            let lastBid
            let lastQuantity
            let lastRestingQuantity
            let lastQuantityMatch
            let partialMatched=[]

            let outputTypeID=":0"
            let outputTokenID='BondToken'+OwnerClientID+genericID+outputTypeID

            let outputBondToken={
                ID: outputTokenID,
                GenericID: genericID,
                TypeID: outputTypeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            let asks
            asks=orderBook[1];
            bids=orderBook[0];
            let bidInputs=tokenAcumulator
            let askInput=currentOrder
            let referencePrice=bidInputs[0].Price
            for (let i=0; i<bidInputs.length;i++){
                if(referencePrice>bidInputs[i].Price){
                    referencePrice=bidInputs[i].Price;
                }
                let balance=0;
                let cashTokenID=bidInputs[i].TokenID;
                let quantityToTransfer=bidInputs[i].QuantityMatch;
                if(usedKeys.indexOf(cashTokenID)!==-1){
                    throw new Error('Error2')
                }
                // total+=quantityToTransfer*bidInputs[i].Price
                balance=bidInputs[i].Quantity-bidInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer*bidInputs[i].Price
                }else{
                    total+=quantityToTransfer*bidInputs[i].Price
                }
                amount+=bidInputs[i].Quantity*bidInputs[i].Price;

                //TODO
                //check errors

                token=await cashTokensArray.filter(item=> item.ID===cashTokenID)



                let cashTokenOwner=token.Owner;


                if (usedOwners.indexOf(cashTokenOwner)===-1){
                    usedOwners.push(cashTokenOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    cashTokensToTransfer.push(quantityToTransfer*askInput.Price);
                    bondTokensToTransfer.push(quantityToTransfer);
                }else{
                    usedAmounts[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(cashTokenOwner)]+=token.Amount;
                    cashTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer*askInput.Price;
                    bondTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                }
                let index;
                let usedKey
                bids=orderBook[0];
                asks=orderBook[1];
                if (bidInputs[i].FullMatch){
                    let myBid=await bids.filter(item=> item.ID!==bidInputs[i].ID);
                    orderBook=[myBid,asks,[referencePrice]]
                }else{
                    let myBid=await bids.filter(item=> item.ID===bidInputs[i].ID);
                    lastOwner=token.Owner
                    lastBid=myBid[0]
                    lastQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    lastQuantityMatch=0
                    lastRestingQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    usedKey=token.ID
                    await ctx.stub.deleteState(token.ID);
                    orderBook=[myBid,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }
            asks=orderBook[1];
            bids=orderBook[0];

            let bondAcumulator=0
            let outputBondTokenBuffer;

            for (let j=0;j<usedOwners.length;j++){

                outputBondToken.ID='BondToken'+usedOwners[j]+outputBondToken.GenericID+':0'
                outputBondToken.Amount=usedAmounts[j];
                outputBondToken.Owner=usedOwners[j];
                bondAcumulator+=outputBondToken.Amount;
                outputBondTokenBuffer=Buffer.from(JSON.stringify(outputBondToken));
                mockStub.createCompositeKey.withArgs('BondToken',[usedOwners[j],outputBondToken.GenericID]).returns('BondToken'+usedOwners[j]+outputBondToken.GenericID);
                mockStub.putState(outputBondTokenBuffer.ID,outputBondTokenBuffer)
            }

            let securitizationCoin1={
                ID: 'securitizationCoin'+OwnerClientID+genericID+':0',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: total,
                Factor: 100,
                CanBeUsed: true
            }
            // let valueBuffer1=Buffer.from(JSON.stringify(securitizationCoin1))
            let restingQuantity=amount-total;
            //console.log('---------------------------------------------------------------------')
            //console.log(restingQuantity)
            //console.log('---------------------------------------------------------------------')
            if(restingQuantity!==0){
                let securitizationCoin2={
                    ID: 'securitizationCoin'+lastOwner+genericID+':1',
                    GenericID: genericID,
                    TypeID: ':1',
                    Issuer: OwnerClientCertAsBytes,
                    Owner: lastOwner,
                    Amount: restingQuantity,
                    Factor: 100,
                    CanBeUsed: true
                }
                lastBid.TokenID=securitizationCoin2.ID;
                lastBid.QuantityMatch=lastQuantityMatch;
                lastBid.RestingQuantity=lastRestingQuantity;
                lastBid.Quantity=lastQuantity;
                lastBid.PartialMatch=false;
                let thisBid=await bids.filter(item=> item.ID===lastBid.ID)
                let indice=bids.indexOf(thisBid[0])
                bids[indice]=lastBid;
                orderBook=[bids,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
                //console.log('ELSE')
            }

            if ((askInput.Quantity-askInput.QuantityMatch)!==0 && !askInput.MarketPrice){
                outputBondToken.ID='BondToken'+OwnerClientID+genericID+':1';
                outputBondToken.Amount=BondToken.Amount-bondAcumulator;
                let thisAsk=await asks.filter(item => item.ID===askInput.ID);
                let index=asks.indexOf(thisAsk[0]);
                thisAsk[0].Quantity=thisAsk[0].Quantity-thisAsk[0].QuantityMatch;
                thisAsk[0].QuantityMatch=0;
                thisAsk[0].TokenID=outputBondToken.ID;
                asks[index]=thisAsk[0];
                orderBook=[bids,asks,[referencePrice]]
            }else if ((askInput.Quantity-askInput.QuantityMatch)===0 && !askInput.MarketPrice){
                let thisAsk=await asks.filter(item => item.ID!==askInput.ID)
                orderBook=[bids,thisAsk,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }

            //console.log('-------------------OrderBook Updated--------------------------')
            //console.log(ret)
            //console.log('--------------------------------------------------------------')
            expect(ret).to.eql(orderBook);
        });
        it('Should return OrderBook. Case 3: cash tokens owned by same identity, balance==0 and AskOrder submitted is a Market order', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let FaceValue,AmountPaid,RemainingPayments;

            let secret="MySecret";
            let Name;
            let securitizationCoinBuffer;

            let NewGenericID;

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            genericID=crypto.createHash('sha256', secret).update('GenericID').digest('hex');

            orderID="AskOrder"+genericID;

            let orderArray=[];

            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            price=109.05
            let myAmount=0
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                if(Price<=price){
                    myAmount+=Quantity
                }
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"
                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensArray.push(securitizationCoin)
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let bondTokensArray=[];
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=AmountPaid;
                bondToken.FaceValue=FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.RemainingPayments=RemainingPayments;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=myAmount;
            price=109.05

            // BondToken inside World State
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));

            // AskMarketOrder
            currentOrder={
                ID: orderID,
                Quantity: amount,
                Price: '',
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: true,
                QuantityMatch: 0,
                RestingQuantity: amount,
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            let bids=orderBook[0];

            // "Match Engine" obtained from AskMarketOrder Function
            const askReference=currentOrder;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let counter=askReference.Quantity;
            let totalTokens=0;
            let balance=0;
            // Check if there is matching
            let myTokens=0
            for await (const bid of bids) {
                if (!bid.FullMatch && myTokens<askReference.Quantity){
                    // //console.log('paso 4.1')
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        // //console.log('paso 4.1.1')
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        // //console.log('paso 4.1.2')
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        // bid.Quantity=bid.Quantity-balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    // //console.log('paso 4.2')
                    continue
                }
            }
            orderBook=[bids,orderBook[1],orderBook[2]]
            currentOrder.TokenID=BondToken.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }
            const InputtokenAcumulator=tokenAcumulator;
            const InputcurrentOrder=currentOrder;

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);

            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            orderBook[1].push(currentOrder);


            let ret=await contract._transferCashTokens(ctx,InputtokenAcumulator,InputcurrentOrder,orderBook)


            const orderBookInputVersion=orderBook




            let bondToken=BondToken;
            let myFunds=bondToken.Amount;

            let usedKeys=[];
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let bondTokensToTransfer=[];
            let total=0;
            let bondsToTransfer=[];
            amount=0;
            let token;
            let lastOwner;
            let lastBid
            let lastQuantity
            let lastRestingQuantity
            let lastQuantityMatch
            let partialMatched=[]

            let outputTypeID=":0"
            let outputTokenID='BondToken'+OwnerClientID+genericID+outputTypeID

            let outputBondToken={
                ID: outputTokenID,
                GenericID: genericID,
                TypeID: outputTypeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            let asks
            asks=orderBook[1];
            bids=orderBook[0];
            let bidInputs=tokenAcumulator
            let askInput=currentOrder
            let referencePrice;
            if (askInput.Price===''){
                referencePrice=bidInputs[0].Price;
            }else{
                referencePrice=bidInputs[0].Price
            }
            for (let i=0; i<bidInputs.length;i++){
                if(referencePrice>bidInputs[i].Price){
                    referencePrice=bidInputs[i].Price;
                }
                let balance=0;
                let cashTokenID=bidInputs[i].TokenID;
                let quantityToTransfer=bidInputs[i].QuantityMatch;
                if(usedKeys.indexOf(cashTokenID)!==-1){
                    throw new Error('Error2')
                }
                // total+=quantityToTransfer*bidInputs[i].Price
                balance=bidInputs[i].Quantity-bidInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer*bidInputs[i].Price
                }else{
                    total+=quantityToTransfer*bidInputs[i].Price
                }
                amount+=bidInputs[i].Quantity*bidInputs[i].Price;

                //TODO
                //check errors

                token=await cashTokensArray.filter(item=> item.ID===cashTokenID)



                let cashTokenOwner=token.Owner;


                if (usedOwners.indexOf(cashTokenOwner)===-1){
                    usedOwners.push(cashTokenOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    // cashTokensToTransfer.push(quantityToTransfer*askInput.Price);
                    bondTokensToTransfer.push(quantityToTransfer);
                }else{
                    usedAmounts[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(cashTokenOwner)]+=token.Amount;
                    // cashTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer*askInput.Price;
                    bondTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                }
                let index;
                let usedKey
                bids=orderBook[0];
                asks=orderBook[1];
                if (bidInputs[i].FullMatch){
                    let myBid=await bids.filter(item=> item.ID!==bidInputs[i].ID);
                    orderBook=[myBid,asks,[referencePrice]]
                }else{
                    let myBid=await bids.filter(item=> item.ID===bidInputs[i].ID);
                    lastOwner=token.Owner
                    lastBid=myBid[0]
                    lastQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    lastQuantityMatch=0
                    lastRestingQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    usedKey=token.ID
                    await ctx.stub.deleteState(token.ID);
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }
            asks=orderBook[1];
            bids=orderBook[0];

            let bondAcumulator=0
            let outputBondTokenBuffer;

            for (let j=0;j<usedOwners.length;j++){

                outputBondToken.ID='BondToken'+usedOwners[j]+outputBondToken.GenericID+':0'
                outputBondToken.Amount=usedAmounts[j];
                outputBondToken.Owner=usedOwners[j];
                bondAcumulator+=outputBondToken.Amount;
                outputBondTokenBuffer=Buffer.from(JSON.stringify(outputBondToken));
                mockStub.createCompositeKey.withArgs('BondToken',[usedOwners[j],outputBondToken.GenericID]).returns('BondToken'+usedOwners[j]+outputBondToken.GenericID);
                mockStub.putState(outputBondTokenBuffer.ID,outputBondTokenBuffer)
            }

            let securitizationCoin1={
                ID: 'securitizationCoin'+OwnerClientID+genericID+':0',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: total,
                Factor: 100,
                CanBeUsed: true
            }
            // let valueBuffer1=Buffer.from(JSON.stringify(securitizationCoin1))
            let restingQuantity=amount-total;
            // //console.log('---------------------------------------------------------------------')
            // //console.log(restingQuantity)
            // //console.log('---------------------------------------------------------------------')
            if(restingQuantity!==0){
                let securitizationCoin2={
                    ID: 'securitizationCoin'+lastOwner+genericID+':1',
                    GenericID: genericID,
                    TypeID: ':1',
                    Issuer: OwnerClientCertAsBytes,
                    Owner: lastOwner,
                    Amount: restingQuantity,
                    Factor: 100,
                    CanBeUsed: true
                }
                lastBid.TokenID=securitizationCoin2.ID;
                lastBid.QuantityMatch=lastQuantityMatch;
                lastBid.RestingQuantity=lastRestingQuantity;
                lastBid.Quantity=lastQuantity;
                lastBid.PartialMatch=false;
                let thisBid=await bids.filter(item=> item.ID===lastBid.ID)
                let indice=bids.indexOf(thisBid[0])
                bids[indice]=lastBid;
                orderBook=[bids,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
                // //console.log('ELSE')
            }

            if ((askInput.Quantity-askInput.QuantityMatch)!==0 && !askInput.MarketPrice){
                outputBondToken.ID='BondToken'+OwnerClientID+genericID+':1';
                outputBondToken.Amount=BondToken.Amount-bondAcumulator;
                let thisAsk=await asks.filter(item => item.ID===askInput.ID);
                let index=asks.indexOf(thisAsk[0]);
                thisAsk[0].Quantity=thisAsk[0].Quantity-thisAsk[0].QuantityMatch;
                thisAsk[0].QuantityMatch=0;
                thisAsk[0].RestingQuantity=thisAsk[0].Quantity;
                thisAsk[0].TokenID=outputBondToken.ID;
                asks[index]=thisAsk[0];
                orderBook=[bids,asks,[referencePrice]]
            }else if ((askInput.Quantity-askInput.QuantityMatch)===0 && !askInput.MarketPrice){
                let thisAsk=await asks.filter(item => item.ID!==askInput.ID)
                orderBook=[bids,thisAsk,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('----------OrderBook Updated----------------')
            //console.log(ret)
            //console.log('--------------------------------------')
            expect(ret).to.eql(orderBook);
        });
        it('Should return OrderBook. Case 4: cash tokens owned by different identities. Ask Order not MarketOrder', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let FaceValue,AmountPaid,RemainingPayments;

            let secret="MySecret";
            let Name;
            let securitizationCoinBuffer;

            let GenericClientID;
            let NewGenericID;

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            genericID=crypto.createHash('sha256', secret).update('GenericID').digest('hex');

            orderID="AskOrder"+genericID;

            let orderArray=[];

            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            GenericClientID="12345678A"
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                OwnerClientID=GenericClientID+i.toString()
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"
                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensArray.push(securitizationCoin)
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID);

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let bondTokensArray=[];
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=AmountPaid;
                bondToken.FaceValue=FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.RemainingPayments=RemainingPayments;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=200;
            price=109.05

            // BondToken inside World State
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));

            currentOrder={
                ID: orderID,
                Quantity: amount,
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: amount,
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            let bids=orderBook[0];
            let askReference=currentOrder;

            // "Match Engine" obtained from AskOrder Function
            let counter=askReference.Quantity;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let totalTokens=0;
            let balance=0;
            let myTokens=0;

            for (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    continue
                }
            }

            orderBook=[bids,orderBook[1],orderBook[2]]

            if (myTokens===askReference.Quantity){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
            }else{
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }
            const InputtokenAcumulator=tokenAcumulator;
            const InputcurrentOrder=currentOrder;

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);

            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            orderBook[1].push(currentOrder);


            let ret=await contract._transferCashTokens(ctx,InputtokenAcumulator,InputcurrentOrder,orderBook)


            const orderBookInputVersion=orderBook




            let bondToken=BondToken;
            let myFunds=bondToken.Amount;

            let usedKeys=[];
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let bondTokensToTransfer=[];
            let total=0;
            let bondsToTransfer=[];
            amount=0;
            let token;
            let lastOwner
            let lastBid
            let lastQuantity
            let lastRestingQuantity
            let lastQuantityMatch
            let partialMatched=[]

            let outputTypeID=":0"
            let outputTokenID='BondToken'+OwnerClientID+genericID+outputTypeID

            let outputBondToken={
                ID: outputTokenID,
                GenericID: genericID,
                TypeID: outputTypeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            let asks
            asks=orderBook[1];
            bids=orderBook[0];
            let bidInputs=tokenAcumulator
            let askInput=currentOrder
            let referencePrice;
            if (askInput.Price===''){
                referencePrice=bidInputs[0].Price;
            }else{
                referencePrice=bidInputs[0].Price
            }

            for (let i=0; i<bidInputs.length;i++){
                if(referencePrice>bidInputs[i].Price){
                    referencePrice=bidInputs[i].Price;
                }
                let balance=0;
                let cashTokenID=bidInputs[i].TokenID;
                let quantityToTransfer=bidInputs[i].QuantityMatch;
                // if(usedKeys.indexOf(cashTokenID)!==-1){
                //     throw new Error('Error2')
                // }
                // total+=quantityToTransfer*bidInputs[i].Price
                balance=bidInputs[i].Quantity-bidInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer*bidInputs[i].Price
                }else{
                    total+=quantityToTransfer*bidInputs[i].Price
                }
                amount+=bidInputs[i].Quantity*bidInputs[i].Price;

                //TODO
                //check errors

                token=await cashTokensArray.filter(item=> item.ID===cashTokenID)



                let cashTokenOwner=token.Owner;


                if (usedOwners.indexOf(cashTokenOwner)===-1){
                    usedOwners.push(cashTokenOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    // cashTokensToTransfer.push(quantityToTransfer*askInput.Price);
                    bondTokensToTransfer.push(quantityToTransfer);
                }else{
                    usedAmounts[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(cashTokenOwner)]+=token.Amount;
                    // cashTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer*askInput.Price;
                    bondTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                }
                let index;
                let usedKey
                bids=orderBook[0];
                asks=orderBook[1];
                if (bidInputs[i].FullMatch){
                    let myBid=await bids.filter(item=> item.ID!==bidInputs[i].ID);
                    orderBook=[myBid,asks,[referencePrice]]
                }else{
                    let myBid=await bids.filter(item=> item.ID===bidInputs[i].ID);
                    lastOwner=token.Owner
                    lastBid=myBid[0]
                    lastQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    lastQuantityMatch=0
                    lastRestingQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    usedKey=token.ID
                    await ctx.stub.deleteState(token.ID);
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }

            let bondAcumulator=0
            for (let j=0;j<usedOwners.length;j++){
                outputBondToken.Amount=usedAmounts[j];
                outputBondToken.Owner=usedOwners[j];
                bondAcumulator+=outputBondToken.Amount;
            }
            let securitizationCoin1={
                ID: 'securitizationCoin'+OwnerClientID+genericID+':0',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: total,
                Factor: 100,
                CanBeUsed: true
            }
            asks=orderBook[1];
            bids=orderBook[0];
            // let valueBuffer1=Buffer.from(JSON.stringify(securitizationCoin1))
            let restingQuantity=amount-total;
            if(restingQuantity!==0){
                let securitizationCoin2={
                    ID: 'securitizationCoin'+lastOwner+genericID+':1',
                    GenericID: genericID,
                    TypeID: ':1',
                    Issuer: OwnerClientCertAsBytes,
                    Owner: lastOwner,
                    Amount: restingQuantity,
                    Factor: 100,
                    CanBeUsed: true
                }
                lastBid.TokenID=securitizationCoin2.ID;
                lastBid.QuantityMatch=lastQuantityMatch;
                lastBid.RestingQuantity=lastRestingQuantity;
                lastBid.Quantity=lastQuantity;
                lastBid.PartialMatch=false;
                let thisBid=await bids.filter(item=> item.ID===lastBid.ID)
                let indice=bids.indexOf(thisBid[0])
                bids[indice]=lastBid;
                orderBook=[bids,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            asks=orderBook[1];
            bids=orderBook[0];

            if ((askInput.Quantity-askInput.QuantityMatch)!==0 && !askInput.MarketPrice){
                outputBondToken.ID='BondToken'+OwnerClientID+genericID+':1';
                outputBondToken.Amount=BondToken.Amount-bondAcumulator;
                let thisAsk=await asks.filter(item => item.ID===askInput.ID);
                let index=asks.indexOf(thisAsk[0]);
                thisAsk[0].Quantity=thisAsk[0].Quantity-thisAsk[0].QuantityMatch;
                thisAsk[0].QuantityMatch=0;
                thisAsk[0].RestingQuantity=thisAsk[0].Quantity;
                thisAsk[0].TokenID=outputBondToken.ID;
                asks[index]=thisAsk[0];
                orderBook=[bids,asks,[referencePrice]]
            }else if ((askInput.Quantity-askInput.QuantityMatch)===0 && !askInput.MarketPrice){
                let thisAsk=await asks.filter(item => item.ID!==askInput.ID)
                orderBook=[bids,thisAsk,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-----------OrderBook Updated---------------')
            expect(ret).to.eql(orderBook);
            //console.log('-------------------------------------------')
        });
        it('Should return OrderBook. Case 5: cash tokens owned by different identities. Ask Order not MarketOrder and is PartialMatched', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let FaceValue,AmountPaid,RemainingPayments;

            let secret="MySecret";
            let Name;
            let securitizationCoinBuffer;

            let GenericClientID;
            let NewGenericID;

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            genericID=crypto.createHash('sha256', secret).update('GenericID').digest('hex');

            orderID="AskOrder"+genericID;

            let orderArray=[];

            let cashTokensArray=[];




            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            GenericClientID="12345678A"
            price=109.05
            let amountToTransfer=0;
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                OwnerClientID=GenericClientID+i.toString()
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"
                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                cashTokensArray.push(securitizationCoin)
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID);

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                if (Price>=price){
                    amountToTransfer+=Quantity;
                }
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            let bondTokensArray=[];
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+Quantity.toString()+Price.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=AmountPaid;
                bondToken.FaceValue=FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.RemainingPayments=RemainingPayments;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (ask matches several bids)=> AskOrder
            amount=amountToTransfer+1;
            price=109.05

            // BondToken inside World State
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));

            currentOrder={
                ID: orderID,
                Quantity: amount,
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: amount,
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            let bids=orderBook[0];
            let askReference=currentOrder;

            // "Match Engine" obtained from AskOrder Function
            let counter=askReference.Quantity;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let totalTokens=0;
            let balance=0;
            let myTokens=0;

            for (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    continue
                }
            }

            orderBook=[bids,orderBook[1],orderBook[2]]
            if (myTokens===askReference.Quantity){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0){
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
            }else{
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }
            const InputtokenAcumulator=tokenAcumulator;
            const InputcurrentOrder=currentOrder;

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);

            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            orderBook[1].push(currentOrder);


            let ret=await contract._transferCashTokens(ctx,InputtokenAcumulator,InputcurrentOrder,orderBook)


            const orderBookInputVersion=orderBook




            let bondToken=BondToken;
            let myFunds=bondToken.Amount;

            let usedKeys=[];
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let bondTokensToTransfer=[];
            let total=0;
            let bondsToTransfer=[];
            amount=0;
            let token;
            let lastOwner
            let lastBid
            let lastQuantity
            let lastRestingQuantity
            let lastQuantityMatch
            let partialMatched=[]

            let outputTypeID=":0"
            let outputTokenID='BondToken'+OwnerClientID+genericID+outputTypeID

            let outputBondToken={
                ID: outputTokenID,
                GenericID: genericID,
                TypeID: outputTypeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            let asks
            asks=orderBook[1];
            bids=orderBook[0];
            let bidInputs=tokenAcumulator
            let askInput=currentOrder
            let referencePrice;

            if (askInput.Price===''){
                referencePrice=bidInputs[0].Price;
            }else{
                referencePrice=bidInputs[0].Price
            }

            for (let i=0; i<bidInputs.length;i++){
                if(referencePrice>bidInputs[i].Price){
                    referencePrice=bidInputs[i].Price;
                }
                let balance=0;
                let cashTokenID=bidInputs[i].TokenID;
                let quantityToTransfer=bidInputs[i].QuantityMatch;
                // if(usedKeys.indexOf(cashTokenID)!==-1){
                //     throw new Error('Error2')
                // }
                // total+=quantityToTransfer*bidInputs[i].Price
                balance=bidInputs[i].Quantity-bidInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer*bidInputs[i].Price
                }else{
                    total+=quantityToTransfer*bidInputs[i].Price
                }
                amount+=bidInputs[i].Quantity*bidInputs[i].Price;

                //TODO
                //check errors

                token=await cashTokensArray.filter(item=> item.ID===cashTokenID)



                let cashTokenOwner=token.Owner;


                if (usedOwners.indexOf(cashTokenOwner)===-1){
                    usedOwners.push(cashTokenOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    // cashTokensToTransfer.push(quantityToTransfer*askInput.Price);
                    bondTokensToTransfer.push(quantityToTransfer);
                }else{
                    usedAmounts[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(cashTokenOwner)]+=token.Amount;
                    // cashTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer*askInput.Price;
                    bondTokensToTransfer[usedOwners.indexOf(cashTokenOwner)]+=quantityToTransfer;
                }
                let index;
                let usedKey
                bids=orderBook[0];
                asks=orderBook[1];
                if (bidInputs[i].FullMatch){
                    let myBid=await bids.filter(item=> item.ID!==bidInputs[i].ID);
                    orderBook=[myBid,asks,[referencePrice]]
                }else{
                    let myBid=await bids.filter(item=> item.ID===bidInputs[i].ID);
                    lastOwner=token.Owner
                    lastBid=myBid[0]
                    lastQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    lastQuantityMatch=0
                    lastRestingQuantity=lastBid.Quantity-lastBid.QuantityMatch
                    usedKey=token.ID
                    await ctx.stub.deleteState(token.ID);
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }

            let bondAcumulator=0
            for (let j=0;j<usedOwners.length;j++){
                outputBondToken.Amount=usedAmounts[j];
                outputBondToken.Owner=usedOwners[j];
                bondAcumulator+=outputBondToken.Amount;
            }

            let securitizationCoin1={
                ID: 'securitizationCoin'+OwnerClientID+genericID+':0',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: total,
                Factor: 100,
                CanBeUsed: true
            }
            // let valueBuffer1=Buffer.from(JSON.stringify(securitizationCoin1))
            let restingQuantity=amount-total;
            asks=orderBook[1];
            bids=orderBook[0];
            if(restingQuantity!==0){
                let securitizationCoin2={
                    ID: 'securitizationCoin'+lastOwner+genericID+':1',
                    GenericID: genericID,
                    TypeID: ':1',
                    Issuer: OwnerClientCertAsBytes,
                    Owner: lastOwner,
                    Amount: restingQuantity,
                    Factor: 100,
                    CanBeUsed: true
                }
                lastBid.TokenID=securitizationCoin2.ID;
                lastBid.QuantityMatch=lastQuantityMatch;
                lastBid.RestingQuantity=lastRestingQuantity;
                lastBid.Quantity=lastQuantity;
                lastBid.PartialMatch=false;
                let thisBid=await bids.filter(item=> item.ID===lastBid.ID)
                let indice=bids.indexOf(thisBid[0])
                bids[indice]=lastBid;
                orderBook=[bids,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            asks=orderBook[1];
            bids=orderBook[0];
            if ((askInput.Quantity-askInput.QuantityMatch)!==0 && !askInput.MarketPrice){
                outputBondToken.ID='BondToken'+OwnerClientID+genericID+':1';
                outputBondToken.Amount=BondToken.Amount-bondAcumulator;
                let thisAsk=await asks.filter(item => item.ID===askInput.ID);
                let index=asks.indexOf(thisAsk[0]);
                thisAsk[0].Quantity=thisAsk[0].Quantity-thisAsk[0].QuantityMatch;
                thisAsk[0].QuantityMatch=0;
                thisAsk[0].RestingQuantity=thisAsk[0].Quantity;
                thisAsk[0].TokenID=outputBondToken.ID;
                asks[index]=thisAsk[0];
                orderBook=[bids,asks,[referencePrice]]
            }else if ((askInput.Quantity-askInput.QuantityMatch)===0 && !askInput.MarketPrice){
                let thisAsk=await asks.filter(item => item.ID!==askInput.ID)
                orderBook=[bids,thisAsk,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-----------OrderBook Updated---------------')
            expect(ret).to.eql(orderBook);
            //console.log('-------------------------------------------')
        });
    })
    // One bid has matched multiple asks and those asks must transfer those bond tokens to bid order submitter
    // and this latter will split his/her cash token to ask submitters matched
    describe('TESTING: _transferBondTokens(ctx,askInputs,bidInput, orderBook) works as expected',()=>{
        let orderBook, askInput, bidInputs;
        let genericID,new_genericID,ownerID,date,argDate;
        let typeID,tokenID,amount,new_tokenID,IdealQuantity,price,IdealPrice;
        let orderID, BondToken1,BondToken2,new_BondToken, securitizationCoin, new_securitizationCoin;
        let currentOrder;
        let bondID, identificativo;
        let FunctionAndParameters;
        let OrderBook;
        let newBidOrder
        let monthlyPayout,PoolID;
        let TransactionID;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let BondToken

        async function sortingAskOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }

        let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? -1 : 1));
            return orderArray.reverse()
        }
        let secret="MySecret"

        // beforeEach we must create an order Book
        beforeEach(() => {
            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };
        })
        it('Should throw an error if there is no securitizationCoin from bid submitter', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,MonthlyPayout,RemainingPayments;

            let secret;

            let Name;

            let securitizationCoinBuffer;

            let NewGenericID;

            // for creating hash ids
            secret='MySecret';

            OwnerClientID="12345678A"
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64')
            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            date=new Date()
            argDate=date.toUTCString();

            typeID=':0'
            tokenID="BondToken"+OwnerClientID+genericID;
            amount="15";

            price="123.21";
            IdealPrice=parseInt(parseFloat(price)*100)

            orderID="AskOrder"+genericID;


            // create a full-of-orders order book

            let orderArray=[];

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            // ASKS
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientID;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceive=BondToken.CouponsReceive;
                bondToken.NotBefore=BondToken.NotBefore;

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (BID matches several ASKS)=> BidOrder
            amount=200;
            price=110.20;

            GenericID=crypto.createHash('sha256', secret).update(amount.toString())
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:true,
            }


            // current order is a bid order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            let asks=orderBook[1];

            let bidReference=currentOrder;
            // "Match Engine" obtained from BidOrder Function
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            // check if there is matching
            let myTokens=0
            // //console.log('paso 5')
            // //console.log(bidReference.Price)
            // check if there is matching
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                    }else{
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }

            orderBook=[orderBook[0],asks,orderBook[2]]
            if (counter===0){
                // Full Match
                currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(counter!==0 && counter!==bidReference.Quantity){
                // Partial Match
                currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
            }else{
                // No match
                currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            orderBook[0].push(currentOrder);

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }


            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,new_genericID]).returns('BondToken'+OwnerClientID+new_genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);


            mockStub.putState.withArgs('OrderMatch'+genericID,Buffer.from(JSON.stringify(orderMatch)));

            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            try{
                await contract._transferBondTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook);
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There is no state associated to key ${currentOrder.TokenID}`)
            }
        });
        it('Should throw an error if bond token is intended to be spent more that once', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let FaceValue;

            let secret;

            let Name;

            let securitizationCoinBuffer;

            let NewGenericID;
            let currentOrder

            // for creating hash ids
            secret='MySecret';

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            OwnerClientID="12345678A"
            OwnerClientCert="OwnerClientCert"
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64')

            date=new Date()
            argDate=date.toUTCString();

            typeID=':0'
            tokenID="BondToken"+OwnerClientID+genericID;
            amount="15";

            price="123.21";
            IdealPrice=parseInt(parseFloat(price)*100)

            orderID="BidOrder"+genericID;

            // create a full-of-orders order book

            let orderArray=[];

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }
            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            // ASKS
            orderArray=[]
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;


                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.FaceValue=FaceValue;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let AskOrderArray_Ordered=await sortingAskOrders(orderArray)


            //search for a match (BID matches several ASKS)=> BidOrder
            amount=200;
            price=115.05;

            GenericID=crypto.createHash('sha256', secret).update(amount.toString())
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:true,
            }

            // Mock Cash Token
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

            // current order is a bid order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            let asks=orderBook[1];

            let bidReference=currentOrder;
            // "Match Engine" obtained from BidOrder Function
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            // check if there is matching
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }

            orderBook=[orderBook[0],asks,orderBook[2]]
            if (counter===0){
                // Full Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(counter!==0 && counter!==bidReference.Quantity){
                // Partial Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
            }else{
                // No match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            orderBook[0].push(currentOrder);



            // token acumulator must have an ask order repeated in order to check this error
            tokenAcumulator[1]=tokenAcumulator[0]
            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }

            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]

            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,new_genericID]).returns('BondToken'+OwnerClientID+new_genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);


            mockStub.putState.withArgs('OrderMatch'+genericID,Buffer.from(JSON.stringify(orderMatch)));
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)

            try{
                await contract._transferBondTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook);
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Bond state with key ${tokenAcumulator[1].TokenID} cannot be spent twice`)
            }
        });
        it('Should return orderBook. Case 1: bond tokens owned by same identity', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;


            let secret;
            let Name;
            let securitizationCoinBuffer;
            let NewGenericID;

            let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

            let bondTokensArray=[];
            let cashTokensArray=[];
            // for creating hash ids
            secret='TutorialsPoint';

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            date=new Date()
            argDate=date.toUTCString();


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');


            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            orderID="BidOrder"+genericID;

            // create a full-of-orders order book
            let orderArray=[];
            let token

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            // ASKS
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"


                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;


                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates,
                bondToken.CouponsReceived=BondToken.CouponsReceived,
                bondToken.NotBefore=BondToken.NotBefore

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);


            //search for a match (BID matches several ASKS)=> BidOrder
            amount=200;
            price=111.20;

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString())
            // genericID=GenericID
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:false,
            }

            //mock cash token state
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

            // current order is a bid order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            let asks=orderBook[1];

            let bidReference=currentOrder;
            // "Match Engine" obtained from BidOrder Function
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            // check if there is matching
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }
            orderBook=[orderBook[0],asks,orderBook[2]]

            // let newID=await this._splitMoney(ctx,token.ID,total);
            if (myTokens===bidReference.Quantity){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // No match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            orderBook[0].push(currentOrder);

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }

            mockStub.getTxID.returns(genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            let ret=await contract._transferBondTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook)

            const orderBookInputVersion=orderBook

            let bids=orderBook[0];
            let askInputs=tokenAcumulator;

            let bidInput=currentOrder;
            let lastAsk;
            let lastAskQuantity;
            let lastAskQuantityMatch;
            let lastAskRestingQuantity
            let usedKeys=[];
            let usedKey, lastOwner;
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let total=0;
            let thisAsk;
            // let lastOwner
            let bondsToTransfer=[];
            amount=0;
            let referencePrice

            if(bidInput.Price===''){
                referencePrice=askInputs[0].Price;
            }else{
                referencePrice=askInputs[0].Price
            }

            for (let i=0; i<askInputs.length;i++){
                if (referencePrice<askInputs[i].Price){
                    referencePrice=askInputs[i].Price;
                }

                let bondID=askInputs[i].TokenID;
                let quantityToTransfer=askInputs[i].QuantityMatch;

                token=bondTokensArray.filter(item=> item.ID===bondID)

                let bondOwner=token.Owner;

                if (usedOwners.indexOf(bondOwner)===-1){
                    usedOwners.push(bondOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    cashTokensToTransfer.push(quantityToTransfer*askInputs[i].Price);
                }else{
                    usedAmounts[usedOwners.indexOf(bondOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(bondOwner)]+=token.Amount;
                    cashTokensToTransfer[usedOwners.indexOf(bondOwner)]+=quantityToTransfer*askInputs[i].Price;
                }

                balance=askInputs[i].Quantity-askInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer
                }else{
                    total+=askInputs[i].Quantity
                }

                amount+=quantityToTransfer;

                bids=orderBook[0];
                asks=orderBook[1];
                if (askInputs[i].FullMatch){
                    let myAsk=await asks.filter(item=> item.ID!==askInputs[i].ID);
                    orderBook=[bids,myAsk,[referencePrice]]
                }else{
                    let myAsk=await asks.filter(item=> item.ID===askInputs[i].ID);
                    lastOwner=token.Owner;
                    lastAsk=myAsk[0];
                    lastAskQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;
                    lastAskQuantityMatch=0;
                    lastAskRestingQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;

                    // New token ID

                    usedKey=token.ID
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }
            let outputSecuritizationCoin={
                ID: '',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: '',
                Amount: '',
                Factor: 100,
                CanBeUsed: true
            }

            let cashAcumulator=0
            for (let j=0;j<usedOwners.length;j++){
                // //console.log('creamos estados tipo cash tokens')
                ////console.log(`creamos estados tipo cash tokens`)

                //TODO
                // check coupons received
                outputSecuritizationCoin.ID='securitizationCoin'+usedOwners[j]+outputSecuritizationCoin.GenericID+':0';
                outputSecuritizationCoin.Amount=usedAmounts[j];

                outputSecuritizationCoin.Owner=usedOwners[j];


                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                cashAcumulator+=outputSecuritizationCoin.Amount;
            }
            bids=orderBook[0];
            asks=orderBook[1];

            let bondToken1={
                ID: 'BondToken'+OwnerClientID+genericID+":0",
                GenericID: genericID,
                TypeID: ':0',
                Rating: token.Rating,
                CouponRate: token.CouponRate,
                MaturityDate: token.MaturityDate,
                Issuer: new_securitizationCoin.Issuer,
                Owner: new_securitizationCoin.Owner,
                Pool: token.Pool,
                AmountPaid: token.AmountPaid,
                FaceValue: token.FaceValue,
                MonthlyPayout: token.MonthlyPayout,
                RemainingPayments: token.RemainingPayments,
                NotBefore: token.NotBefore,
                CouponDates: token.CouponDates,
                CouponsReceived: token.CouponsReceived,
                Amount: amount,
                CanBeUsed: true
            }
            let valueBuffer1=Buffer.from(JSON.stringify(bondToken1))
            let restingQuantity=total-amount;
            if(restingQuantity!==0){
                let bondID='BondToken'+lastOwner+genericID+':1'
                let bondToken2={
                    ID: bondID,
                    GenericID: genericID,
                    TypeID: ':1',
                    Rating: token.Rating,
                    CouponRate: token.CouponRate,
                    MaturityDate: token.MaturityDate,
                    Issuer: new_securitizationCoin.Issuer,
                    Owner: new_securitizationCoin.Owner,
                    Pool: token.Pool,
                    AmountPaid: token.AmountPaid,
                    FaceValue: token.FaceValue,
                    MonthlyPayout: token.MonthlyPayout,
                    RemainingPayments: token.RemainingPayments,
                    Amount: restingQuantity,
                    CanBeUsed: false,
                    NotBefore: token.NotBefore,
                    CouponDates: token.CouponDates,
                    CouponsReceived: token.CouponsReceived
                }
                let indice=asks.indexOf(lastAsk)
                lastAsk.TokenID=bondID;
                lastAsk.QuantityMatch=lastAskQuantityMatch;
                lastAsk.RestingQuantity=lastAskRestingQuantity;
                lastAsk.Quantity=lastAskQuantity;
                lastAsk.PartialMatch=false;
                asks[indice]=lastAsk;
                orderBook=[bids,asks,[referencePrice]]

                let valueBuffer2=Buffer.from(JSON.stringify(bondToken2));
            }else{
                orderBook=[bids,asks,[referencePrice]]
                //console.log('ELSE')
            }


            if ((bidInput.Quantity-bidInput.QuantityMatch)!==0 && !bidInput.MarketPrice){
                outputSecuritizationCoin.ID='securitizationCoin'+OwnerClientID+genericID+':1';
                outputSecuritizationCoin.Amount=token.Amount-cashAcumulator;
                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                let thisBid=await bids.filter(item => item.ID===bidInput.ID);
                let index=bids.indexOf(thisBid[0]);
                thisBid[0].Quantity=thisBid[0].Quantity-thisBid[0].QuantityMatch;
                thisBid[0].QuantityMatch=0;
                thisBid[0].RestingQuantity=thisBid[0].Quantity;
                thisBid[0].TokenID=outputSecuritizationCoin.ID;
                bids[index]=thisBid[0];
                orderBook=[bids,asks,[referencePrice]]
                // await ctx.stub.deleteState(token.ID)
            }else if ((bidInput.Quantity-bidInput.QuantityMatch)===0 && !bidInput.MarketPrice){
                let thisBid=await bids.filter(item => item.ID!==bidInput.ID)
                orderBook=[thisBid,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-------------OrderBook Updated-----------------')
            //console.log(ret)
            //console.log('-----------------------------------------------')
            expect(ret).to.eql(orderBook)
        });
        it('Should return orderBook. Case 2: bond tokens owned by same identity and balance==0', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,OriginalValue,MonthlyPayout,RemainingPayments;

            let secret;
            let Name;
            let securitizationCoinBuffer;
            let NewGenericID;

            let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

            let bondTokensArray=[];
            let cashTokensArray=[];
            // for creating hash ids
            secret='TutorialsPoint';

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            date=new Date()
            argDate=date.toUTCString();


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');


            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            orderID="BidOrder"+genericID;

            // create a full-of-orders order book
            let orderArray=[];
            let token

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            // ASKS
            price=111.20;
            let amountMatched=0
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"


                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;
                Rating= "";
                CouponRate= 4;
                CouponFactor= 100;
                MaturityDate= "";
                FaceValue=100000;
                Factor=100;
                Pool= "";
                AmountPaid= "";
                OriginalValue= "";
                MonthlyPayout= "";
                RemainingPayments= "";

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates,
                bondToken.CouponsReceived=BondToken.CouponsReceived,
                bondToken.NotBefore=BondToken.NotBefore

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if(price>=Price){
                    amountMatched+=Quantity
                }

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);


            //search for a match (BID matches several ASKS)=> BidOrder
            amount=amountMatched;
            price=111.20;

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString())
            // genericID=GenericID
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:false,
            }

            //mock cash token state
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

            // current order is a bid order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            let asks=orderBook[1];

            let bidReference=currentOrder;
            // "Match Engine" obtained from BidOrder Function
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            // check if there is matching
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }

            // let newID=await this._splitMoney(ctx,token.ID,total);
            if (myTokens===bidReference.Quantity){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // No match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            orderBook[0].push(currentOrder);

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }

            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]

            mockStub.getTxID.returns(genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            let ret=await contract._transferBondTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook)

            const orderBookInputVersion=orderBook

            let bids=orderBook[0];
            let askInputs=tokenAcumulator;

            let bidInput=currentOrder;
            let lastAsk;
            let lastAskQuantity;
            let lastAskQuantityMatch;
            let lastAskRestingQuantity
            let usedKeys=[];
            let usedKey, lastOwner;
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let total=0;
            let thisAsk;
            // let lastOwner
            let bondsToTransfer=[];
            amount=0;
            let referencePrice

            if(bidInput.Price===''){
                referencePrice=askInputs[0].Price;
            }else{
                referencePrice=askInputs[0].Price
            }

            for (let i=0; i<askInputs.length;i++){
                if (referencePrice<askInputs[i].Price){
                    referencePrice=askInputs[i].Price;
                }

                let bondID=askInputs[i].TokenID;
                let quantityToTransfer=askInputs[i].QuantityMatch;

                token=bondTokensArray.filter(item=> item.ID===bondID)

                let bondOwner=token.Owner;

                if (usedOwners.indexOf(bondOwner)===-1){
                    usedOwners.push(bondOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    cashTokensToTransfer.push(quantityToTransfer*askInputs[i].Price);
                }else{
                    usedAmounts[usedOwners.indexOf(bondOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(bondOwner)]+=token.Amount;
                    cashTokensToTransfer[usedOwners.indexOf(bondOwner)]+=quantityToTransfer*askInputs[i].Price;
                }

                balance=askInputs[i].Quantity-askInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer
                }else{
                    total+=askInputs[i].Quantity
                }

                amount+=quantityToTransfer;

                bids=orderBook[0];
                asks=orderBook[1];
                if (askInputs[i].FullMatch){
                    let myAsk=await asks.filter(item=> item.ID!==askInputs[i].ID);
                    orderBook=[bids,myAsk,[referencePrice]]
                }else{
                    let myAsk=await asks.filter(item=> item.ID===askInputs[i].ID);
                    lastOwner=token.Owner;
                    lastAsk=myAsk[0];
                    lastAskQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;
                    lastAskQuantityMatch=0;
                    lastAskRestingQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;

                    // New token ID

                    usedKey=token.ID
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }
            let outputSecuritizationCoin={
                ID: '',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: '',
                Amount: '',
                Factor: 100,
                CanBeUsed: true
            }

            let cashAcumulator=0
            for (let j=0;j<usedOwners.length;j++){
                // //console.log('creamos estados tipo cash tokens')
                ////console.log(`creamos estados tipo cash tokens`)

                //TODO
                // check coupons received
                outputSecuritizationCoin.ID='securitizationCoin'+usedOwners[j]+outputSecuritizationCoin.GenericID+':0';
                outputSecuritizationCoin.Amount=usedAmounts[j];

                outputSecuritizationCoin.Owner=usedOwners[j];


                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                cashAcumulator+=outputSecuritizationCoin.Amount;
            }
            bids=orderBook[0];
            asks=orderBook[1];

            let bondToken1={
                ID: 'BondToken'+OwnerClientID+genericID+":0",
                GenericID: genericID,
                TypeID: ':0',
                Rating: token.Rating,
                CouponRate: token.CouponRate,
                MaturityDate: token.MaturityDate,
                Issuer: new_securitizationCoin.Issuer,
                Owner: new_securitizationCoin.Owner,
                Pool: token.Pool,
                AmountPaid: token.AmountPaid,
                FaceValue: token.FaceValue,
                MonthlyPayout: token.MonthlyPayout,
                RemainingPayments: token.RemainingPayments,
                NotBefore: token.NotBefore,
                CouponDates: token.CouponDates,
                CouponsReceived: token.CouponsReceived,
                Amount: amount,
                CanBeUsed: true
            }
            let valueBuffer1=Buffer.from(JSON.stringify(bondToken1))
            let restingQuantity=total-amount;
            if(restingQuantity!==0){
                let bondID='BondToken'+lastOwner+genericID+':1'
                let bondToken2={
                    ID: bondID,
                    GenericID: genericID,
                    TypeID: ':1',
                    Rating: token.Rating,
                    CouponRate: token.CouponRate,
                    MaturityDate: token.MaturityDate,
                    Issuer: new_securitizationCoin.Issuer,
                    Owner: new_securitizationCoin.Owner,
                    Pool: token.Pool,
                    AmountPaid: token.AmountPaid,
                    FaceValue: token.FaceValue,
                    MonthlyPayout: token.MonthlyPayout,
                    RemainingPayments: token.RemainingPayments,
                    Amount: restingQuantity,
                    CanBeUsed: false,
                    NotBefore: token.NotBefore,
                    CouponDates: token.CouponDates,
                    CouponsReceived: token.CouponsReceived
                }
                let indice=asks.indexOf(lastAsk)
                lastAsk.TokenID=bondID;
                lastAsk.QuantityMatch=lastAskQuantityMatch;
                lastAsk.RestingQuantity=lastAskRestingQuantity;
                lastAsk.Quantity=lastAskQuantity;
                lastAsk.PartialMatch=false;
                asks[indice]=lastAsk;
                orderBook=[bids,asks,[referencePrice]]

                let valueBuffer2=Buffer.from(JSON.stringify(bondToken2));
            }else{
                orderBook=[bids,asks,[referencePrice]]
                //console.log('ELSE')
            }


            if ((bidInput.Quantity-bidInput.QuantityMatch)!==0 && !bidInput.MarketPrice){
                outputSecuritizationCoin.ID='securitizationCoin'+OwnerClientID+genericID+':1';
                outputSecuritizationCoin.Amount=token.Amount-cashAcumulator;
                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                let thisBid=await bids.filter(item => item.ID===bidInput.ID);
                let index=bids.indexOf(thisBid[0]);
                thisBid[0].Quantity=thisBid[0].Quantity-thisBid[0].QuantityMatch;
                thisBid[0].QuantityMatch=0;
                thisBid[0].RestingQuantity=thisBid[0].Quantity;
                thisBid[0].TokenID=outputSecuritizationCoin.ID;
                bids[index]=thisBid[0];
                orderBook=[bids,asks,[referencePrice]]
                // await ctx.stub.deleteState(token.ID)
            }else if ((bidInput.Quantity-bidInput.QuantityMatch)===0 && !bidInput.MarketPrice){
                let thisBid=await bids.filter(item => item.ID!==bidInput.ID)
                orderBook=[thisBid,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-------------OrderBook Updated-----------------')
            //console.log(ret)
            //console.log('-----------------------------------------------')
            expect(ret).to.eql(orderBook)
        });
        it('Should return orderBook. Case 3: bond tokens owned by same identity, balance==0 and BidOrder submitted is a Market order', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let secret;
            let Name;
            let securitizationCoinBuffer;
            let NewGenericID;

            let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

            let bondTokensArray=[];
            let cashTokensArray=[];
            // for creating hash ids
            secret='mySecret';

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            date=new Date()
            argDate=date.toUTCString();


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');


            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            orderID="BidOrder"+genericID;

            // create a full-of-orders order book
            let orderArray=[];
            let token

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            // ASKS
            price=111.20;
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"


                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates,
                bondToken.CouponsReceived=BondToken.CouponsReceived,
                bondToken.NotBefore=BondToken.NotBefore

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);


            //search for a match (BID matches several ASKS)=> BidOrder
            amount=200;
            price=111.20;

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString()).digest('hex')
            // genericID=GenericID
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:false,
            }

            //mock cash token state
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

            // current order is a bid order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: '',
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: true,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            let asks=orderBook[1];

            let bidReference=currentOrder;
            // "Match Engine" obtained from BidOrder Function
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            // check if there is matching
            for await (const ask of asks) {
                if (!ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                    }
                }else{
                    continue
                }
            }

            // Full Match
            currentOrder.TokenID=new_securitizationCoin.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            orderBook=[orderBook[0],asks,orderBook[2]];

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }

            mockStub.getTxID.returns(genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            let ret=await contract._transferBondTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook)


            const orderBookInputVersion=orderBook

            let bids=orderBook[0];
            let askInputs=tokenAcumulator;

            let bidInput=currentOrder;
            let lastAsk;
            let lastAskQuantity;
            let lastAskQuantityMatch;
            let lastAskRestingQuantity
            let usedKeys=[];
            let usedKey, lastOwner;
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let total=0;
            let thisAsk;
            // let lastOwner
            let bondsToTransfer=[];
            amount=0;
            let referencePrice

            if(bidInput.Price===''){
                referencePrice=askInputs[0].Price;
            }else{
                referencePrice=askInputs[0].Price
            }

            for (let i=0; i<askInputs.length;i++){
                if (referencePrice<askInputs[i].Price){
                    referencePrice=askInputs[i].Price;
                }

                let bondID=askInputs[i].TokenID;
                let quantityToTransfer=askInputs[i].QuantityMatch;

                token=bondTokensArray.filter(item=> item.ID===bondID)

                let bondOwner=token.Owner;

                if (usedOwners.indexOf(bondOwner)===-1){
                    usedOwners.push(bondOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    cashTokensToTransfer.push(quantityToTransfer*askInputs[i].Price);
                }else{
                    usedAmounts[usedOwners.indexOf(bondOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(bondOwner)]+=token.Amount;
                    cashTokensToTransfer[usedOwners.indexOf(bondOwner)]+=quantityToTransfer*askInputs[i].Price;
                }

                balance=askInputs[i].Quantity-askInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer
                }else{
                    total+=askInputs[i].Quantity
                }

                amount+=quantityToTransfer;

                bids=orderBook[0];
                asks=orderBook[1];
                if (askInputs[i].FullMatch){
                    let myAsk=await asks.filter(item=> item.ID!==askInputs[i].ID);
                    orderBook=[bids,myAsk,[referencePrice]]
                }else{
                    let myAsk=await asks.filter(item=> item.ID===askInputs[i].ID);
                    lastOwner=token.Owner;
                    lastAsk=myAsk[0];
                    lastAskQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;
                    lastAskQuantityMatch=0;
                    lastAskRestingQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;

                    // New token ID

                    usedKey=token.ID
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }
            let outputSecuritizationCoin={
                ID: '',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: '',
                Amount: '',
                Factor: 100,
                CanBeUsed: true
            }

            let cashAcumulator=0
            for (let j=0;j<usedOwners.length;j++){
                // //console.log('creamos estados tipo cash tokens')
                ////console.log(`creamos estados tipo cash tokens`)

                //TODO
                // check coupons received
                outputSecuritizationCoin.ID='securitizationCoin'+usedOwners[j]+outputSecuritizationCoin.GenericID+':0';
                outputSecuritizationCoin.Amount=usedAmounts[j];

                outputSecuritizationCoin.Owner=usedOwners[j];


                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                cashAcumulator+=outputSecuritizationCoin.Amount;
            }
            bids=orderBook[0];
            asks=orderBook[1];

            let bondToken1={
                ID: 'BondToken'+OwnerClientID+genericID+":0",
                GenericID: genericID,
                TypeID: ':0',
                Rating: token.Rating,
                CouponRate: token.CouponRate,
                MaturityDate: token.MaturityDate,
                Issuer: new_securitizationCoin.Issuer,
                Owner: new_securitizationCoin.Owner,
                Pool: token.Pool,
                AmountPaid: token.AmountPaid,
                FaceValue: token.FaceValue,
                MonthlyPayout: token.MonthlyPayout,
                RemainingPayments: token.RemainingPayments,
                NotBefore: token.NotBefore,
                CouponDates: token.CouponDates,
                CouponsReceived: token.CouponsReceived,
                Amount: amount,
                CanBeUsed: true
            }
            let valueBuffer1=Buffer.from(JSON.stringify(bondToken1))
            let restingQuantity=total-amount;
            if(restingQuantity!==0){
                let bondID='BondToken'+lastOwner+genericID+':1'
                let bondToken2={
                    ID: bondID,
                    GenericID: genericID,
                    TypeID: ':1',
                    Rating: token.Rating,
                    CouponRate: token.CouponRate,
                    MaturityDate: token.MaturityDate,
                    Issuer: new_securitizationCoin.Issuer,
                    Owner: new_securitizationCoin.Owner,
                    Pool: token.Pool,
                    AmountPaid: token.AmountPaid,
                    FaceValue: token.FaceValue,
                    MonthlyPayout: token.MonthlyPayout,
                    RemainingPayments: token.RemainingPayments,
                    Amount: restingQuantity,
                    CanBeUsed: false,
                    NotBefore: token.NotBefore,
                    CouponDates: token.CouponDates,
                    CouponsReceived: token.CouponsReceived
                }
                let indice=asks.indexOf(lastAsk)
                lastAsk.TokenID=bondID;
                lastAsk.QuantityMatch=lastAskQuantityMatch;
                lastAsk.RestingQuantity=lastAskRestingQuantity;
                lastAsk.Quantity=lastAskQuantity;
                lastAsk.PartialMatch=false;
                asks[indice]=lastAsk;
                orderBook=[bids,asks,[referencePrice]]

                let valueBuffer2=Buffer.from(JSON.stringify(bondToken2));
            }else{
                orderBook=[bids,asks,[referencePrice]]
                //console.log('ELSE')
            }
            bids=orderBook[0];
            asks=orderBook[1];

            if ((bidInput.Quantity-bidInput.QuantityMatch)!==0 && !bidInput.MarketPrice){
                outputSecuritizationCoin.ID='securitizationCoin'+OwnerClientID+genericID+':1';
                outputSecuritizationCoin.Amount=token.Amount-cashAcumulator;
                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                let thisBid=await bids.filter(item => item.ID===bidInput.ID);
                let index=bids.indexOf(thisBid[0]);
                thisBid[0].Quantity=thisBid[0].Quantity-thisBid[0].QuantityMatch;
                thisBid[0].QuantityMatch=0;
                thisBid[0].RestingQuantity=thisBid[0].Quantity;
                thisBid[0].TokenID=outputSecuritizationCoin.ID;
                bids[index]=thisBid[0];
                orderBook=[bids,asks,[referencePrice]]
                // await ctx.stub.deleteState(token.ID)
            }else if ((bidInput.Quantity-bidInput.QuantityMatch)===0 && !bidInput.MarketPrice){
                let thisBid=await bids.filter(item => item.ID!==bidInput.ID)
                orderBook=[thisBid,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-------------OrderBook Updated-----------------')
            //console.log(ret)
            //console.log('-----------------------------------------------')
            expect(ret).to.eql(orderBook)
        });
        it('Should return orderBook. Case 4: bond tokens owned by different identities. BidOrder not market order', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,OriginalValue,MonthlyPayout,RemainingPayments;

            let secret;
            let Name;
            let securitizationCoinBuffer;
            let NewGenericID;

            let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

            let bondTokensArray=[];
            let cashTokensArray=[];
            // for creating hash ids
            secret='TutorialsPoint';

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            date=new Date()
            argDate=date.toUTCString();


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');


            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            orderID="BidOrder"+genericID;

            // create a full-of-orders order book
            let orderArray=[];
            let token

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();


                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let GenericOwnerClientID="12345678A";
            // ASKS
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"


                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;
                Rating= "";
                CouponRate= 4;
                CouponFactor= 100;
                MaturityDate= "";
                FaceValue=100000;
                Factor=100;
                Pool= "";
                AmountPaid= "";
                OriginalValue= "";
                MonthlyPayout= "";
                RemainingPayments= "";

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates,
                bondToken.CouponsReceived=BondToken.CouponsReceived,
                bondToken.NotBefore=BondToken.NotBefore

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);
            OwnerClientID="12345678A"

            //search for a match (BID matches several ASKS)=> BidOrder
            amount=200;
            price=111.20;

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString()).digest('hex')
            // genericID=GenericID
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:false,
            }

            //mock cash token state
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

            // current order is a bid order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]
            let asks=orderBook[1];

            let bidReference=currentOrder;
            // "Match Engine" obtained from BidOrder Function
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            // check if there is matching
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }

            // let newID=await this._splitMoney(ctx,token.ID,total);
            if (myTokens===bidReference.Quantity){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // No match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            orderBook[0].push(currentOrder);


            BidOrderArray_Ordered=await sortingBidOrders(orderBook[0]);
            AskOrderArray_Ordered=await sortingAskOrders(orderBook[1]);

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }

            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered]

            mockStub.getTxID.returns(genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            let ret=await contract._transferBondTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook)


            const orderBookInputVersion=orderBook

            let bids=orderBook[0];
            let askInputs=tokenAcumulator;

            let bidInput=currentOrder;
            let lastAsk;
            let lastAskQuantity;
            let lastAskQuantityMatch;
            let lastAskRestingQuantity
            let usedKeys=[];
            let usedKey, lastOwner;
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let total=0;
            let thisAsk;
            // let lastOwner
            let bondsToTransfer=[];
            amount=0;
            let referencePrice

            if(bidInput.Price===''){
                referencePrice=askInputs[0].Price;
            }else{
                referencePrice=askInputs[0].Price
            }

            for (let i=0; i<askInputs.length;i++){
                if (referencePrice<askInputs[i].Price){
                    referencePrice=askInputs[i].Price;
                }

                let bondID=askInputs[i].TokenID;
                let quantityToTransfer=askInputs[i].QuantityMatch;

                token=bondTokensArray.filter(item=> item.ID===bondID)

                let bondOwner=token.Owner;

                if (usedOwners.indexOf(bondOwner)===-1){
                    usedOwners.push(bondOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    cashTokensToTransfer.push(quantityToTransfer*askInputs[i].Price);
                }else{
                    usedAmounts[usedOwners.indexOf(bondOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(bondOwner)]+=token.Amount;
                    cashTokensToTransfer[usedOwners.indexOf(bondOwner)]+=quantityToTransfer*askInputs[i].Price;
                }

                balance=askInputs[i].Quantity-askInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer
                }else{
                    total+=askInputs[i].Quantity
                }

                amount+=quantityToTransfer;

                bids=orderBook[0];
                asks=orderBook[1];
                if (askInputs[i].FullMatch){
                    let myAsk=await asks.filter(item=> item.ID!==askInputs[i].ID);
                    orderBook=[bids,myAsk,[referencePrice]]
                }else{
                    let myAsk=await asks.filter(item=> item.ID===askInputs[i].ID);
                    lastOwner=token.Owner;
                    lastAsk=myAsk[0];
                    lastAskQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;
                    lastAskQuantityMatch=0;
                    lastAskRestingQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;

                    // New token ID

                    usedKey=token.ID
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }
            let outputSecuritizationCoin={
                ID: '',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: '',
                Amount: '',
                Factor: 100,
                CanBeUsed: true
            }

            let cashAcumulator=0
            for (let j=0;j<usedOwners.length;j++){
                // //console.log('creamos estados tipo cash tokens')
                ////console.log(`creamos estados tipo cash tokens`)

                //TODO
                // check coupons received
                outputSecuritizationCoin.ID='securitizationCoin'+usedOwners[j]+outputSecuritizationCoin.GenericID+':0';
                outputSecuritizationCoin.Amount=usedAmounts[j];

                outputSecuritizationCoin.Owner=usedOwners[j];


                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                cashAcumulator+=outputSecuritizationCoin.Amount;
            }
            bids=orderBook[0];
            asks=orderBook[1];

            let bondToken1={
                ID: 'BondToken'+OwnerClientID+genericID+":0",
                GenericID: genericID,
                TypeID: ':0',
                Rating: token.Rating,
                CouponRate: token.CouponRate,
                MaturityDate: token.MaturityDate,
                Issuer: new_securitizationCoin.Issuer,
                Owner: new_securitizationCoin.Owner,
                Pool: token.Pool,
                AmountPaid: token.AmountPaid,
                FaceValue: token.FaceValue,
                MonthlyPayout: token.MonthlyPayout,
                RemainingPayments: token.RemainingPayments,
                NotBefore: token.NotBefore,
                CouponDates: token.CouponDates,
                CouponsReceived: token.CouponsReceived,
                Amount: amount,
                CanBeUsed: true
            }
            let valueBuffer1=Buffer.from(JSON.stringify(bondToken1))
            let restingQuantity=total-amount;
            if(restingQuantity!==0){
                let bondID='BondToken'+lastOwner+genericID+':1'
                let bondToken2={
                    ID: bondID,
                    GenericID: genericID,
                    TypeID: ':1',
                    Rating: token.Rating,
                    CouponRate: token.CouponRate,
                    MaturityDate: token.MaturityDate,
                    Issuer: new_securitizationCoin.Issuer,
                    Owner: new_securitizationCoin.Owner,
                    Pool: token.Pool,
                    AmountPaid: token.AmountPaid,
                    FaceValue: token.FaceValue,
                    MonthlyPayout: token.MonthlyPayout,
                    RemainingPayments: token.RemainingPayments,
                    Amount: restingQuantity,
                    CanBeUsed: false,
                    NotBefore: token.NotBefore,
                    CouponDates: token.CouponDates,
                    CouponsReceived: token.CouponsReceived
                }
                let indice=asks.indexOf(lastAsk)
                lastAsk.TokenID=bondID;
                lastAsk.QuantityMatch=lastAskQuantityMatch;
                lastAsk.RestingQuantity=lastAskRestingQuantity;
                lastAsk.Quantity=lastAskQuantity;
                lastAsk.PartialMatch=false;
                asks[indice]=lastAsk;
                orderBook=[bids,asks,[referencePrice]]

                let valueBuffer2=Buffer.from(JSON.stringify(bondToken2));
            }else{
                orderBook=[bids,asks,[referencePrice]]
                //console.log('ELSE')
            }

            asks=orderBook[1];
            bids=orderBook[0];

            if ((bidInput.Quantity-bidInput.QuantityMatch)!==0 && !bidInput.MarketPrice){
                outputSecuritizationCoin.ID='securitizationCoin'+OwnerClientID+genericID+':1';
                outputSecuritizationCoin.Amount=token.Amount-cashAcumulator;
                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                let thisBid=await bids.filter(item => item.ID===bidInput.ID);
                let index=bids.indexOf(thisBid[0]);
                thisBid[0].Quantity=thisBid[0].Quantity-thisBid[0].QuantityMatch;
                thisBid[0].QuantityMatch=0;
                thisBid[0].RestingQuantity=thisBid[0].Quantity;
                thisBid[0].TokenID=outputSecuritizationCoin.ID;
                bids[index]=thisBid[0];
                orderBook=[bids,asks,[referencePrice]]
                // await ctx.stub.deleteState(token.ID)
            }else if ((bidInput.Quantity-bidInput.QuantityMatch)===0 && !bidInput.MarketPrice){
                let thisBid=await bids.filter(item => item.ID!==bidInput.ID)
                orderBook=[thisBid,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-------------OrderBook Updated-----------------')
            //console.log(ret)
            //console.log('-----------------------------------------------')
            expect(ret).to.eql(orderBook)
        });
        it('Should return OrderBook. Case 5: bond tokens owned by different identities. Bid Order not MarketOrder and is PartialMatched', async () =>{
            let GenericID,TypeID,ID,Issuer,Owner,Amount,Factor,CanBeUsed;

            let TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time;

            let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,OriginalValue,MonthlyPayout,RemainingPayments;

            let secret;
            let Name;
            let securitizationCoinBuffer;
            let NewGenericID;

            let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

            let bondTokensArray=[];
            let cashTokensArray=[];
            // for creating hash ids
            secret='TutorialsPoint';

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')

            date=new Date()
            argDate=date.toUTCString();


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');


            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };



            orderID="BidOrder"+genericID;

            // create a full-of-orders order book
            let orderArray=[];
            let token

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();


                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let GenericOwnerClientID="12345678A";
            // ASKS
            price=111.20;
            let quantityMatch=0
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"


                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.Factor=Factor;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates,
                bondToken.CouponsReceived=BondToken.CouponsReceived,
                bondToken.NotBefore=BondToken.NotBefore

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                if (price>=Price){
                    quantityMatch+=Quantity
                }
            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);
            OwnerClientID="12345678A"

            //search for a match (BID matches several ASKS)=> BidOrder
            amount=quantityMatch+1;
            price=111.20;

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString()).digest('hex')
            // genericID=GenericID
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:false,
            }

            //mock cash token state
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

            // current order is a bid order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            let asks=orderBook[1];

            let bidReference=currentOrder;
            // "Match Engine" obtained from BidOrder Function
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            // check if there is matching
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }

            orderBook=[orderBook[0],asks,orderBook[2]]



            // let newID=await this._splitMoney(ctx,token.ID,total);
            if (myTokens===bidReference.Quantity){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // No match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }

            orderBook[0].push(currentOrder);

            const orderMatch={
                Orders: tokenAcumulator,
                Order: currentOrder,
            }

            mockStub.getTxID.returns(genericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);

            let ret=await contract._transferBondTokens(ctx,orderMatch.Orders,orderMatch.Order,orderBook)


            const orderBookInputVersion=orderBook

            let bids=orderBook[0];
            let askInputs=tokenAcumulator;

            let bidInput=currentOrder;
            let lastAsk;
            let lastAskQuantity;
            let lastAskQuantityMatch;
            let lastAskRestingQuantity
            let usedKeys=[];
            let usedKey, lastOwner;
            let usedOwners=[];
            let usedAmounts=[];
            let notUsedTokensAmounts=[];
            let cashTokensToTransfer=[];
            let total=0;
            let thisAsk;
            // let lastOwner
            let bondsToTransfer=[];
            amount=0;
            let referencePrice

            if(bidInput.Price===''){
                referencePrice=askInputs[0].Price;
            }else{
                referencePrice=askInputs[0].Price
            }

            for (let i=0; i<askInputs.length;i++){
                if (referencePrice<askInputs[i].Price){
                    referencePrice=askInputs[i].Price;
                }

                let bondID=askInputs[i].TokenID;
                let quantityToTransfer=askInputs[i].QuantityMatch;

                token=bondTokensArray.filter(item=> item.ID===bondID)

                let bondOwner=token.Owner;

                if (usedOwners.indexOf(bondOwner)===-1){
                    usedOwners.push(bondOwner);
                    usedAmounts.push(quantityToTransfer);
                    notUsedTokensAmounts.push(token.Amount);
                    cashTokensToTransfer.push(quantityToTransfer*askInputs[i].Price);
                }else{
                    usedAmounts[usedOwners.indexOf(bondOwner)]+=quantityToTransfer;
                    notUsedTokensAmounts[usedOwners.indexOf(bondOwner)]+=token.Amount;
                    cashTokensToTransfer[usedOwners.indexOf(bondOwner)]+=quantityToTransfer*askInputs[i].Price;
                }

                balance=askInputs[i].Quantity-askInputs[i].QuantityMatch
                if (balance===0){
                    total+=quantityToTransfer
                }else{
                    total+=askInputs[i].Quantity
                }

                amount+=quantityToTransfer;

                bids=orderBook[0];
                asks=orderBook[1];
                if (askInputs[i].FullMatch){
                    let myAsk=await asks.filter(item=> item.ID!==askInputs[i].ID);
                    orderBook=[bids,myAsk,[referencePrice]]
                }else{
                    let myAsk=await asks.filter(item=> item.ID===askInputs[i].ID);
                    lastOwner=token.Owner;
                    lastAsk=myAsk[0];
                    lastAskQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;
                    lastAskQuantityMatch=0;
                    lastAskRestingQuantity=lastAsk.Quantity-lastAsk.QuantityMatch;

                    // New token ID

                    usedKey=token.ID
                    orderBook=[bids,asks,[referencePrice]]
                }
                usedKeys.push(token.ID);
            }
            let outputSecuritizationCoin={
                ID: '',
                GenericID: genericID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: '',
                Amount: '',
                Factor: 100,
                CanBeUsed: true
            }

            let cashAcumulator=0
            for (let j=0;j<usedOwners.length;j++){
                // //console.log('creamos estados tipo cash tokens')
                ////console.log(`creamos estados tipo cash tokens`)

                //TODO
                // check coupons received
                outputSecuritizationCoin.ID='securitizationCoin'+usedOwners[j]+outputSecuritizationCoin.GenericID+':0';
                outputSecuritizationCoin.Amount=usedAmounts[j];

                outputSecuritizationCoin.Owner=usedOwners[j];


                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                cashAcumulator+=outputSecuritizationCoin.Amount;
            }
            bids=orderBook[0];
            asks=orderBook[1];

            let bondToken1={
                ID: 'BondToken'+OwnerClientID+genericID+":0",
                GenericID: genericID,
                TypeID: ':0',
                Rating: token.Rating,
                CouponRate: token.CouponRate,
                MaturityDate: token.MaturityDate,
                Issuer: new_securitizationCoin.Issuer,
                Owner: new_securitizationCoin.Owner,
                Pool: token.Pool,
                AmountPaid: token.AmountPaid,
                FaceValue: token.FaceValue,
                MonthlyPayout: token.MonthlyPayout,
                RemainingPayments: token.RemainingPayments,
                NotBefore: token.NotBefore,
                CouponDates: token.CouponDates,
                CouponsReceived: token.CouponsReceived,
                Amount: amount,
                CanBeUsed: true
            }
            let valueBuffer1=Buffer.from(JSON.stringify(bondToken1))
            let restingQuantity=total-amount;
            if(restingQuantity!==0){
                let bondID='BondToken'+lastOwner+genericID+':1'
                let bondToken2={
                    ID: bondID,
                    GenericID: genericID,
                    TypeID: ':1',
                    Rating: token.Rating,
                    CouponRate: token.CouponRate,
                    MaturityDate: token.MaturityDate,
                    Issuer: new_securitizationCoin.Issuer,
                    Owner: new_securitizationCoin.Owner,
                    Pool: token.Pool,
                    AmountPaid: token.AmountPaid,
                    FaceValue: token.FaceValue,
                    MonthlyPayout: token.MonthlyPayout,
                    RemainingPayments: token.RemainingPayments,
                    Amount: restingQuantity,
                    CanBeUsed: false,
                    NotBefore: token.NotBefore,
                    CouponDates: token.CouponDates,
                    CouponsReceived: token.CouponsReceived
                }
                let indice=asks.indexOf(lastAsk)
                lastAsk.TokenID=bondID;
                lastAsk.QuantityMatch=lastAskQuantityMatch;
                lastAsk.RestingQuantity=lastAskRestingQuantity;
                lastAsk.Quantity=lastAskQuantity;
                lastAsk.PartialMatch=false;
                asks[indice]=lastAsk;
                orderBook=[bids,asks,[referencePrice]]

                let valueBuffer2=Buffer.from(JSON.stringify(bondToken2));
            }else{
                orderBook=[bids,asks,[referencePrice]]
                // //console.log('ELSE')
            }

            asks=orderBook[1];
            bids=orderBook[0];

            if ((bidInput.Quantity-bidInput.QuantityMatch)!==0 && !bidInput.MarketPrice){
                outputSecuritizationCoin.ID='securitizationCoin'+OwnerClientID+genericID+':1';
                outputSecuritizationCoin.Amount=token.Amount-cashAcumulator;
                let outputSecuritizationCoinBuffer= Buffer.from(JSON.stringify(outputSecuritizationCoin))
                // await ctx.stub.putState(outputSecuritizationCoin.ID,outputSecuritizationCoinBuffer)
                let thisBid=await bids.filter(item => item.ID===bidInput.ID);
                let index=bids.indexOf(thisBid[0]);
                thisBid[0].Quantity=thisBid[0].Quantity-thisBid[0].QuantityMatch;
                thisBid[0].QuantityMatch=0;
                thisBid[0].RestingQuantity=thisBid[0].Quantity;
                thisBid[0].TokenID=outputSecuritizationCoin.ID;
                bids[index]=thisBid[0];
                orderBook=[bids,asks,[referencePrice]]
                // await ctx.stub.deleteState(token.ID)
            }else if ((bidInput.Quantity-bidInput.QuantityMatch)===0 && !bidInput.MarketPrice){
                let thisBid=await bids.filter(item => item.ID!==bidInput.ID)
                orderBook=[thisBid,asks,[referencePrice]]
            }else{
                orderBook=[bids,asks,[referencePrice]]
            }
            //console.log('-------------OrderBook Updated-----------------')
            //console.log(ret)
            //console.log('-----------------------------------------------')
            expect(ret).to.eql(orderBook)

        });
    })
    describe('TESTING: AskOrder', () =>{
        let tokenID;
        let typeID;
        let amount,price;
        let FunctionAndParameters;
        let secret="mySecret"
        let BondToken;
        let monthlyPayout,PoolID;
        let TransactionID;
        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;
        let argTodayDate;
        let genericID;
        let currentOrder;
        let OrderBook


        let orderArray=[];
        async function sortingAskOrders(orderArray){
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }

        let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? -1 : 1));
            return orderArray.reverse()
        }




        beforeEach(() => {
            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";

            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            todayDate=new Date();
            argTodayDate=todayDate.toUTCString();
            mockStub.getDateTimestamp.returns(argTodayDate);
            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex');
            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            FunctionAndParameters={
                fcn: 'AskOrder',
                params: [amount,price,BondToken.GenericID,BondToken.TypeID]
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters)
        })
        it('Should throw an error if user is not a client', async ()=>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            // mockStub.getState.withArgs(new_BondToken.ID).returns(Buffer.from(JSON.stringify(new_BondToken)))
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('AskOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty string ',async ()=>{
            FunctionAndParameters.params=[amount,'',BondToken.GenericID,BondToken.TypeID]
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('AskOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter that should not be`)
            }
        })
        it('Should throw an error if user is neither a SPV nor an Investor member', async () =>{
            let wrong_OrgMSP="originatorMSP"
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('AskOrder should throw an Error');
            }catch(err){
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        });
        it('Should throw an error if format is not OK',async ()=>{
            // we know _checkDecimals works as expected.
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskOrder(ctx,amount,"123,124",BondToken.ID,BondToken.TypeID);
                assert.fail('AskOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Wrong format. Try using dot instead of comma`)
            }
        })
        it('Should throw an error if format is not OK',async ()=>{
            // we know _checkDecimals works as expected.
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskOrder(ctx,amount,"-123.12",BondToken.ID,BondToken.TypeID);
                assert.fail('AskOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Number must be strictly positive`)
            }
        })
        it('Should throw an error if Bond Token does not exist',async ()=>{
            // we know _checkDecimals works as expected.
            sinon.stub(contract,'_checkDecimals').returns(true);
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskOrder(ctx,amount,price,BondToken.GenericID,BondToken.TypeID);
                assert.fail('AskOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Error, Bond State with ID ${BondToken.GenericID} does not exist`)
            }
        })
        it('Should throw an error if Bond Token exists  but cannot be used',async ()=>{
            BondToken.CanBeUsed=false;
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))
            sinon.stub(contract,'_checkDecimals').returns(true);
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskOrder(ctx,amount,price,BondToken.GenericID,BondToken.TypeID);
                assert.fail('AskOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`This Bond State with ID ${BondToken.GenericID} has already been used. Try another Bond ID`)
            }
        })
        it('Should throw an error if Bond Token exists it does not have enough funds',async ()=>{
            BondToken.Amount=1
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))
            sinon.stub(contract,'_checkDecimals').returns(true);
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskOrder(ctx,amount,price,BondToken.GenericID,BondToken.TypeID);
                assert.fail('AskOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Bond Token amount not enough.`)
            }
        })
        it('Case 1: ORDER BOOK does not exist=> no asks and no bids=> no matching => just update order book',async ()=>{
            let orderID="AskOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()
            };

            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))



            // OrderBook must include AskOrder
            OrderBook=[[],[],[]];

            // And input BondToken should be splitted

            let test_amount= "10"
            let test_price="110.20"

            let NewBondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: BondToken.Issuer,
                Owner: BondToken.Owner,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: parseInt(test_amount),
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitBonds').returns(NewBondToken.ID);
            sinon.stub(contract,'_sortingAskOrders').returns(OrderBook[1])
            OrderBook[1].push(currentOrder);
            await contract.beforeTransaction(ctx);

            let ret=await contract.AskOrder(ctx,test_amount,test_price,BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 2: ORDER BOOK exists but no bids => no matching => just update order book',async ()=>{
            let oldGenericID=crypto.createHash('sha256', secret).update("oldGenericID").digest('hex')
            let test_amount= "10"
            let test_price="110.20"

            let orderID="AskOrder"+oldGenericID
            let lastOrder={
                ID: orderID,
                Quantity: parseInt(test_amount)-2,
                Price: parseInt(parseFloat(test_price)*100)-10,
                TokenID: 'BondToken'+OwnerClientID+oldGenericID+':0',
                FullMatch: false,
                PartialMatch: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount)-2,
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()-1240
            };

            orderID="AskOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(test_amount),
                Price: parseInt(test_price)*100,
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount),
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()
            };




            OrderBook=[[],[lastOrder],[]];

            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))



            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))




            // And input BondToken should be splitted



            let NewBondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: BondToken.Issuer,
                Owner: BondToken.Owner,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: parseInt(test_amount),
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitBonds').returns(NewBondToken.ID);
            sinon.stub(contract,'_sortingAskOrders').returns(OrderBook[1])
            OrderBook[1].push(currentOrder);
            await contract.beforeTransaction(ctx);

            OrderBook[1].push(currentOrder);
            await contract.beforeTransaction(ctx);
            let ret=await contract.AskOrder(ctx,test_amount,test_price,BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 3: There is at least one Bid and one Ask but no Match',async ()=>{
            price=105.12
            amount=100
            let FakeInvestorClientID="12345678L"
            let BidTransactionID=crypto.createHash('sha256', secret).update("BidOrderGenericID").digest('hex')
            let BidOrder={
                ID: 'BidOrder'+TransactionID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: 'securitizationCoin'+FakeInvestorClientID+BidTransactionID+':0',
                Name: 'Bid',
                FullMatch: false,
                MarketPrice: false,
                PartialMatch: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Time: new Date(argTodayDate)-40000
            };

            let oldGenericID=crypto.createHash('sha256', secret).update("oldGenericID").digest('hex')
            let test_amount= "10"
            let test_price="110.20"
            let orderID="AskOrder"+oldGenericID
            let lastOrder={
                ID: orderID,
                Quantity: parseInt(test_amount)-2,
                Price: parseInt(parseFloat(test_price)*100)-10,
                TokenID: 'BondToken'+OwnerClientID+oldGenericID+':0',
                FullMatch: false,
                PartialMatch: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount)-2,
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()-1240
            };

            orderID="AskOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(test_amount),
                Price: parseInt(test_price)*100,
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount),
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()
            };




            OrderBook=[[BidOrder],[lastOrder],[]];

            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))



            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))



            // And input BondToken should be splitted



            let NewBondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: BondToken.Rating,
                CouponRate: BondToken.CouponRate,
                MaturityDate: BondToken.MaturityDate,
                Issuer: BondToken.Issuer,
                Owner: BondToken.Owner,
                Pool: BondToken.Pool,
                AmountPaid: BondToken.AmountPaid,
                FaceValue: BondToken.FaceValue,
                MonthlyPayout: BondToken.MonthlyPayout,
                CouponDates: BondToken.CouponDates,
                CouponsReceived: BondToken.CouponsReceived,
                RemainingPayments: BondToken.RemainingPayments,
                Amount: parseInt(test_amount),
                CanBeUsed: true,
                NotBefore: BondToken.NotBefore
            }

            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitBonds').returns(NewBondToken.ID);
            // sinon.stub(contract,'_sortingAskOrders').returns(OrderBook[1])
            OrderBook=[[BidOrder],[lastOrder,currentOrder],[]];
            sinon.stub(contract,'_sortingAskOrders').returns(OrderBook[1])
            sinon.stub(contract,'_sortingBidOrders').returns(OrderBook[0]);

            await contract.beforeTransaction(ctx);

            let ret=await contract.AskOrder(ctx,test_amount,test_price,BondToken.GenericID,BondToken.TypeID);

            expect(ret).to.eql(OrderBook);
        })
        it('Case 4:  There is Match. Ask Order partial matched',async ()=>{
            let GenericID,ID,NewGenericID,TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time,Name;
            let TypeID,Issuer,Owner,Amount,Factor,CanBeUsed;
            let securitizationCoinBuffer
            let cashTokensArray=[]
            let bondTokensArray=[]
            let new_BondToken;
            let argDate;
            let NewBondToken

            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            // comparador is the lower Bound
            let comparador=100.00
            let GenericOwnerClientID="12345678A"
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString();
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                // mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
                if(Price>comparador){
                    comparador=Price
                }

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            // ASKS
            GenericOwnerClientID="12345678B"
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString();
                GenericID=crypto.createHash('sha256', secret).update('Ask'+i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;


                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore


                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            let orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(orderBook)))
            // currently asks  \in (110.10,115.05) and bids \in (100.00,110.05)

            price=comparador;
            amount=1000;
            BondToken.Amount=amount+1
            let orderID="AskOrder"+genericID;

            // Amount should be enough bid to not full matched ask order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()
            };
            bondTokensArray.push(BondToken)

            // with a bond token: //non split bond token because it matched

            // "search engine"
            let bids=orderBook[0];

            const askReference=currentOrder;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let counter=askReference.Quantity;
            let totalTokens=0;
            let balance=0;
            let myTokens=0;
            let referencePrice=0
            // Check if our order can be matched
            for await (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                        referencePrice=bid.Price
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        bid.Quantity=bid.Quantity-balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                        referencePrice=bid.Price
                    }
                }else{
                    continue
                }
            }

            orderBook=[bids,orderBook[1],[referencePrice]]

            if (myTokens===askReference.Quantity){
                // Full Match
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0 ){
                // Partial Match
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
            }else{
                // No match
                // newID=await this._splitBonds(ctx,bond.ID,amount);
                // //console.log('paso 5.3')
                // BondToken must be splitted
                currentOrder.TokenID="emptyArray";
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }

            orderBook[1].push(currentOrder);


            // BondToken splitted should be such that NewBondToken.Amount=Quantity-QuantityMatch
            // //console.log('currentOrder.QuantityMatch')
            // //console.log(currentOrder.QuantityMatch)
            // NewBondToken= BondToken;
            NewBondToken=Object.assign({}, BondToken );
            NewBondToken.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            // let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewBondToken.GenericID=genericID;
            NewBondToken.ID='BondToken'+NewBondToken.Owner+NewBondToken.GenericID+':1';
            NewBondToken.TypeID=':1'

            // we have to mock our "delivery v. payment" function, namely _transferCashTokens

            // this function has to return the updated orderbook, i.e, with tokens IDs updates, resting quantities,
            // quantity match

            // As we know this function performs OK we just return this updated orderBook
            let asks=orderBook[1];
            bids=orderBook[0];
            orderBook[2]=[referencePrice]
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            // and update those orders partial matched
            let newPartialBids=await newBids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await newAsks.filter(item=> item.PartialMatch===true)
            let index;
            let bondOutputKey;
            for (let t=0; t<newPartialAsks.length;t++){
                // //console.log('newPartialAsks')
                index=newAsks.indexOf(newPartialAsks[t])

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity

                // let newBondToken=await bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                // newBondToken[0].Amount=newBondToken[0].Amount-(newPartialAsks[t].QuantityMatch*newPartialAsks[t].Price);
                // newBondToken[0].GenericID=genericID;
                // newBondToken[0].ID='BondToken'+newBondToken[0].Owner+genericID+':1';
                // bondOutputKey=newBondToken[0].ID
                newPartialAsks[t].TokenID=NewBondToken.ID
                newAsks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                // //console.log('newPartialBids')
                index=newBids.indexOf(newPartialBids[l])

                newPartialBids[l].PartialMatch=false;
                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                let newSecuritizationCoin=await cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID;
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+genericID+':0';
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newBids[index]=newPartialBids[l]
            }


            let newOrderBook=[newBids,newAsks,orderBook[2]];


            mockStub.createCompositeKey.withArgs('BondToken',[BondToken.Owner,BondToken.GenericID]).returns('BondToken'+BondToken.Owner+BondToken.GenericID)
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))

            //console.log('---------------BondToken--------------------')
            //console.log(BondToken)
            // sinon.stub(contract,'_transferCashTokens').returns(newOrderBook);

            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitBonds').returns(bondOutputKey);

            await contract.beforeTransaction(ctx);
            let ret=await contract.AskOrder(ctx,amount.toString(),price,BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(newOrderBook);
        })
        it('Case 5:  There is Match. Ask Order Full matched',async ()=>{
            let GenericID,ID,NewGenericID,TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time,Name;
            let TypeID,Issuer,Owner,Amount,Factor,CanBeUsed;
            let securitizationCoinBuffer
            let cashTokensArray=[]
            let bondTokensArray=[]
            let new_BondToken;
            let argDate;
            let NewBondToken

            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)



            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            // comparador is the lower Bound
            orderArray=[];
            let comparador=100.00
            let GenericOwnerClientID="12345678A"
            let thisAmount=0
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString();
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                // mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
                if(Price>comparador){
                    comparador=Price
                    thisAmount=Quantity
                }
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            // ASKS
            GenericOwnerClientID="12345678B"
            for (let i=0;i<100;i++){

                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString();
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                Factor=100;
                CanBeUsed=true;


                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore


                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            let orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(orderBook)))
            // currently asks  \in (110.10,115.05) and bids \in (100.00,110.05)

            price=comparador;
            amount=thisAmount;
            let orderID="AskOrder"+genericID;

            // Amount should be enough bid to not full matched ask order
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Ask',
                Time: new Date(argDate).getTime()
            };


            // with a bond token: //non split bond token because it matched

            // "search engine"
            let bids=orderBook[0];

            const askReference=currentOrder;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let counter=askReference.Quantity;
            let totalTokens=0;
            let balance=0;
            let myTokens=0;
            let referencePrice
            // Check if our order can be matched
            for await (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                        referencePrice=bid.Price
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        bid.Quantity=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                        referencePrice=bid.Price
                    }
                }else{
                    continue
                }
            }

            orderBook=[bids,orderBook[1],orderBook[2]]


            if (myTokens===askReference.Quantity){
                // Full Match
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0 ){
                // Partial Match
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
            }else{
                // No match
                // newID=await this._splitBonds(ctx,bond.ID,amount);
                // //console.log('paso 5.3')
                // BondToken must be splitted
                currentOrder.TokenID="emptyArray";
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }

            orderBook[1].push(currentOrder);



            // mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            // mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))

            // BondToken splitted should be such that NewBondToken.Amount=Quantity-QuantityMatch
            // BondToken splitted should be such that NewBondToken.Amount=Quantity-QuantityMatch
            // //console.log('currentOrder.QuantityMatch')
            // //console.log(currentOrder.QuantityMatch)
            // NewBondToken= BondToken;
            NewBondToken=Object.assign({}, BondToken );
            NewBondToken.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            // let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewBondToken.GenericID=genericID;
            NewBondToken.ID='BondToken'+BondToken.Owner+NewBondToken.GenericID+':1';
            NewBondToken.TypeID=':1'

            // we have to mock our "delivery v. payment" function, namely _transferCashTokens

            // this function has to return the updated orderbook, i.e, with tokens IDs updates, resting quantities,
            // quantity match

            // As we know this function performs OK we just return this updated orderBook
            let asks=orderBook[1];
            bids=orderBook[0];
            orderBook[2]=[referencePrice]
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            // and update those orders partial matched
            let newPartialBids=await newBids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await newAsks.filter(item=> item.PartialMatch===true)
            //console.log('----------newPartialAsks------------------')
            //console.log(newPartialAsks)
            //console.log('------------------------------------')
            //console.log('----------newPartialBids------------------')
            //console.log(newPartialBids)
            //console.log('----------------------------------')
            let index;
            let bondOutputKey;

            for (let t=0; t<newPartialAsks.length;t++){
                // //console.log('newPartialAsks')
                index=newAsks.indexOf(newPartialAsks[t])


                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity

                // let newBondToken=await bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                // newBondToken[0].Amount=newBondToken[0].Amount-(newPartialAsks[t].QuantityMatch*newPartialAsks[t].Price);
                // newBondToken[0].GenericID=genericID;
                // newBondToken[0].ID='BondToken'+newBondToken[0].Owner+genericID+':1';
                // bondOutputKey=newBondToken[0].ID
                newPartialAsks[t].TokenID=NewBondToken.ID
                newAsks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                // //console.log('newPartialBids')
                index=newBids.indexOf(newPartialBids[l])

                newPartialBids[l].PartialMatch=false;
                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                let newSecuritizationCoin=await cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                //console.log('----------NewSecuritizationCoin------------')
                //console.log(newSecuritizationCoin)
                //console.log('-------------------------------')
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID;
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+genericID+':1';
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newBids[index]=newPartialBids[l]
            }


            let newOrderBook=[newBids,newAsks,orderBook[2]];


            mockStub.createCompositeKey.withArgs('BondToken',[BondToken.Owner,BondToken.GenericID]).returns('BondToken'+BondToken.Owner+BondToken.GenericID)
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))


            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitBonds').returns(NewBondToken.ID);


            await contract.beforeTransaction(ctx);
            let ret=await contract.AskOrder(ctx,amount.toString(),price,BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(newOrderBook);
        })
        it('Case 6:  There is Match. Ask Order Full matched and BidOrder PartialMatched',async ()=>{
            // lets create our order book full of bids and asks
            let GenericID,ID,NewGenericID,TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity,Time,Name;
            let TypeID,Issuer,Owner,Amount,Factor,CanBeUsed;
            let securitizationCoinBuffer
            let cashTokensArray=[]
            let bondTokensArray=[]
            let new_BondToken;
            let argDate;
            let NewBondToken

            // create a full-of-orders order book

            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            let orderArray=[];
            let token

            let orderID='AskOrder' +genericID
            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            orderArray=[];
            // BIDS
            price=108.00;
            let quantityMatched=0
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+'BidOrder').digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(2,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)


                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

                if (price<=Price){
                    quantityMatched+=Quantity
                }

            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            // ASKS
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+'AskOrder').digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                // //console.log(TokenID)

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                // Time=(comp>0.5) ? todayDate.getTime()+(Quantity*100) :todayDate.getTime()-(Quantity*100)
                // FullMatch=(comp>0.9) ? true :false
                // MarketPrice=(comp>0.99) ? true :false
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;


                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates
                bondToken.NotBefore=BondToken.NotBefore
                bondToken.CouponsReceived=BondToken.CouponsReceived

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            let orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]

            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(orderBook)))
            // currently asks  \in (110.10,115.05) and bids \in (100.00,110.05)

            // amount should be as small as a bid order quantity
            amount=quantityMatched-1;

            BondToken.Amount=amount+10
            currentOrder={
                ID: orderID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Ask',
                Time: new Date(todayDate).getTime()
            };

            //console.log('-------------currentOrder---------------')
            //console.log(currentOrder)
            // with a bond token: //non split bond token because it matched

            // "search engine"
            let bids=orderBook[0];

            const askReference=currentOrder;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let counter=askReference.Quantity;
            let totalTokens=0;
            let balance=0;
            let myTokens=0;
            let referencePrice
            // Check if our order can be matched
            for await (const bid of bids) {
                if (bid.Price>=askReference.Price && !bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                        referencePrice=bid.Price
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        bid.Quantity=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                        referencePrice=bid.Price
                    }
                }else{
                    continue
                }
            }

            orderBook=[bids,orderBook[1],orderBook[2]]


            if (myTokens===askReference.Quantity){
                // Full Match
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
            }else if(myTokens<askReference.Quantity && myTokens!==0 ){
                // Partial Match
                currentOrder.TokenID=BondToken.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
            }else{
                // No match
                // newID=await this._splitBonds(ctx,bond.ID,amount);
                // //console.log('paso 5.3')
                // BondToken must be splitted
                currentOrder.TokenID="emptyArray";
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= false;
            }

            orderBook[1].push(currentOrder);



            // mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            // mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))

            // BondToken splitted should be such that NewBondToken.Amount=Quantity-QuantityMatch
            // BondToken splitted should be such that NewBondToken.Amount=Quantity-QuantityMatch
            // //console.log('currentOrder.QuantityMatch')
            // //console.log(currentOrder.QuantityMatch)
            // NewBondToken= BondToken;
            NewBondToken=Object.assign({}, BondToken );
            NewBondToken.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            // let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewBondToken.GenericID=genericID;
            NewBondToken.ID='BondToken'+BondToken.Owner+NewBondToken.GenericID+':1';
            NewBondToken.TypeID=':1'

            // we have to mock our "delivery v. payment" function, namely _transferCashTokens

            // this function has to return the updated orderbook, i.e, with tokens IDs updates, resting quantities,
            // quantity match

            // As we know this function performs OK we just return this updated orderBook
            let asks=orderBook[1];
            bids=orderBook[0];
            orderBook[2]=[referencePrice]
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            // and update those orders partial matched
            let newPartialBids=await newBids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await newAsks.filter(item=> item.PartialMatch===true)
            //console.log('----------newPartialAsks------------------')
            //console.log(newPartialAsks)
            //console.log('------------------------------------')
            //console.log('----------newPartialBids------------------')
            //console.log(newPartialBids)
            //console.log('----------------------------------')
            let index;
            let bondOutputKey;

            for (let t=0; t<newPartialAsks.length;t++){
                // //console.log('newPartialAsks')
                index=newAsks.indexOf(newPartialAsks[t])


                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity

                // let newBondToken=await bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                // newBondToken[0].Amount=newBondToken[0].Amount-(newPartialAsks[t].QuantityMatch*newPartialAsks[t].Price);
                // newBondToken[0].GenericID=genericID;
                // newBondToken[0].ID='BondToken'+newBondToken[0].Owner+genericID+':1';
                // bondOutputKey=newBondToken[0].ID
                newPartialAsks[t].TokenID=NewBondToken.ID
                newAsks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                // //console.log('newPartialBids')
                index=newBids.indexOf(newPartialBids[l])

                newPartialBids[l].PartialMatch=false;
                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                let newSecuritizationCoin=await cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                //console.log('----------NewSecuritizationCoin------------')
                //console.log(newSecuritizationCoin)
                //console.log('-------------------------------')
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID;
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+genericID+':1';
                //console.log('----------NewSecuritizationCoin------------')
                //console.log(newSecuritizationCoin)
                //console.log('-------------------------------')
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newBids[index]=newPartialBids[l]
            }


            let newOrderBook=[newBids,newAsks,orderBook[2]];


            mockStub.createCompositeKey.withArgs('BondToken',[BondToken.Owner,BondToken.GenericID]).returns('BondToken'+BondToken.Owner+BondToken.GenericID)
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))


            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitBonds').returns(NewBondToken.ID);


            await contract.beforeTransaction(ctx);
            let ret=await contract.AskOrder(ctx,amount.toString(),price,BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(newOrderBook);
        })

    })
    describe('TESTING: BidOrder', () =>{
        let genericID;
        let tokenID;
        let typeID;
        let amount,price,bondID,identificativo,date,argDate;
        let FunctionAndParameters;
        let wrong_OrgMSP;
        let OrderBook;
        let currentOrder;
        let orderID;
        // let currentTime
        let new_securitizationCoin,securitizationCoin1,securitizationCoin2
        let bondTokensArray=[]

        let GenericID,ID,NewGenericID,TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity
        let Time,Name

        let TypeID,Issuer,Owner,Amount,Factor,CanBeUsed;

        let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,OriginalValue,MonthlyPayout,RemainingPayments;

        let secret="mySecret"
        let todayDate=new Date();
        let securitizationCoinBuffer
        let cashTokensArray=[]

        let orderBook;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

        let monthlyPayout,PoolID,TransactionID,BondToken;
        let securitizationCoinID
        let argTodayDate
        let securitizationCoin
        let test_amount,test_price

        let orderArray=[];
        async function sortingAskOrders(orderArray){
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }

        // let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? -1 : 1));
            return orderArray.reverse()
        }
        beforeEach(() => {

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";
            price="110.12"

            //lets suppose test_amount is less than amount
            test_amount="10"
            test_price=price

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')
            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            securitizationCoinID=crypto.createHash('sha256', secret).update("securitizationCoinID").digest('hex');
            securitizationCoin={
                ID:'securitizationCoin'+OwnerClientID+securitizationCoinID+':0',
                GenericID: securitizationCoinID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: Amount,
                Factor: 100,
                CanBeUsed: true
            }
            todayDate=new Date();
            argTodayDate=todayDate.toUTCString();

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex');

            mockStub.getDateTimestamp.returns(argTodayDate);
            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,securitizationCoinID]).returns('securitizationCoin'+OwnerClientID+securitizationCoinID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            FunctionAndParameters={
                fcn: 'BidOrder',
                params: [amount,price,securitizationCoin.GenericID,securitizationCoin.TypeID]
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters)
        })
        it('Should throw an error if user is not a client', async ()=>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('BidOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty ',async ()=>{
            FunctionAndParameters.params=[amount,'',securitizationCoin.GenericID,securitizationCoin.TypeID]
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('BidOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter that should not be`)
            }
        })
        it('Should throw an error if user is neither a SPV nor an Investor member', async () =>{
            let wrong_OrgMSP="originatorMSP"
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('BidOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        });
        it('Should throw an error if format is not OK',async ()=>{
            // we know _checkDecimals works as expected.
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidOrder(ctx,amount,"123,124",securitizationCoin.ID,securitizationCoin.TypeID);
                assert.fail('BidOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Wrong format. Try using dot instead of comma`)
            }
        })
        it('Should throw an error if format is not OK',async ()=>{
            // we know _checkDecimals works as expected.
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidOrder(ctx,amount,"123.124",securitizationCoin.ID,securitizationCoin.TypeID);
                assert.fail('BidOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Wrong decimals`)
            }
        })
        it('Should throw an error if format is not OK',async ()=>{
            // we know _checkDecimals works as expected.
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidOrder(ctx,amount,"-123.12",securitizationCoin.ID,securitizationCoin.TypeID);
                assert.fail('BidOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Number must be strictly positive`)
            }
        })
        it('Should throw an error if securitizationCoin does not exist',async ()=>{
            // we know _checkDecimals works as expected.
            sinon.stub(contract,'_checkDecimals').returns(true);
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidOrder(ctx,amount,price,securitizationCoin.GenericID,securitizationCoin.TypeID);
                assert.fail('BidOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Error, Token State according to key ${securitizationCoin.GenericID} does not exist`)
            }
        })
        it('Should throw an error if securitizationCoin exists  but cannot be used',async ()=>{
            securitizationCoin.CanBeUsed=false;
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidOrder(ctx,amount,price,securitizationCoin.GenericID,securitizationCoin.TypeID);
                assert.fail('BidOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`This Token State with ID ${securitizationCoin.GenericID} has already been used. Try another Token ID`)
            }
        })
        it('Case 1: ORDER BOOK does not exist=> no asks and no bids=> no matching => just update order book',async ()=>{
            let orderID="BidOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(test_amount),
                Price: parseInt(parseFloat(test_price)*100),
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount),
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };


            let newSecuritizationCoin=Object.assign({}, securitizationCoin );
            let newSecuritizationCoinID=crypto.createHash('sha256', secret).update("newSecuritizationCoinID").digest('hex');
            newSecuritizationCoin.Amount=securitizationCoin.Amount-parseInt(parseFloat(test_price)*parseInt(test_amount)*100);
            newSecuritizationCoin.GenericID=newSecuritizationCoinID;
            newSecuritizationCoin.ID='securitizationCoin'+newSecuritizationCoin.Owner+newSecuritizationCoin.GenericID+':0';

            OrderBook=[[],[],[]];
            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitMoney').returns(newSecuritizationCoin.ID);
            // sinon.stub(contract,'_sortingBidOrders').returns(OrderBook[0])
            currentOrder.TokenID=newSecuritizationCoin.ID
            OrderBook[0].push(currentOrder);

            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))

            await contract.beforeTransaction(ctx);
            let ret=await contract.BidOrder(ctx,test_amount,test_price,securitizationCoin.GenericID,securitizationCoin.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 2: ORDER BOOK exists but without asks => no matching => just update order book',async ()=>{

            let lastSecuritizationCoin=Object.assign({},securitizationCoin);
            let lastSecuritizationCoinID=crypto.createHash('sha256', secret).update("lastSecuritizationCoinID").digest('hex');
            lastSecuritizationCoin.ID='securitizationCoin'+OwnerClientID+lastSecuritizationCoinID+':0';


            let lastOrderID=crypto.createHash('sha256', secret).update("lastOrderID").digest('hex');
            let orderID="BidOrder"+lastOrderID
            let lastOrder={
                ID: orderID,
                Quantity: parseInt(test_amount)-2,
                Price: parseInt(parseFloat(test_price)*100),
                TokenID: lastSecuritizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice:false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount)-2,
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()-1240
            };

            lastSecuritizationCoin.Amount=lastOrder.Quantity*lastOrder.Price;
            lastSecuritizationCoin.CanBeUsed=false;
            lastSecuritizationCoin.GenericID=lastSecuritizationCoinID;
            mockStub.putState(lastSecuritizationCoin.ID,Buffer.from(JSON.stringify(lastSecuritizationCoin)));

            OrderBook=[[lastOrder],[],[]];
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))

            orderID="BidOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(test_amount),
                Price: parseInt(parseFloat(test_price)*100),
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount),
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };

            let newSecuritizationCoin=Object.assign({}, securitizationCoin );
            let newSecuritizationCoinID=crypto.createHash('sha256', secret).update("newSecuritizationCoinID").digest('hex');
            newSecuritizationCoin.Amount=securitizationCoin.Amount-parseInt(parseFloat(test_price)*parseInt(test_amount)*100);
            newSecuritizationCoin.GenericID=newSecuritizationCoinID;
            newSecuritizationCoin.ID='securitizationCoin'+newSecuritizationCoin.Owner+newSecuritizationCoin.GenericID+':0';
            currentOrder.TokenID=newSecuritizationCoin.ID;


            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitMoney').returns(newSecuritizationCoin.ID);
            OrderBook=[[lastOrder,currentOrder],[],[]];
            // sinon.stub(contract,'_sortingBidOrders').returns(OrderBook[0])


            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))

            // OrderBook must include BidOrder

            await contract.beforeTransaction(ctx);
            let ret=await contract.BidOrder(ctx,test_amount,test_price,securitizationCoin.GenericID,securitizationCoin.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 3: There is at least one Ask and one Bid and no Match',async ()=>{
            let askOrderID=crypto.createHash('sha256', secret).update("askOrderID").digest('hex');
            let askOrderAmount="100";
            let askOrderPrice=(parseFloat(test_price)+1).toString();
            BondToken.Amount=parseInt(askOrderAmount);
            BondToken.CanBeUsed=false;
            let AskOrder={
                ID: 'AskOrder'+askOrderID,
                Quantity: parseInt(askOrderAmount),
                Price: parseInt(parseFloat(askOrderPrice)*100),
                TokenID: BondToken.ID,
                Name: 'Ask',
                FullMatch: false,
                MarketPrice: false,
                PartialMatch: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Time: new Date(argTodayDate).getTime()-40000
            };

            let lastSecuritizationCoin=Object.assign({},securitizationCoin);
            let lastSecuritizationCoinID=crypto.createHash('sha256', secret).update("lastSecuritizationCoinID").digest('hex');
            lastSecuritizationCoin.ID='securitizationCoin'+OwnerClientID+lastSecuritizationCoinID+':0';


            let lastOrderID=crypto.createHash('sha256', secret).update("lastOrderID").digest('hex');
            let orderID="BidOrder"+lastOrderID
            let lastOrder={
                ID: orderID,
                Quantity: parseInt(test_amount)-2,
                Price: parseInt(parseFloat(test_price)*100),
                TokenID: lastSecuritizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice:false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount)-2,
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()-1240
            };

            lastSecuritizationCoin.Amount=lastOrder.Quantity*lastOrder.Price;
            lastSecuritizationCoin.CanBeUsed=false;
            lastSecuritizationCoin.GenericID=lastSecuritizationCoinID;
            mockStub.putState(lastSecuritizationCoin.ID,Buffer.from(JSON.stringify(lastSecuritizationCoin)));

            OrderBook=[[lastOrder],[AskOrder],[]];
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))

            orderID="BidOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(test_amount),
                Price: parseInt(parseFloat(test_price)*100),
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(test_amount),
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };

            let newSecuritizationCoin=Object.assign({}, securitizationCoin );
            let newSecuritizationCoinID=crypto.createHash('sha256', secret).update("newSecuritizationCoinID").digest('hex');
            newSecuritizationCoin.Amount=securitizationCoin.Amount-parseInt(parseFloat(test_price)*parseInt(test_amount)*100);
            newSecuritizationCoin.GenericID=newSecuritizationCoinID;
            newSecuritizationCoin.ID='securitizationCoin'+newSecuritizationCoin.Owner+newSecuritizationCoin.GenericID+':0';

            currentOrder.TokenID=newSecuritizationCoin.ID
            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitMoney').returns(newSecuritizationCoin.ID);
            OrderBook=[[lastOrder,currentOrder],[AskOrder],[]];
            // sinon.stub(contract,'_sortingBidOrders').returns(OrderBook[0]);
            // sinon.stub(contract,'_sortingAskOrders').returns(OrderBook[1]);


            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))

            // OrderBook must include BidOrder

            await contract.beforeTransaction(ctx);
            let ret=await contract.BidOrder(ctx,test_amount,test_price,securitizationCoin.GenericID,securitizationCoin.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 4: There is Match: Bid Order Partial matched',async ()=>{
            // create a full-of-orders order book
            let orderArray=[];
            let token

            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)



            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            // comparador is the upperBound
            let comparador=114.05
            let quantityMatched;

            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(2,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparador){
                    comparador=Price
                    quantityMatched=Quantity
                }

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);


            //search for a match (BID matches several ASKS)=> BidOrder
            // AMount big enough to not full match bid Order
            amount=quantityMatched+1;
            price=comparador
            // //console.log(price)

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString()).digest('hex')
            // genericID=GenericID
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:true,
            }

            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            mockStub.createCompositeKey.withArgs('securitizationCoin',[new_securitizationCoin.Owner,new_securitizationCoin.GenericID]).returns('securitizationCoin'+new_securitizationCoin.Owner+new_securitizationCoin.GenericID)


            currentOrder={
                ID: 'BidOrder'+genericID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.getState.withArgs("OrderBook").returns(Buffer.from(JSON.stringify(orderBook)))

            let asks=orderBook[1];
            // "Match engine"
            let bidReference=currentOrder;

            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            let referencePrice
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                        referencePrice=ask.Price
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        referencePrice=ask.Price
                    }
                }else{
                    continue
                }
            }
            let newID
            if (myTokens===bidReference.Quantity){
                // Full Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                // Partial Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // //console.log('final')
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // //console.log('paso 7.3')
                // No match
                // currentOrder.ID=orderID
                newID="";
                currentOrder.TokenID=newID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            // check if there is matching
            orderBook[0].push(currentOrder)



            let NewBondToken=Object.assign({}, BondToken );
            NewBondToken.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewBondToken.GenericID=NewBondTokenID;
            NewBondToken.ID='BondToken'+NewBondToken.Owner+NewBondTokenID+':0';
            NewBondToken.TypeID=':0'

            let NewSecuritizationCoin=Object.assign({}, new_securitizationCoin );
            NewSecuritizationCoin.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            // let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewSecuritizationCoin.GenericID=genericID;
            NewSecuritizationCoin.ID='securitizationCoin'+new_securitizationCoin.Owner+NewSecuritizationCoin.GenericID+':1';
            NewSecuritizationCoin.TypeID=':1'
            // we have to mock our "delivery v. payment" function, namely _transferCashTokens

            // this function has to return the updated orderbook, i.e, with tokens IDs updates, resting quantities,
            // quantity match

            // As we know this function performs OK we just return this updated orderBook
            asks=orderBook[1];
            let bids=orderBook[0];
            orderBook[2]=[referencePrice]
            // orderBook[2]=[referencePrice]
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            // and update those orders partial matched
            let newPartialBids=await newBids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await newAsks.filter(item=> item.PartialMatch===true)
            //console.log('----------newPartialAsks------------------')
            //console.log(newPartialAsks)
            //console.log('------------------------------------')
            //console.log('----------newPartialBids------------------')
            //console.log(newPartialBids)
            //console.log('----------------------------------')
            let index;
            let bondOutputKey;

            for (let t=0; t<newPartialAsks.length;t++){
                // //console.log('newPartialAsks')
                index=newAsks.indexOf(newPartialAsks[t])

                let newBondToken=await bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                //console.log('newBondToken')
                //console.log(newBondToken[0])
                //console.log('------------------')
                newBondToken[0].Amount=newBondToken[0].Amount-(newPartialAsks[t].QuantityMatch*newPartialAsks[t].Price);
                newBondToken[0].GenericID=genericID;
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+genericID+':1';

                bondOutputKey=newBondToken[0].ID
                newPartialAsks[t].TokenID=newBondToken[0].ID

                //console.log('newBondToken')
                //console.log(newBondToken[0])
                //console.log('------------------')

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity

                newAsks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                // //console.log('newPartialBids')
                index=newBids.indexOf(newPartialBids[l])

                newPartialBids[l].PartialMatch=false;
                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].TokenID=NewSecuritizationCoin.ID
                newBids[index]=newPartialBids[l]
            }


            let newOrderBook=[newBids,newAsks,orderBook[2]];


            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,new_securitizationCoin.GenericID]).returns('securitizationCoin'+OwnerClientID+new_securitizationCoin.GenericID)
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))


            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitMoney').returns(NewSecuritizationCoin.ID);


            await contract.beforeTransaction(ctx);
            let ret=await contract.BidOrder(ctx,amount.toString(),price.toString(),new_securitizationCoin.GenericID,new_securitizationCoin.TypeID);
            expect(ret).to.eql(newOrderBook);
        })
        it('Case 5: There is Match: Bid Order Full matched',async ()=>{
            // create a full-of-orders order book
            let orderArray=[];
            let token


            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();


                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            // comparador is the upperBound
            let comparador=115.05
            let minimumMatched=0
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparador){
                    comparador=Price
                    minimumMatched=Quantity
                }

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);


            //search for a match (BID matches several ASKS)=> BidOrder
            // AMount big enough to not full match bid Order
            amount=minimumMatched;
            price=comparador

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString()).digest('hex')
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:true,
            }

            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            mockStub.createCompositeKey.withArgs('securitizationCoin',[new_securitizationCoin.Owner,new_securitizationCoin.GenericID]).returns('securitizationCoin'+new_securitizationCoin.Owner+new_securitizationCoin.GenericID)


            currentOrder={
                ID: 'BidOrder'+genericID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.getState.withArgs("OrderBook").returns(Buffer.from(JSON.stringify(orderBook)))

            let asks=orderBook[1];
            // "Match engine"
            let bidReference=currentOrder;

            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            let referencePrice;
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                        referencePrice=ask.Price
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        referencePrice=ask.Price
                    }
                }else{
                    continue
                }
            }
            let newID
            if (myTokens===bidReference.Quantity){
                // Full Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                // Partial Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // //console.log('final')
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // //console.log('paso 7.3')
                // No match
                // currentOrder.ID=orderID
                newID="";
                currentOrder.TokenID=newID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            // check if there is matching
            orderBook[0].push(currentOrder)



            let NewBondToken=Object.assign({}, BondToken );
            NewBondToken.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewBondToken.GenericID=NewBondTokenID;
            NewBondToken.ID='BondToken'+NewBondToken.Owner+NewBondTokenID+':0';
            NewBondToken.TypeID=':0'

            let NewSecuritizationCoin=Object.assign({}, new_securitizationCoin );
            NewSecuritizationCoin.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            // let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewSecuritizationCoin.GenericID=genericID;
            NewSecuritizationCoin.ID='securitizationCoin'+new_securitizationCoin.Owner+NewSecuritizationCoin.GenericID+':1';
            NewSecuritizationCoin.TypeID=':1'
            // we have to mock our "delivery v. payment" function, namely _transferCashTokens

            // this function has to return the updated orderbook, i.e, with tokens IDs updates, resting quantities,
            // quantity match

            // As we know this function performs OK we just return this updated orderBook
            asks=orderBook[1];
            let bids=orderBook[0];
            orderBook[2]=[referencePrice]
            // orderBook[2]=[referencePrice]
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            // and update those orders partial matched
            let newPartialBids=await newBids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await newAsks.filter(item=> item.PartialMatch===true)
            //console.log('----------newPartialAsks------------------')
            //console.log(newPartialAsks)
            //console.log('------------------------------------')
            //console.log('----------newPartialBids------------------')
            //console.log(newPartialBids)
            //console.log('----------------------------------')
            let index;
            let bondOutputKey;

            for (let t=0; t<newPartialAsks.length;t++){
                // //console.log('newPartialAsks')
                index=newAsks.indexOf(newPartialAsks[t])

                let newBondToken=await bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                //console.log('newBondToken')
                //console.log(newBondToken[0])
                //console.log('------------------')
                newBondToken[0].Amount=newBondToken[0].Amount-(newPartialAsks[t].QuantityMatch*newPartialAsks[t].Price);
                newBondToken[0].GenericID=genericID;
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+genericID+':1';

                bondOutputKey=newBondToken[0].ID
                newPartialAsks[t].TokenID=newBondToken[0].ID

                //console.log('newBondToken')
                //console.log(newBondToken[0])
                //console.log('------------------')

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity

                newAsks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                // //console.log('newPartialBids')
                index=newBids.indexOf(newPartialBids[l])

                newPartialBids[l].PartialMatch=false;
                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].TokenID=NewSecuritizationCoin.ID
                newBids[index]=newPartialBids[l]
            }


            let newOrderBook=[newBids,newAsks,orderBook[2]];


            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,new_securitizationCoin.GenericID]).returns('securitizationCoin'+OwnerClientID+new_securitizationCoin.GenericID)
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))


            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitMoney').returns(NewSecuritizationCoin.ID);


            await contract.beforeTransaction(ctx);
            let ret=await contract.BidOrder(ctx,amount.toString(),price.toString(),new_securitizationCoin.GenericID,new_securitizationCoin.TypeID);
            expect(ret).to.eql(newOrderBook);
        })
        it('Case 6: There is Match: Bid Order Full matched and AskOrder PartialMatched',async ()=>{
            // create a full-of-orders order book
            let orderArray=[];
            let token


            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();


                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            // comparador is the upperBound
            let comparador=113.05
            let quantityMatched=0
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(2,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<=comparador){
                    quantityMatched+=Quantity
                }

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);


            //search for a match (BID matches several ASKS)=> BidOrder
            // AMount big enough to not full match bid Order
            amount=quantityMatched-1;
            price=comparador

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString()).digest('hex')
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:true,
            }

            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            mockStub.createCompositeKey.withArgs('securitizationCoin',[new_securitizationCoin.Owner,new_securitizationCoin.GenericID]).returns('securitizationCoin'+new_securitizationCoin.Owner+new_securitizationCoin.GenericID)


            currentOrder={
                ID: 'BidOrder'+genericID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.getState.withArgs("OrderBook").returns(Buffer.from(JSON.stringify(orderBook)))

            let asks=orderBook[1];
            // "Match engine"
            let bidReference=currentOrder;

            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            let referencePrice;
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                        referencePrice=ask.Price
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        referencePrice=ask.Price
                    }
                }else{
                    continue
                }
            }
            let newID
            if (myTokens===bidReference.Quantity){
                // Full Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                // Partial Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // //console.log('final')
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // //console.log('paso 7.3')
                // No match
                // currentOrder.ID=orderID
                newID="";
                currentOrder.TokenID=newID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            // check if there is matching
            orderBook[0].push(currentOrder)



            let NewBondToken=Object.assign({}, BondToken );
            NewBondToken.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewBondToken.GenericID=NewBondTokenID;
            NewBondToken.ID='BondToken'+NewBondToken.Owner+NewBondTokenID+':0';
            NewBondToken.TypeID=':0'

            let NewSecuritizationCoin=Object.assign({}, new_securitizationCoin );
            NewSecuritizationCoin.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            // let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewSecuritizationCoin.GenericID=genericID;
            NewSecuritizationCoin.ID='securitizationCoin'+new_securitizationCoin.Owner+NewSecuritizationCoin.GenericID+':1';
            NewSecuritizationCoin.TypeID=':1'
            // we have to mock our "delivery v. payment" function, namely _transferCashTokens

            // this function has to return the updated orderbook, i.e, with tokens IDs updates, resting quantities,
            // quantity match

            // As we know this function performs OK we just return this updated orderBook
            asks=orderBook[1];
            let bids=orderBook[0];
            orderBook[2]=[referencePrice]
            // orderBook[2]=[referencePrice]
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            // and update those orders partial matched
            let newPartialBids=await newBids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await newAsks.filter(item=> item.PartialMatch===true)
            //console.log('----------newPartialAsks------------------')
            //console.log(newPartialAsks)
            //console.log('------------------------------------')
            //console.log('----------newPartialBids------------------')
            //console.log(newPartialBids)
            //console.log('----------------------------------')
            let index;
            let bondOutputKey;

            for (let t=0; t<newPartialAsks.length;t++){
                // //console.log('newPartialAsks')
                index=newAsks.indexOf(newPartialAsks[t])

                let newBondToken=await bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                //console.log('newBondToken')
                //console.log(newBondToken[0])
                //console.log('------------------')
                newBondToken[0].Amount=newBondToken[0].Amount-(newPartialAsks[t].QuantityMatch*newPartialAsks[t].Price);
                newBondToken[0].GenericID=genericID;
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+genericID+':1';

                bondOutputKey=newBondToken[0].ID
                newPartialAsks[t].TokenID=newBondToken[0].ID

                //console.log('newBondToken')
                //console.log(newBondToken[0])
                //console.log('------------------')

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity

                newAsks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                // //console.log('newPartialBids')
                index=newBids.indexOf(newPartialBids[l])

                newPartialBids[l].PartialMatch=false;
                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].TokenID=NewSecuritizationCoin.ID
                newBids[index]=newPartialBids[l]
            }


            let newOrderBook=[newBids,newAsks,orderBook[2]];


            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,new_securitizationCoin.GenericID]).returns('securitizationCoin'+OwnerClientID+new_securitizationCoin.GenericID)
            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))


            sinon.stub(contract,'_checkDecimals').returns(true);
            sinon.stub(contract,'_splitMoney').returns(NewSecuritizationCoin.ID);


            await contract.beforeTransaction(ctx);
            let ret=await contract.BidOrder(ctx,amount.toString(),price.toString(),new_securitizationCoin.GenericID,new_securitizationCoin.TypeID);
            expect(ret).to.eql(newOrderBook);
        })
    })
    describe('TESTING: AskMarketOrder', () =>{
        let ownerID;
        let new_BondToken;
        let genericID,new_genericID;
        let tokenID,new_tokenID;
        let typeID;
        let IdealPrice,IdealQuantity;
        let idealQuantity,idealPrice;
        let notEnoughAmount;
        let amount,price,bondID,identificativo,date,argDate;
        let FunctionAndParameters;
        let wrong_OrgMSP;
        let OrderBook;
        let currentOrder;
        let orderID;
        // let currentTime
        let new_securitizationCoin,securitizationCoin1,securitizationCoin2
        let bondTokensArray=[]

        let GenericID,ID,NewGenericID,TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity
        let Time,Name

        let TypeID,Issuer,Owner,Amount,Factor,CanBeUsed;

        let new_securitizationCoinBuffer


        let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,OriginalValue,MonthlyPayout,RemainingPayments;

        let secret="mySecret"
        let todayDate=new Date();
        let securitizationCoinBuffer
        let cashTokensArray=[]

        let orderBook;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

        let monthlyPayout,PoolID,TransactionID,BondToken;
        let securitizationCoinID
        let argTodayDate
        let securitizationCoin
        let test_amount,test_price

        let orderArray=[];
        async function sortingAskOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }

        // let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? 1 : ((b.Price > a.Price) ? -1 : (a.Time<b.Time) ? 1 : -1));
            return orderArray
        }
        beforeEach(() => {

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";
            price="110.12"

            //lets suppose test_amount is less than amount
            test_amount="10"
            test_price=price

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')
            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            securitizationCoinID=crypto.createHash('sha256', secret).update("securitizationCoinID").digest('hex');
            securitizationCoin={
                ID:'securitizationCoin'+OwnerClientID+securitizationCoinID+':0',
                GenericID: securitizationCoinID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: Amount,
                Factor: 100,
                CanBeUsed: true
            }
            todayDate=new Date();
            argTodayDate=todayDate.toUTCString();

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex');

            mockStub.getDateTimestamp.returns(argTodayDate);
            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('AskOrder',[genericID]).returns('AskOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,BondToken.GenericID]).returns('BondToken'+OwnerClientID+BondToken.GenericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            FunctionAndParameters={
                fcn: 'AskMarketOrder',
                params: [amount,BondToken.GenericID,BondToken.TypeID]
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters)
        })
        it('Should throw an error if user is not a client', async ()=>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('AskMarketOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty string',async ()=>{
            FunctionAndParameters.params=[amount,price,BondToken.GenericID,BondToken.TypeID,'']
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('AskMarketOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter that should not be`)
            }
        })
        it('Should throw an error if user is neither an investor nor an spv member',async ()=>{
            let wrong_OrgMSP='ratingagencyMSP';
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('AskMarketOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        })
        it('Should throw an error if amount is <=0',async () =>{
            await contract.beforeTransaction(ctx)
            try{
                await contract.AskMarketOrder(ctx,"-35",BondToken.ID,BondToken.TypeID)
                assert.fail('AskMarketOrder should throw an Error')
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Amount argument must be positive`)
            }
        })
        it('Should throw an error if Bond Token does not exist',async ()=>{
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskMarketOrder(ctx,amount,BondToken.GenericID,BondToken.TypeID,argDate);
                assert.fail('AskMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Error, Bond State with key ${BondToken.GenericID} does not exist`)
            }
        })
        it('Should throw an error if Bond Token exists but cannot be used',async ()=>{
            BondToken.CanBeUsed=false;
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskMarketOrder(ctx,amount,BondToken.GenericID,BondToken.TypeID);
                assert.fail('AskMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`This Bond State with ID ${BondToken.GenericID} has already been used. Try another bond ID`)
            }
        })
        it('Should throw an error if Bond Token exists but it does not have enough funds',async ()=>{
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))
            let newAmount=BondToken.Amount+10
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskMarketOrder(ctx,newAmount.toString(),BondToken.GenericID,BondToken.TypeID);
                assert.fail('AskMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Your token has not enough funds`)
            }
        })
        it('Case 1: ORDER BOOK does not exist=> no marketPrice => throw error',async ()=>{
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)))
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskMarketOrder(ctx,BondToken.Amount.toString(),BondToken.GenericID,BondToken.TypeID);
                assert.fail('AskMarketOrder should throw an Error')
            }catch(err){
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Order Book still not submitted`)
            }
        })
        it('Case 2: ORDER BOOK exists with asks but no bids => order not submitted',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice;
            let todayDate=new Date();
            let Name
            let orderArray=[];
            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            let askPrice=[];
            // ASKS
            let comparador=115.05
            for (let i=0;i<100;i++){
                let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)


                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=(comp>0.5) ? todayDate.getTime()+(Quantity*100) :todayDate.getTime()-(Quantity*100)
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparador){
                    comparador=Price
                }
            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            OrderBook=[[],AskOrderArray_Ordered,[]];
            mockStub.putState('OrderBook',Buffer.from(JSON.stringify(OrderBook)));
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))
            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)));
            await contract.beforeTransaction(ctx);
            try{
                await contract.AskMarketOrder(ctx,BondToken.Amount.toString(),BondToken.GenericID,BondToken.TypeID);
                assert.fail('AskMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There are no bids submitted.`)
            }
        })
        it('Case 3: ORDER BOOK exists and askMarketOrder is FullMatched, and bid.Quantity>=askMarketOrder.Quantity',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice;
            let todayDate=new Date();
            let Name
            let orderArray=[];
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            let GenericOwnerClientID="12345678A"
            let comparadorAskMarketOrder=0
            let quantityAskMarketOrder
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let new_securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                new_securitizationCoin.ID=ID;
                new_securitizationCoin.GenericID= NewGenericID;
                new_securitizationCoin.TypeID= TypeID;
                new_securitizationCoin.Issuer=Issuer;
                new_securitizationCoin.Owner= Owner;
                new_securitizationCoin.Amount=Amount;
                new_securitizationCoin.Factor=Factor;
                new_securitizationCoin.CanBeUsed=CanBeUsed
                new_securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(new_securitizationCoin);
                mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
                mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                if (Price>comparadorAskMarketOrder){
                    comparadorAskMarketOrder=Price
                    quantityAskMarketOrder=Quantity
                }
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            let comparador=115.05
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparador){
                    comparador=Price
                }
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            OrderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.putState('OrderBook', Buffer.from(JSON.stringify(OrderBook)))
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))

            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))


            let orderID="AskOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(quantityAskMarketOrder)-1,
                Price: '',
                TokenID: BondToken.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(quantityAskMarketOrder)-1,
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()
            };

            // securitizationCoin.Amount=parseInt(quantityAskMarketOrder*comparadorAskMarketOrder*100)
            // mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))


            let bids=OrderBook[0]
            const askReference=currentOrder;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let counter=askReference.Quantity;
            let totalTokens=0;
            let balance=0;
            // Check if there is matching
            let myTokens=0
            let lastBidPrice
            for await (const bid of bids) {
                if (!bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                        lastBidPrice=bid.Price
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        // bid.Quantity=bid.Quantity-balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                        lastBidPrice=bid.Price
                    }
                }else{
                    continue
                }
            }

            currentOrder.TokenID=BondToken.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            bids=OrderBook[0];
            let asks=OrderBook[1];
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            OrderBook=[newBids,newAsks,[lastBidPrice]]
            asks=OrderBook[1];
            bids=OrderBook[0];
            // and update those orders partial matched
            let newPartialBids=await bids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await asks.filter(item=> item.PartialMatch===true)
            let index;
            for (let t=0; t<newPartialAsks.length;t++){
                index=asks.indexOf(newPartialAsks[t])
                let newBondToken=bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                //console.log('----------------NewBondToken-----------------')
                //console.log(newBondToken)
                //console.log('------------------------------------------')
                newBondToken[0].Amount=newBondToken[0].Amount-newPartialAsks[t].QuantityMatch;
                newBondToken[0].GenericID=genericID
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+newBondToken[0].GenericID+':1';
                newBondToken[0].Issuer=BondToken.Issuer
                //console.log('----------------NewBondToken-----------------')
                //console.log(newBondToken)
                //console.log('------------------------------------------')


                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity
                newPartialAsks[t].TokenID=newBondToken[0].ID;
                asks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                index=bids.indexOf(newPartialBids[l])
                let newSecuritizationCoin=cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                //console.log('----------------NewSecuritizationCoin-----------------')
                //console.log(newSecuritizationCoin)
                //console.log('------------------------------------------')
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+newSecuritizationCoin[0].GenericID+':1';
                newSecuritizationCoin[0].Issuer=BondToken.Issuer
                //console.log('----------------NewSecuritizationCoin-----------------')
                //console.log(newSecuritizationCoin)
                //console.log('------------------------------------------')

                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newPartialBids[l].PartialMatch=false;
                bids[index]=newPartialBids[l]
            }


            OrderBook=[bids,asks,[lastBidPrice]]
            await contract.beforeTransaction(ctx);
            let ret=await contract.AskMarketOrder(ctx, (parseInt(quantityAskMarketOrder)-1).toString(),BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 4: ORDER BOOK exists and askMarketOrder is FullMatched, and (bid[0].Quantity+bid[1])>=askMarketOrder.Quantity',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice;
            let todayDate=new Date();
            let Name
            let orderArray=[];
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            let GenericOwnerClientID="12345678A"
            let comparadorAskMarketOrder=0
            let quantityAskMarketOrder
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let new_securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                new_securitizationCoin.ID=ID;
                new_securitizationCoin.GenericID= NewGenericID;
                new_securitizationCoin.TypeID= TypeID;
                new_securitizationCoin.Issuer=Issuer;
                new_securitizationCoin.Owner= Owner;
                new_securitizationCoin.Amount=Amount;
                new_securitizationCoin.Factor=Factor;
                new_securitizationCoin.CanBeUsed=CanBeUsed
                new_securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(new_securitizationCoin);
                mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
                mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                if (Price>comparadorAskMarketOrder){
                    comparadorAskMarketOrder=Price
                    quantityAskMarketOrder=Quantity
                }
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            let comparador=115.05
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparador){
                    comparador=Price
                }
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);
            OrderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.putState('OrderBook', Buffer.from(JSON.stringify(OrderBook)))
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))

            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))


            let orderID="AskOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(quantityAskMarketOrder)+1,
                Price: '',
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(quantityAskMarketOrder)+1,
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()
            };
            securitizationCoin.Amount=parseInt(quantityAskMarketOrder*comparadorAskMarketOrder*100)
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))


            let bids=OrderBook[0]
            const askReference=currentOrder;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let counter=askReference.Quantity;
            let totalTokens=0;
            let balance=0;
            // Check if there is matching
            let myTokens=0
            let lastBidPrice
            for await (const bid of bids) {
                if (!bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                        lastBidPrice=bid.Price
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        // bid.Quantity=bid.Quantity-balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                        lastBidPrice=bid.Price
                    }
                }else{
                    continue
                }
            }

            currentOrder.TokenID=BondToken.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            bids=OrderBook[0];
            let asks=OrderBook[1];
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            OrderBook=[newBids,newAsks,[lastBidPrice]]
            asks=OrderBook[1];
            bids=OrderBook[0];
            // and update those orders partial matched
            let newPartialBids=await bids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await asks.filter(item=> item.PartialMatch===true)
            let index;
            for (let t=0; t<newPartialAsks.length;t++){
                let newBondToken=bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                //console.log('----------------NewBondToken-----------------')
                //console.log(newBondToken)
                //console.log('------------------------------------------')
                newBondToken[0].Amount=newBondToken[0].Amount-newPartialAsks[t].QuantityMatch;
                newBondToken[0].GenericID=genericID
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+newBondToken[0].GenericID+':1';
                newBondToken[0].Issuer=BondToken.Issuer
                //console.log('----------------NewBondToken-----------------')
                //console.log(newBondToken)
                //console.log('------------------------------------------')
                index=asks.indexOf(newPartialAsks[t])
                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].TokenID=newBondToken[0].ID;
                asks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                index=bids.indexOf(newPartialBids[l])
                let newSecuritizationCoin=cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                //console.log('----------------NewSecuritizationCoin-----------------')
                //console.log(newSecuritizationCoin)
                //console.log('------------------------------------------')
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+newSecuritizationCoin[0].GenericID+':1';
                newSecuritizationCoin[0].Issuer=BondToken.Issuer
                //console.log('----------------NewSecuritizationCoin-----------------')
                //console.log(newSecuritizationCoin)
                //console.log('------------------------------------------')

                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newPartialBids[l].PartialMatch=false;
                bids[index]=newPartialBids[l]
            }


            OrderBook=[bids,asks,[lastBidPrice]];
            await contract.beforeTransaction(ctx);
            let ret=await contract.AskMarketOrder(ctx, (parseInt(quantityAskMarketOrder)+1).toString(),BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 5: ORDER BOOK exists and askMarketOrder is "PartialMatched", sum over all bid.Quantity<askMarketOrder.Quantity',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice;
            let todayDate=new Date();
            let Name
            let orderArray=[];
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            let GenericOwnerClientID="12345678A"
            let comparadorAskMarketOrder=0
            let quantityAskMarketOrder
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let new_securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,10))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                new_securitizationCoin.ID=ID;
                new_securitizationCoin.GenericID= NewGenericID;
                new_securitizationCoin.TypeID= TypeID;
                new_securitizationCoin.Issuer=Issuer;
                new_securitizationCoin.Owner= Owner;
                new_securitizationCoin.Amount=Amount;
                new_securitizationCoin.Factor=Factor;
                new_securitizationCoin.CanBeUsed=CanBeUsed
                new_securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(new_securitizationCoin);
                mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
                mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                quantityAskMarketOrder=Quantity
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            let comparador=115.05
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                // GenericID=crypto.createHash('sha256', secret).update(i.toString()+investorCert).digest('hex');
                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparador){
                    comparador=Price
                }
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);
            OrderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.putState('OrderBook', Buffer.from(JSON.stringify(OrderBook)))
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)))

            mockStub.putState(BondToken.ID,Buffer.from(JSON.stringify(BondToken)));
            mockStub.getState.withArgs(BondToken.ID).returns(Buffer.from(JSON.stringify(BondToken)))


            let orderID="AskOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(quantityAskMarketOrder)+1,
                Price: '',
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(quantityAskMarketOrder)+1,
                Name: 'Ask',
                Time: new Date(argTodayDate).getTime()
            };
            securitizationCoin.Amount=parseInt(quantityAskMarketOrder*comparadorAskMarketOrder*100)
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))


            let bids=OrderBook[0]
            const askReference=currentOrder;
            let tokenKeyAcumulator=[];
            let tokenAcumulator=[];
            let tokenQuantitiesAcumulator=[];
            let counter=askReference.Quantity;
            let totalTokens=0;
            let balance=0;
            // Check if there is matching
            let myTokens=0
            let lastBidPrice
            for await (const bid of bids) {
                if (!bid.FullMatch && myTokens<askReference.Quantity){
                    counter=counter-bid.Quantity;
                    balance=bid.Quantity+counter;
                    if (counter>=0 ){
                        bid.FullMatch=true;
                        bid.PartialMatch=false;
                        bid.QuantityMatch=bid.Quantity;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=bid.Quantity
                        lastBidPrice=bid.Price
                    } else{
                        bid.FullMatch=false;
                        bid.PartialMatch=true;
                        bid.QuantityMatch=balance;
                        // bid.Quantity=bid.Quantity-balance;
                        tokenKeyAcumulator.push(bid.ID);
                        tokenAcumulator.push(bid);
                        tokenQuantitiesAcumulator.push(counter+bid.Quantity);
                        totalTokens=totalTokens+(bid.Price*bid.QuantityMatch);
                        myTokens+=balance
                        lastBidPrice=bid.Price
                    }
                }else{
                    continue
                }
            }

            currentOrder.TokenID=BondToken.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            bids=OrderBook[0];
            let asks=OrderBook[1];
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            OrderBook=[newBids,newAsks,[lastBidPrice]]
            asks=OrderBook[1];
            bids=OrderBook[0];
            // and update those orders partial matched
            let newPartialBids=await bids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await asks.filter(item=> item.PartialMatch===true)
            let index;
            for (let t=0; t<newPartialAsks.length;t++){
                index=asks.indexOf(newPartialAsks[t])

                let newBondToken=bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                //console.log('----------------NewBondToken-----------------')
                //console.log(newBondToken)
                //console.log('------------------------------------------')
                newBondToken[0].Amount=newBondToken[0].Amount-newPartialAsks[t].QuantityMatch;
                newBondToken[0].GenericID=genericID
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+newBondToken[0].GenericID+':1';
                newBondToken[0].Issuer=BondToken.Issuer
                //console.log('----------------NewBondToken-----------------')
                //console.log(newBondToken)
                //console.log('------------------------------------------')


                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].TokenID=newBondToken[0].ID;
                asks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                index=bids.indexOf(newPartialBids[l])
                let newSecuritizationCoin=cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                //console.log('----------------NewSecuritizationCoin-----------------')
                //console.log(newSecuritizationCoin)
                //console.log('------------------------------------------')
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+newSecuritizationCoin[0].GenericID+':1';
                newSecuritizationCoin[0].Issuer=BondToken.Issuer
                //console.log('----------------NewSecuritizationCoin-----------------')
                //console.log(newSecuritizationCoin)
                //console.log('------------------------------------------')

                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newPartialBids[l].PartialMatch=false;
                bids[index]=newPartialBids[l]
            }


            OrderBook=[bids,asks,[lastBidPrice]]
            await contract.beforeTransaction(ctx);
            let ret=await contract.AskMarketOrder(ctx, (parseInt(quantityAskMarketOrder)+1).toString(),BondToken.GenericID,BondToken.TypeID);
            expect(ret).to.eql(OrderBook);
        })
    })
    describe('TESTING: BidMarketOrder', () =>{
        let new_BondToken;
        let genericID,new_genericID;
        let tokenID,new_tokenID;
        let typeID;
        let IdealPrice,IdealQuantity;
        let idealQuantity,idealPrice;
        let notEnoughAmount;
        let amount,price,bondID,identificativo,date,argDate;
        let FunctionAndParameters;
        let wrong_OrgMSP;
        let OrderBook;
        let currentOrder;
        let orderID;
        // let currentTime
        let new_securitizationCoin,securitizationCoin1,securitizationCoin2
        let bondTokensArray=[]

        let GenericID,ID,NewGenericID,TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity
        let Time,Name

        let TypeID,Issuer,Owner,Amount,Factor,CanBeUsed;

        let new_securitizationCoinBuffer

        let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,OriginalValue,MonthlyPayout,RemainingPayments;

        let secret="mySecret"
        let todayDate=new Date();
        let securitizationCoinBuffer
        let cashTokensArray=[]

        let orderBook;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

        let monthlyPayout,PoolID,TransactionID,BondToken;
        let securitizationCoinID
        let argTodayDate
        let securitizationCoin
        let test_amount,test_price

        let orderArray=[];
        async function sortingAskOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }

        // let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            // await orderArray.sort((a,b) => (a.MarketPrice && b.MarketPrice && a.Time<b.Time) ? 1 : (a.MarketPrice && b.MarketPrice && a.Time>b.Time)? -1: 0);
            await orderArray.sort((b,a) => (a.Price > b.Price) ? 1 : ((b.Price > a.Price) ? -1 : (a.Time<b.Time) ? 1 : -1));
            return orderArray
        }
        beforeEach(() => {

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";
            price="110.12"

            //lets suppose test_amount is less than amount
            test_amount="10"
            test_price=price

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')
            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            securitizationCoinID=crypto.createHash('sha256', secret).update("securitizationCoinID").digest('hex');
            securitizationCoin={
                ID:'securitizationCoin'+OwnerClientID+securitizationCoinID+':0',
                GenericID: securitizationCoinID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: Amount,
                Factor: 100,
                CanBeUsed: true
            }
            todayDate=new Date();
            argTodayDate=todayDate.toUTCString();

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex');

            mockStub.getDateTimestamp.returns(argTodayDate);
            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,securitizationCoin.GenericID]).returns('securitizationCoin'+OwnerClientID+securitizationCoin.GenericID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            FunctionAndParameters={
                fcn: 'BidMarketOrder',
                params: [amount,securitizationCoin.GenericID,securitizationCoin.TypeID]
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters)
        })
        it('Should throw an error if user is not a client', async ()=>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('BidMarketOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should throw an error if any arg is an empty ',async ()=>{
            FunctionAndParameters.params=['',securitizationCoin.GenericID,securitizationCoin.TypeID]
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters);
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('BidMarketOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`There is at least one empty parameter that should not be`)
            }
        })
        it('Should through an error if user is not an investor',async ()=>{
            wrong_OrgMSP='originatorMSP';
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('BidMarketOrder should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        })
        it('Should throw an error if amount<=0',async ()=>{
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidMarketOrder(ctx,"-35",securitizationCoin.ID,securitizationCoin.TypeID);
                assert.fail('BidMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Amount argument must be positive`)
            }
        })
        it('Should throw an error if securitizationCoin does not exist',async ()=>{
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidMarketOrder(ctx,amount,securitizationCoin.GenericID,securitizationCoin.TypeID);
                assert.fail('BidMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Error, Token State with ID ${securitizationCoin.GenericID} does not exist`)
            }
        })
        it('Should throw an error if securitizationCoin exists  but cannot be used',async ()=>{
            securitizationCoin.CanBeUsed=false;
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidMarketOrder(ctx,amount,securitizationCoin.GenericID,securitizationCoin.TypeID);
                assert.fail('BidMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`This Token State with ID ${securitizationCoin.GenericID} has already been used. Try another token ID`)
            }
        })
        it('Case 1: ORDER BOOK does not exist=> throw an error',async ()=>{
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidMarketOrder(ctx,amount,securitizationCoin.GenericID,securitizationCoin.TypeID);
                assert.fail('BidMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There are no asks submitted.`)
            }
        })
        it('Case 2: ORDER BOOK exists with bids but without asks => order not submitted',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice
            let todayDate=new Date()
            let Name;
            let orderArray=[];
            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);
            OrderBook=[BidOrderArray_Ordered,[],[]]
            mockStub.putState('OrderBook', Buffer.from(JSON.stringify(OrderBook)));
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)));
            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
            await contract.beforeTransaction(ctx);
            try{
                await contract.BidMarketOrder(ctx,amount,securitizationCoin.GenericID,securitizationCoin.TypeID);
                assert.fail('BidMarketOrder should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`There are no asks submitted.`)
            }
        })
        it('Case 3: ORDER BOOK exists with asks and bids. BidMarketOrder FullMatched. bidMarket.Quantity<=ask.Quantity ',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice
            let todayDate=new Date()
            let Name;
            let orderArray=[];
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            let GenericOwnerClientID="12345678A"
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let new_securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString();
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=parseInt(Quantity);
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                new_securitizationCoin.ID=ID;
                new_securitizationCoin.GenericID= NewGenericID;
                new_securitizationCoin.TypeID= TypeID;
                new_securitizationCoin.Issuer=Issuer;
                new_securitizationCoin.Owner= Owner;
                new_securitizationCoin.Amount=Amount;
                new_securitizationCoin.Factor=Factor;
                new_securitizationCoin.CanBeUsed=CanBeUsed
                new_securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(new_securitizationCoin);
                mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
                mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            let comparador=115.05
            let comparadorBidMarketOrder=115.05;
            let quantityBidMarketOrder=0
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(2,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=parseInt(Quantity);
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparadorBidMarketOrder){
                    comparadorBidMarketOrder=Price
                    quantityBidMarketOrder=Quantity
                }
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            securitizationCoin.Amount=parseInt(quantityBidMarketOrder*comparadorBidMarketOrder*100);
            OrderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.putState('OrderBook', Buffer.from(JSON.stringify(OrderBook)));
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)));

            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));


            let orderID="BidOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(quantityBidMarketOrder)-1,
                Price: '',
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(quantityBidMarketOrder)-1,
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };



            const bidReference=currentOrder;

            let asks=OrderBook[1];
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            let lastAskPrice=0
            for await (const ask of asks) {
                if (!ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                        lastAskPrice=ask.Price
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        lastAskPrice=ask.Price
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }


            currentOrder.TokenID=securitizationCoin.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            OrderBook=[OrderBook[0],asks,OrderBook[2]]

            let bids=OrderBook[0];
            asks=OrderBook[1];
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            OrderBook=[newBids,newAsks,[lastAskPrice]]
            asks=OrderBook[1];
            bids=OrderBook[0];
            // and update those orders partial matched
            let newPartialBids=await bids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await asks.filter(item=> item.PartialMatch===true)
            let index;
            for (let t=0; t<newPartialAsks.length;t++){
                index=asks.indexOf(newPartialAsks[t])
                let newBondToken=bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                newBondToken[0].Amount=newBondToken[0].Amount-newPartialAsks[t].QuantityMatch;
                newBondToken[0].GenericID=genericID
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+newBondToken[0].GenericID+':1';
                newBondToken[0].Issuer=securitizationCoin.Issuer

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity
                newPartialAsks[t].TokenID=newBondToken[0].ID;
                asks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                index=bids.indexOf(newPartialBids[l])
                let newSecuritizationCoin=cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+newSecuritizationCoin[0].GenericID+':1';
                newSecuritizationCoin[0].Issuer=securitizationCoin.Issuer

                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newPartialBids[l].PartialMatch=false;
                bids[index]=newPartialBids[l]
            }

            // newBids=await sortingBidOrders(bids)
            // newAsks=await sortingAskOrders(asks)

            OrderBook=[bids,asks,[lastAskPrice]]

            await contract.beforeTransaction(ctx);

            let ret=await contract.BidMarketOrder(ctx,(parseInt(quantityBidMarketOrder-1)).toString(),securitizationCoin.GenericID,securitizationCoin.TypeID);
            // //console.log('ret[0]')
            // //console.log('-------------------------------------')
            // //console.log(ret[1])
            // //console.log('-------------------------------------')
            // //console.log('OrderBook[0]')
            // //console.log('-------------------------------------')
            // //console.log(OrderBook[1])
            // //console.log('-------------------------------------')
            expect(ret).to.eql(OrderBook);
        })
        it('Case 4: ORDER BOOK exists and bidMarketOrder is FullMatched, and (ask[0].Quantity+ask[1].Quantity)>=bidMarketOrder.Quantity ',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice
            let todayDate=new Date()
            let Name;
            let orderArray=[];
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            let GenericOwnerClientID="12345678A"
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let new_securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString();
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=parseInt(Quantity);
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                new_securitizationCoin.ID=ID;
                new_securitizationCoin.GenericID= NewGenericID;
                new_securitizationCoin.TypeID= TypeID;
                new_securitizationCoin.Issuer=Issuer;
                new_securitizationCoin.Owner= Owner;
                new_securitizationCoin.Amount=Amount;
                new_securitizationCoin.Factor=Factor;
                new_securitizationCoin.CanBeUsed=CanBeUsed
                new_securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(new_securitizationCoin);
                mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
                mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            let comparador=115.05
            let comparadorBidMarketOrder=115.05;
            let quantityBidMarketOrder=0
            for (let i=0;i<100;i++){
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(2,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=parseInt(Quantity);
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<comparadorBidMarketOrder){
                    comparadorBidMarketOrder=Price
                    quantityBidMarketOrder=Quantity
                }
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            securitizationCoin.Amount=parseInt(quantityBidMarketOrder*comparadorBidMarketOrder*100);
            OrderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.putState('OrderBook', Buffer.from(JSON.stringify(OrderBook)));
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)));

            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));


            let orderID="BidOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(quantityBidMarketOrder)+1,
                Price: '',
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(quantityBidMarketOrder)+1,
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };



            const bidReference=currentOrder;

            let asks=OrderBook[1];
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            let lastAskPrice=0
            for await (const ask of asks) {
                if (!ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                        lastAskPrice=ask.Price
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        lastAskPrice=ask.Price
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }


            currentOrder.TokenID=securitizationCoin.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            OrderBook=[OrderBook[0],asks,OrderBook[2]]

            let bids=OrderBook[0];
            asks=OrderBook[1];
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            OrderBook=[newBids,newAsks,[lastAskPrice]]
            asks=OrderBook[1];
            bids=OrderBook[0];
            // and update those orders partial matched
            let newPartialBids=await bids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await asks.filter(item=> item.PartialMatch===true)
            let index;
            for (let t=0; t<newPartialAsks.length;t++){
                index=asks.indexOf(newPartialAsks[t])
                let newBondToken=bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                newBondToken[0].Amount=newBondToken[0].Amount-newPartialAsks[t].QuantityMatch;
                newBondToken[0].GenericID=genericID
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+newBondToken[0].GenericID+':1';
                newBondToken[0].Issuer=securitizationCoin.Issuer

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity
                newPartialAsks[t].TokenID=newBondToken[0].ID;
                asks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                index=bids.indexOf(newPartialBids[l])
                let newSecuritizationCoin=cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+newSecuritizationCoin[0].GenericID+':1';
                newSecuritizationCoin[0].Issuer=securitizationCoin.Issuer

                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newPartialBids[l].PartialMatch=false;
                bids[index]=newPartialBids[l]
            }

            // newBids=await sortingBidOrders(bids)
            // newAsks=await sortingAskOrders(asks)

            OrderBook=[bids,asks,[lastAskPrice]]

            await contract.beforeTransaction(ctx);

            let ret=await contract.BidMarketOrder(ctx,(parseInt(quantityBidMarketOrder+1)).toString(),securitizationCoin.GenericID,securitizationCoin.TypeID);
            expect(ret).to.eql(OrderBook);
        })
        it('Case 5: ORDER BOOK exists and bidMarketOrder is "PartialMatched", sum over all ask.Quantity<bidMarketOrder.Quantity ',async ()=>{
            let ID,TokenID,Quantity,Price,PartialMatch,QuantityMatch,RestingQuantity,Time,FullMatch,MarketPrice
            let todayDate=new Date()
            let Name;
            let orderArray=[];
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)

            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            let GenericOwnerClientID="12345678A"
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let new_securitizationCoin={

                };
                OwnerClientID=GenericOwnerClientID+i.toString();
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=parseInt(Quantity);
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                new_securitizationCoin.ID=ID;
                new_securitizationCoin.GenericID= NewGenericID;
                new_securitizationCoin.TypeID= TypeID;
                new_securitizationCoin.Issuer=Issuer;
                new_securitizationCoin.Owner= Owner;
                new_securitizationCoin.Amount=Amount;
                new_securitizationCoin.Factor=Factor;
                new_securitizationCoin.CanBeUsed=CanBeUsed
                new_securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(new_securitizationCoin);
                mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
                mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            let comparador=115.05
            let comparadorBidMarketOrder=115.05;
            let quantityBidMarketOrder=0
            for (let i=0;i<10;i++){
                let AskOrder={

                };
                let bondToken={

                };
                OwnerClientID=GenericOwnerClientID+i.toString()
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(1,10))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=parseInt(Quantity);
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.NotBefore=BondToken.NotBefore;
                bondToken.CouponsReceived=BondToken.CouponsReceived;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                // if (Price<comparadorBidMarketOrder){
                //     comparadorBidMarketOrder=Price
                //     quantityBidMarketOrder=Quantity
                // }
                quantityBidMarketOrder+=Quantity
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)

            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);

            securitizationCoin.Amount=parseInt(quantityBidMarketOrder*comparadorBidMarketOrder*100);
            OrderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            mockStub.putState('OrderBook', Buffer.from(JSON.stringify(OrderBook)));
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(OrderBook)));

            mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)))
            mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)));


            let orderID="BidOrder"+genericID;
            currentOrder={
                ID: orderID,
                Quantity: parseInt(quantityBidMarketOrder)+1,
                Price: '',
                TokenID: securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(quantityBidMarketOrder)+1,
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };



            const bidReference=currentOrder;

            let asks=OrderBook[1];
            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            let lastAskPrice=0
            for await (const ask of asks) {
                if (!ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                        lastAskPrice=ask.Price
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        lastAskPrice=ask.Price
                        // And finally break, because we read following a prestablished order
                    }
                }else{
                    continue
                }
            }


            currentOrder.TokenID=securitizationCoin.ID;
            currentOrder.FullMatch=true;
            currentOrder.PartialMatch= false;
            currentOrder.QuantityMatch=myTokens;

            OrderBook=[OrderBook[0],asks,OrderBook[2]]

            let bids=OrderBook[0];
            asks=OrderBook[1];
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            OrderBook=[newBids,newAsks,[lastAskPrice]]
            asks=OrderBook[1];
            bids=OrderBook[0];
            // and update those orders partial matched
            let newPartialBids=await bids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await asks.filter(item=> item.PartialMatch===true)
            let index;
            for (let t=0; t<newPartialAsks.length;t++){
                index=asks.indexOf(newPartialAsks[t])
                let newBondToken=bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                newBondToken[0].Amount=newBondToken[0].Amount-newPartialAsks[t].QuantityMatch;
                newBondToken[0].GenericID=genericID
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+newBondToken[0].GenericID+':1';
                newBondToken[0].Issuer=securitizationCoin.Issuer

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity
                newPartialAsks[t].TokenID=newBondToken[0].ID;
                asks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                index=bids.indexOf(newPartialBids[l])
                let newSecuritizationCoin=cashTokensArray.filter(item=> item.ID===newPartialBids[l].TokenID)
                newSecuritizationCoin[0].Amount=newSecuritizationCoin[0].Amount-(newPartialBids[l].QuantityMatch*newPartialBids[l].Price);
                newSecuritizationCoin[0].GenericID=genericID
                newSecuritizationCoin[0].ID='securitizationCoin'+newSecuritizationCoin[0].Owner+newSecuritizationCoin[0].GenericID+':1';
                newSecuritizationCoin[0].Issuer=securitizationCoin.Issuer

                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].TokenID=newSecuritizationCoin[0].ID
                newPartialBids[l].PartialMatch=false;
                bids[index]=newPartialBids[l]
            }

            // newBids=await sortingBidOrders(bids)
            // newAsks=await sortingAskOrders(asks)

            OrderBook=[bids,asks,[lastAskPrice]]

            await contract.beforeTransaction(ctx);

            let ret=await contract.BidMarketOrder(ctx,(parseInt(quantityBidMarketOrder+1)).toString(),securitizationCoin.GenericID,securitizationCoin.TypeID);
            // //console.log('ret[0]')
            // //console.log('-------------------------------------')
            // //console.log(ret[1])
            // //console.log('-------------------------------------')
            // //console.log('OrderBook[0]')
            // //console.log('-------------------------------------')
            // //console.log(OrderBook[1])
            // //console.log('-------------------------------------')
            expect(ret).to.eql(OrderBook);
        })
    })
    describe('TESTING: Query Order Book', () =>{
        let genericID;
        let tokenID;
        let typeID;
        let amount,price,bondID,identificativo,date,argDate;
        let FunctionAndParameters;
        let wrong_OrgMSP;
        let OrderBook;
        let currentOrder;
        let orderID;
        // let currentTime
        let new_securitizationCoin,securitizationCoin1,securitizationCoin2
        let bondTokensArray=[]

        let GenericID,ID,NewGenericID,TokenID,Quantity,Price,MarketPrice,PartialMatch,FullMatch,QuantityMatch,RestingQuantity
        let Time,Name

        let TypeID,Issuer,Owner,Amount,Factor,CanBeUsed;

        let Rating,CouponRate,CouponFactor,MaturityDate,FaceValue,Pool,AmountPaid,OriginalValue,MonthlyPayout,RemainingPayments;

        let secret="mySecret"
        let todayDate=new Date();
        let securitizationCoinBuffer
        let cashTokensArray=[]

        let orderBook;

        let OwnerClientID,OwnerClientCert,OwnerClientCertAsBytes;

        let monthlyPayout,PoolID,TransactionID,BondToken;
        let securitizationCoinID
        let argTodayDate
        let securitizationCoin
        let test_amount,test_price

        let orderArray=[];
        async function sortingAskOrders(orderArray){
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? 1 : -1));
            return orderArray
        }

        // let todayDate=new Date()
        async function sortingBidOrders(orderArray){
            await orderArray.sort((b,a) => (a.Price > b.Price) ? -1 : ((b.Price > a.Price) ? 1 : (b.Time>a.Time) ? -1 : 1));
            return orderArray.reverse()
        }
        beforeEach(() => {

            OwnerClientID="12345678A";
            OwnerClientCert="OwnerClientCert";
            OwnerClientCertAsBytes=Buffer.from(OwnerClientCert).toString('base64');


            let thisDate=new Date(2022,11,24)
            let argThisDate=thisDate.toUTCString()

            let couponRate=0.0423;
            let faceValue=1000;
            let remainingPayments=30;
            let couponsReceived=0;
            let totalCoupons=30
            let couponDates=new Array(totalCoupons);
            let maturityDate;

            let initYear=thisDate.getFullYear();
            let initMonth=thisDate.getMonth();
            let initDate


            let newInitYear,newInitMonth,newInitDate;

            if(initMonth<11){
                newInitMonth=initMonth+1
                newInitDate=1
                newInitYear=initYear
                maturityDate=new Date(initYear+15,newInitMonth,newInitDate);
            }else{
                newInitMonth=0
                newInitDate=1
                newInitYear=initYear+1
                maturityDate=new Date(initYear+16,newInitMonth,newInitDate);
            }

            let nextYear=newInitYear
            let nextMonth=newInitMonth;
            let nextDate=newInitDate;
            let monthDiff;


            for (let l=0; l<totalCoupons;l++){
                if(newInitMonth+6<12){
                    if(l%2===0){
                        nextMonth+=6
                    }else{
                        nextYear=nextYear+1
                        nextMonth=newInitMonth
                    }
                }else{
                    monthDiff=nextMonth+6-11;
                    if(l%2===0){
                        nextYear=nextYear+1
                        nextMonth=monthDiff
                    }else{
                        nextMonth=newInitMonth
                    }
                }
                couponDates[l]=new Date(nextYear,nextMonth,nextDate).toUTCString();
            }


            monthlyPayout=(couponRate*faceValue);

            PoolID=crypto.createHash('sha256', secret).update("POOL").digest('hex');

            TransactionID=crypto.createHash('sha256', secret).update('TransactionID').digest('hex');
            typeID=':0'
            tokenID="BondToken"+OwnerClientID+TransactionID+typeID;
            amount="15";
            price="110.12"

            //lets suppose test_amount is less than amount
            test_amount="10"
            test_price=price

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex')
            BondToken={
                ID: tokenID,
                GenericID: TransactionID,
                TypeID: typeID,
                Rating: "BBB",
                CouponRate: couponRate,
                MaturityDate: maturityDate.toUTCString(),
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Pool: 'POOL'+PoolID,
                AmountPaid: "",
                FaceValue: faceValue,
                MonthlyPayout: monthlyPayout.toFixed(2),
                CouponDates: couponDates,
                CouponsReceived: couponsReceived,
                RemainingPayments: remainingPayments,
                Amount: 100,
                CanBeUsed: true,
                NotBefore: couponDates[0]
            };

            securitizationCoinID=crypto.createHash('sha256', secret).update("securitizationCoinID").digest('hex');
            securitizationCoin={
                ID:'securitizationCoin'+OwnerClientID+securitizationCoinID+':0',
                GenericID: securitizationCoinID,
                TypeID: ':0',
                Issuer: OwnerClientCertAsBytes,
                Owner: OwnerClientID,
                Amount: Amount,
                Factor: 100,
                CanBeUsed: true
            }
            todayDate=new Date();
            argTodayDate=todayDate.toUTCString();

            genericID=crypto.createHash('sha256', secret).update("genericID").digest('hex');

            mockStub.getDateTimestamp.returns(argTodayDate);
            mockStub.getTxID.returns(genericID);
            mockStub.createCompositeKey.withArgs('BidOrder',[genericID]).returns('BidOrder'+genericID);
            mockClientIdentity.getMSPID.returns('investorMSP')
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,securitizationCoinID]).returns('securitizationCoin'+OwnerClientID+securitizationCoinID);
            mockClientIdentity.getIDBytes.returns(OwnerClientCertAsBytes);
            mockClientIdentity.getAttributeValue.withArgs('cif').returns(OwnerClientID);
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(true);
            FunctionAndParameters={
                fcn: 'QueryOrderBook',
                params: []
            }
            mockStub.getFunctionAndParameters.returns(FunctionAndParameters)
        })
        it('Should throw an error if user is neither a SPV nor an Investor member', async () =>{
            let wrong_OrgMSP="originatorMSP"
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('QueryOrderBook should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        });
        it('Should throw an error if user is not a client', async ()=>{
            mockClientIdentity.assertAttributeValue.withArgs('role','client').returns(false)
            // mockStub.getState.withArgs(new_BondToken.ID).returns(Buffer.from(JSON.stringify(new_BondToken)))
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('QueryOrderBook should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`You are not allowed to perform this action`)
            }
        });
        it('Should through an error if user is not an investor',async ()=>{
            wrong_OrgMSP='ratingagencyMSP';
            mockClientIdentity.getMSPID.returns(wrong_OrgMSP)
            try{
                await contract.beforeTransaction(ctx);
                assert.fail('QueryOrderBook should throw an Error');
            }catch(err) {
                expect(err.name).to.equal('Error');
                expect(err.message).to.equal(`Your organization ${wrong_OrgMSP} is not allowed to perform this action`)
            }
        })
        it('Should throw an error if OrderBook does not exist',async ()=>{
            await contract.beforeTransaction(ctx);
            try{
                await contract.QueryOrderBook(ctx);
                assert.fail('QueryOrderBook should throw an Error');
            }catch (err) {
                expect(err.name).to.equal('Error')
                expect(err.message).to.equal(`Order Book does not exist`)
            }
        })
        it('Should return Order Book',async ()=>{
            // create a full-of-orders order book
            let orderArray=[];
            let token


            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
            mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            function randomBetween(min,max){
                return Math.random()*(max-min)+min
            }

            // BIDS
            for (let i=0;i<100;i++){
                let BidOrder={

                };
                let securitizationCoin={

                };
                GenericID=crypto.createHash('sha256', secret).update('Bid'+i.toString()).digest('hex');
                ID="BidOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='securitizationCoin'+OwnerClientID+NewGenericID+':0'
                // Quantity=Math.floor(randomBetween(1,100))
                Quantity=Math.floor(randomBetween(1,100))
                Price=randomBetween(100.00,110.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Bid"

                BidOrder.ID=ID;
                BidOrder.TokenID=TokenID;
                BidOrder.Quantity=Quantity;
                BidOrder.Price=parseInt(Price*100);
                BidOrder.MarketPrice=MarketPrice;
                BidOrder.PartialMatch=PartialMatch;
                BidOrder.FullMatch=FullMatch;
                BidOrder.QuantityMatch=QuantityMatch;
                BidOrder.RestingQuantity=RestingQuantity;
                BidOrder.Time=Time;
                BidOrder.Name=Name
                orderArray.push(BidOrder)

                TypeID=':0';
                ID='securitizationCoin'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=parseInt(Price*100*Quantity);
                Factor=100;
                CanBeUsed=true;

                securitizationCoin.ID=ID;
                securitizationCoin.GenericID= NewGenericID;
                securitizationCoin.TypeID= TypeID;
                securitizationCoin.Issuer=Issuer;
                securitizationCoin.Owner= Owner;
                securitizationCoin.Amount=Amount;
                securitizationCoin.Factor=Factor;
                securitizationCoin.CanBeUsed=CanBeUsed
                securitizationCoinBuffer=JSON.stringify(securitizationCoin)
                cashTokensArray.push(securitizationCoin);
                mockStub.putState(securitizationCoin.ID,Buffer.from(JSON.stringify(securitizationCoin)));
                mockStub.getState.withArgs(securitizationCoin.ID).returns(Buffer.from(JSON.stringify(securitizationCoin)))
                mockStub.deleteState.withArgs(securitizationCoin.ID).returns();


                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            }

            let BidOrderArray_Ordered=await sortingBidOrders(orderArray);

            orderArray=[]
            let askPrice=[];
            // ASKS
            // comparador is the upperBound
            let comparador=113.05
            let quantityMatched=0
            for (let i=0;i<100;i++){
                // let comp=Math.random()
                let AskOrder={

                };
                let bondToken={

                };
                GenericID=crypto.createHash('sha256', secret).update(i.toString()).digest('hex');
                ID="AskOrder"+GenericID;
                NewGenericID=crypto.createHash('sha256', secret).update(i.toString()+OwnerClientID).digest('hex')
                TokenID='BondToken'+OwnerClientID+NewGenericID+":0"

                Quantity=Math.floor(randomBetween(2,100))
                Price=randomBetween(110.10,115.05).toFixed(2)
                MarketPrice=false
                PartialMatch=false
                FullMatch=false
                QuantityMatch=0
                RestingQuantity=Quantity
                Time=todayDate.getTime()
                Name="Ask"

                AskOrder.ID=ID;
                AskOrder.TokenID=TokenID;
                AskOrder.Quantity=Quantity;
                AskOrder.Price=parseInt(Price*100);
                AskOrder.MarketPrice=MarketPrice;
                AskOrder.PartialMatch=PartialMatch;
                AskOrder.FullMatch=FullMatch;
                AskOrder.QuantityMatch=QuantityMatch;
                AskOrder.RestingQuantity=RestingQuantity;
                AskOrder.Time=Time;
                AskOrder.Name=Name
                orderArray.push(AskOrder)

                TypeID=':0';
                ID='BondToken'+OwnerClientID+NewGenericID+TypeID
                Issuer=OwnerClientCertAsBytes;
                Owner=OwnerClientID;
                Amount=Quantity;
                CanBeUsed=true;

                bondToken.GenericID=NewGenericID;
                bondToken.ID=ID;
                bondToken.TypeID=TypeID;
                bondToken.Issuer=Issuer;
                bondToken.Owner=Owner;
                bondToken.Amount=Amount;
                bondToken.CanBeUsed=CanBeUsed;
                bondToken.Rating=BondToken.Rating;
                bondToken.CouponRate=BondToken.CouponRate;
                bondToken.MaturityDate=BondToken.MaturityDate;
                bondToken.FaceValue=BondToken.FaceValue;
                bondToken.Pool=BondToken.Pool;
                bondToken.AmountPaid=BondToken.AmountPaid;
                bondToken.MonthlyPayout=BondToken.MonthlyPayout;
                bondToken.RemainingPayments=BondToken.RemainingPayments;
                bondToken.CouponDates=BondToken.CouponDates;
                bondToken.CouponsReceived=BondToken.CouponsReceived;
                bondToken.NotBefore=BondToken.NotBefore;

                bondTokensArray.push(bondToken);

                mockStub.putState(bondToken.ID,Buffer.from(JSON.stringify(bondToken)));
                mockStub.getState.withArgs(bondToken.ID).returns(Buffer.from(JSON.stringify(bondToken)))
                if (Price<=comparador){
                    quantityMatched+=Quantity
                }

                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('BondToken',[OwnerClientID,genericID]).returns('BondToken'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)
                mockStub.createCompositeKey.withArgs('securitizationCoin',[OwnerClientID,genericID]).returns('securitizationCoin'+OwnerClientID+genericID)


            }


            let AskOrderArray_Ordered=await sortingAskOrders(orderArray);


            //search for a match (BID matches several ASKS)=> BidOrder
            // AMount big enough to not full match bid Order
            amount=quantityMatched-1;
            price=comparador

            GenericID=crypto.createHash('sha256', secret).update((amount*price).toString()).digest('hex')
            TypeID=':0';
            new_securitizationCoin={
                GenericID: GenericID,
                TypeID:':0',
                ID:'securitizationCoin'+OwnerClientID+GenericID+TypeID,
                Issuer:OwnerClientCertAsBytes,
                Owner:OwnerClientID,
                Amount:parseInt(price*100*amount),
                Factor:100,
                CanBeUsed:true,
            }

            mockStub.putState(new_securitizationCoin.ID,Buffer.from(JSON.stringify(new_securitizationCoin)));
            mockStub.getState.withArgs(new_securitizationCoin.ID).returns(Buffer.from(JSON.stringify(new_securitizationCoin)))
            mockStub.createCompositeKey.withArgs('securitizationCoin',[new_securitizationCoin.Owner,new_securitizationCoin.GenericID]).returns('securitizationCoin'+new_securitizationCoin.Owner+new_securitizationCoin.GenericID)


            currentOrder={
                ID: 'BidOrder'+genericID,
                Quantity: parseInt(amount),
                Price: parseInt(price*100),
                TokenID: new_securitizationCoin.ID,
                FullMatch: false,
                PartialMatch: false,
                MarketPrice: false,
                QuantityMatch: 0,
                RestingQuantity: parseInt(amount),
                Name: 'Bid',
                Time: new Date(argTodayDate).getTime()
            };



            orderBook=[BidOrderArray_Ordered,AskOrderArray_Ordered,[]]
            // mockStub.getState.withArgs("OrderBook").returns(Buffer.from(JSON.stringify(orderBook)))

            let asks=orderBook[1];
            // "Match engine"
            let bidReference=currentOrder;

            let bondKeyAcumulator=[];
            let tokenAcumulator=[];
            let counter=bidReference.Quantity;
            let balance=0;
            let totalTokens=0;
            let tokensCounter=new_securitizationCoin.Amount;
            let balanceTokens=0;
            let myTokens=0
            let referencePrice;
            for await (const ask of asks) {
                if (ask.Price<=bidReference.Price && !ask.FullMatch && myTokens<bidReference.Quantity ){
                    counter=counter-ask.Quantity;
                    balance=ask.Quantity+counter;
                    tokensCounter=tokensCounter-(ask.Quantity*ask.Price);
                    balanceTokens=(ask.Quantity*ask.Price)+tokensCounter;
                    // FULL MATCH means that our submitted order with that size has been completed
                    if (counter>=0){
                        // FULL MATCH
                        ask.QuantityMatch=ask.Quantity;
                        ask.FullMatch=true;
                        ask.PartialMatch=false;
                        tokenAcumulator.push(ask);
                        bondKeyAcumulator.push(ask.TokenID);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=ask.Quantity
                        referencePrice=ask.Price
                    }else{
                        // PARTIAL MATCH means that our submitted order with that size has been completed partially
                        // PARTIAL MATCH
                        ask.FullMatch=false;
                        ask.PartialMatch=true;
                        ask.QuantityMatch=balance;
                        bondKeyAcumulator.push(ask.TokenID);
                        tokenAcumulator.push(ask);
                        totalTokens=totalTokens+(ask.Price*ask.QuantityMatch);
                        myTokens+=balance
                        referencePrice=ask.Price
                    }
                }else{
                    continue
                }
            }
            let newID
            if (myTokens===bidReference.Quantity){
                // Full Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=true;
                currentOrder.PartialMatch= false;
                currentOrder.QuantityMatch=currentOrder.Quantity;
                // currentOrder.MatchID=bidReference.MatchID;
            }else if(myTokens<bidReference.Quantity && myTokens!==0){
                // Partial Match
                // currentOrder.ID=orderID
                currentOrder.TokenID=new_securitizationCoin.ID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch= true;
                currentOrder.QuantityMatch=myTokens;
                // //console.log('final')
                // currentOrder.Quantity=counter;
                // currentOrder.MatchID=bidReference.MatchID;
            }else{
                // //console.log('paso 7.3')
                // No match
                // currentOrder.ID=orderID
                newID="";
                currentOrder.TokenID=newID;
                currentOrder.FullMatch=false;
                currentOrder.PartialMatch=false;
            }
            // check if there is matching
            orderBook[0].push(currentOrder)



            let NewBondToken=Object.assign({}, BondToken );
            NewBondToken.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewBondToken.GenericID=NewBondTokenID;
            NewBondToken.ID='BondToken'+NewBondToken.Owner+NewBondTokenID+':0';
            NewBondToken.TypeID=':0'

            let NewSecuritizationCoin=Object.assign({}, new_securitizationCoin );
            NewSecuritizationCoin.Amount=currentOrder.Quantity-currentOrder.QuantityMatch;
            // let NewBondTokenID=crypto.createHash('sha256', secret).update("NewBondTokenID").digest('hex')
            NewSecuritizationCoin.GenericID=genericID;
            NewSecuritizationCoin.ID='securitizationCoin'+new_securitizationCoin.Owner+NewSecuritizationCoin.GenericID+':1';
            NewSecuritizationCoin.TypeID=':1'
            // we have to mock our "delivery v. payment" function, namely _transferCashTokens

            // this function has to return the updated orderbook, i.e, with tokens IDs updates, resting quantities,
            // quantity match

            // As we know this function performs OK we just return this updated orderBook
            asks=orderBook[1];
            let bids=orderBook[0];
            orderBook[2]=[referencePrice]
            // orderBook[2]=[referencePrice]
            let newBids=await bids.filter(item=> item.FullMatch!==true)
            let newAsks=await asks.filter(item=> item.FullMatch!==true)

            // and update those orders partial matched
            let newPartialBids=await newBids.filter(item=> item.PartialMatch===true)
            let newPartialAsks=await newAsks.filter(item=> item.PartialMatch===true)
            //console.log('----------newPartialAsks------------------')
            //console.log(newPartialAsks)
            //console.log('------------------------------------')
            //console.log('----------newPartialBids------------------')
            //console.log(newPartialBids)
            //console.log('----------------------------------')
            let index;
            let bondOutputKey;

            for (let t=0; t<newPartialAsks.length;t++){
                // ////console.log('newPartialAsks')
                index=newAsks.indexOf(newPartialAsks[t])

                let newBondToken=await bondTokensArray.filter(item=> item.ID===newPartialAsks[t].TokenID)
                ////console.log('newBondToken')
                ////console.log(newBondToken[0])
                ////console.log('------------------')
                newBondToken[0].Amount=newBondToken[0].Amount-(newPartialAsks[t].QuantityMatch*newPartialAsks[t].Price);
                newBondToken[0].GenericID=genericID;
                newBondToken[0].ID='BondToken'+newBondToken[0].Owner+genericID+':1';

                bondOutputKey=newBondToken[0].ID
                newPartialAsks[t].TokenID=newBondToken[0].ID

                ////console.log('newBondToken')
                ////console.log(newBondToken[0])
                ////console.log('------------------')

                newPartialAsks[t].PartialMatch=false;
                newPartialAsks[t].Quantity=newPartialAsks[t].Quantity-newPartialAsks[t].QuantityMatch
                newPartialAsks[t].QuantityMatch=0
                newPartialAsks[t].RestingQuantity=newPartialAsks[t].Quantity

                newAsks[index]=newPartialAsks[t]
            }
            for (let l=0; l<newPartialBids.length;l++){
                // //console.log('newPartialBids')
                index=newBids.indexOf(newPartialBids[l])

                newPartialBids[l].PartialMatch=false;
                newPartialBids[l].Quantity=newPartialBids[l].Quantity-newPartialBids[l].QuantityMatch
                newPartialBids[l].QuantityMatch=0
                newPartialBids[l].RestingQuantity=newPartialBids[l].Quantity
                newPartialBids[l].TokenID=NewSecuritizationCoin.ID
                newBids[index]=newPartialBids[l]
            }


            let newOrderBook=[newBids,newAsks,orderBook[2]];
            mockStub.getState.withArgs('OrderBook').returns(Buffer.from(JSON.stringify(newOrderBook)))
            let ret=await contract.QueryOrderBook(ctx)
            expect(ret).to.eql(newOrderBook)
        })
    })
    // describe('TESTING: auxiliary function _mygetStateByPartialCompositeKey works as expected',()=>{

    //     let name;
    //     let userID;
    //     let state;
    //     beforeEach(() => {
    //         // ////console.log('auxiliary function')


    //     })
    //     it('Should throw an error if there are more than one state',async () =>{
    //         try{

    //         }catch (err) {
    //             expect(err.name).to.equal('Error');
    //             expect(err.message).to.equal(`Partial Key Uniqueness not provided. Something went wrong`)
    //         }
    //         await contract._mygetStateByPartialCompositeKey(ctx,name, userID)
    //     })

    //     it('Should return true if there is no State linked to that partial key',async () =>{
    //         let ret= await contract._mygetStateByPartialCompositeKey(ctx,name, userID)
    //         expect(ret).to.eql(true)
    //     })
    //     it('Should return state if there is one State linked to that partial key',async () =>{
    //         let ret= await contract._mygetStateByPartialCompositeKey(ctx,name, userID)
    //         expect(ret).to.eql(state)
    //     })
    // })
})